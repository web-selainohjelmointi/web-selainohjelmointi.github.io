<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Web-selainohjelmointi</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/sh_style.css">
    <link rel="stylesheet" href="css/weso.css">
    <script src="js/jquery.js"></script>
    <script src="js/mustache.min.js"></script>
    <script src="js/material.js"></script>


    <script type="text/javascript" src="js/sh_main.js"></script>
    <script type="text/javascript" src="js/sh_java.js"></script>
    <script type="text/javascript" src="js/sh_xml.js"></script>
    <script type="text/javascript" src="js/sh_html.js"></script>
    <script type="text/javascript" src="js/sh_css.js"></script>
    <script type="text/javascript" src="js/sh_javascript_dom.js"></script>
    <script>
      jQuery(document).ready(function() {
      Material.createContentList();
      Material.createExerciseList();
      sh_highlightDocument();
      });
    </script>
  </head>
  <body>

    <!-- BEGIN NAV -->
    <header role="navigation">
      <h1>
        <button type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>

        <a href="http://www.cs.helsinki.fi/"><img src="img/header_tktl.png" alt="CS Dept. Univ. Helsinki"></a>
      </h1>
      <nav class="collapse bs-navbar-collapse" role="navigation">
        <ul>
          <li class="active">
            <a href="#">Web-selainohjelmointi</a>
          </li>
          <li>
            <a href="#viikko1">Viikko 1</a>
          </li>
          <li>
            <a href="#viikko2">Viikko 2</a>
          </li>
          <li>
            <a href="#viikko3">Viikko 3</a>
          </li>
          <li>
            <a href="#viikko4">Viikko 4</a>
          </li>
          <li>
            <a href="#viikko5">Viikko 5</a>
          </li>
          <li>
            <a href="#viikko6">Viikko 6</a>
          </li>
          <li>
            <a href="#viikko7">Viikko 7</a>
          </li>
        </ul>
      </nav>
    </header>
    <article>
      <section>
        <header>
          <h1 data-week-id="1">Lukijalle</h1>
        </header>

        <p>Tämä materiaali on tarkoitettu Helsingin yliopiston
          tietojenkäsittelytieteen laitoksen keväällä ja kesällä 2015
          järjestettävälle kurssille web-selainohjelmointi. Materiaali
          pohjautuu <a href="http://www.cs.helsinki.fi/group/java/s12-weso/"
          target="_blank">syksyn 2012 kurssiin</a>, ja sen
          kirjoittajat ovat Kalle Ilves ja Arto Vihavainen. Vuoden
          2012 materiaalin syntyyn ovat vaikuttaneet useat tahot,
          joista tärkein lienee Mikael Nousiainen. Iso kiitos kuuluu
          myös Kasper Hirvikoskelle. Kurssia web-selainohjelmointi on
          edeltänyt aiemmin järjestetty kurssi Digitaalisen Median
          tekniikat, jonka tämä kurssi korvaa. "DiMe"-kurssin
          viimeisten vetäjien Samuli Kaipiaisen ja Matti Paksulan
          henki kuitenkin elää kurssilla. </p>

<!--
        <p>Materiaali päivittyy kurssin edetessä. Osa tehtävistä on osana
          materiaalia, osa taas linkkeinä omille sivuilleen. Tehtävien lisäksi
          materiaali sisältää kysymysmerkillä merkittyjä <em>pohdi</em>-kohtia,
          joissa pääsee pohtimaan juuri tutuksi tullutta asiaa esimerkin kautta.
          Lampuilla merkityt kohdat taas sisältävät mm. arvokkaita vinkkejä
          erilaisista työkaluista.</p>
-->

        <p><!-- Materiaali päivittyy kurssin edetessä.--> Lue materiaalia
          siten, että teet samalla itse kaikki lukemasi
          esimerkit. Esimerkkeihin kannattaa tehdä pieniä muutoksia ja
          tarkkailla, miten muutokset vaikuttavat ohjelman
          toimintaan. Äkkiseltään voisi luulla, että esimerkkien
          tekeminen ja muokkaaminen hidastaa opiskelua.  Tämä ei
          kuitenkaan pidä ollenkaan paikkansa. Oppiminen perustuu
          oleellisesti aktiiviseen tekemiseen ja rutiinin
          kasvattamiseen.  Esimerkkien ja erityisesti omien kokeilujen
          tekeminen on parhaita tapoja sisäistää luettua. Muista että
          copy-paste ei ole oppimisen kannalta yhtä tehokasta kuin
          itse kirjoittaminen.</p>

<!--
        <p>Pyri tekemään tai ainakin yrittämään tehtäviä sitä mukaa
          kuin luet tekstiä. Jos et osaa heti tehdä jotain tehtävää,
          älä masennu, sillä saat ohjausaikoina neuvoja tehtävien
          tekemiseen.</p>
-->

        <p>Tekstiä ei ole tarkoitettu vain kertaalleen
          luettavaksi. Joudut varmasti myöhemmin palaamaan aiemmin
          lukemiisi kohtiin tai aiemmin tekemiisi tehtäviin. Tämä
          materiaali ei sisällä kaikkea oleellista
          web-selainohjelmointiin liittyvää. Tällä hetkellä ei ole
          oikeastaan mitään kirjaa josta löytyisi kaikki
          oleellinen. Joudut kurssin aikana ja urallasi etsimään
          tietoa myös omatoimisesti. Harjoitukset ja materiaali
          sisältävät jo jonkin verran ohjeita, mistä suunnista tietoa
          kannattaa lähteä hakemaan.</p>

        <p>Jos (ja kun) materiaalista löytyy esimerkiksi
          kirjoitusvirheitä, korjaa tilanne, ja tee pull-request
          osoitteessa <a href="https://github.com/web-selainohjelmointi/web-selainohjelmointi.github.io"
          target="_blank">https://github.com/web-selainohjelmointi/web-selainohjelmointi.github.io</a>. Kiitos
          bugien ja ongelmien korjauksesta kuuluu jo nyt seuraaville
          nimimerkeille: pro_, gleant, BiQ, Absor, Rase, jombo,
          BearGrylls, Marko, _jumi_, jykke, Semilia, Walther, Loezi,
          happosade, doge ja mluukkai.</p>

<!--
        <h2>Aikataulu</h2>
        <p>
          Kurssin viikottaisten tehtävien viimeinen palautushetki on torstaisin kello 23:59. Ensimmäinen deadline on 19.3.2015.
        </p>
-->

        <div style="display: table">
          <div style="display: table-cell">
            <h2>Sisältö</h2>
            <div id="materiaali-sisalto"></div>
          </div>
          <div style="display: table-cell; padding-left: 35px">
            <h2>Tehtävät</h2>
            <div id="tehtava-sisalto"></div>
          </div>
        </div>
      </section>

      <section class="week">
        <header>
          <a name="viikko1"></a>
          <h1 data-week-id="1">Viikko 1</h1>
        </header>

	<h2>Tools of the trade</h2>

	<p>Käydään läpi pikaisesti oleellisia työkaluja.</p>

	<h3>Web-selainten tarjoamat kehittäjien työkalut</h3>

	<p>Ohjelmien debuggaaminen on oleellinen taito. Selainohjelmistot pyörivät selaimessa, joten luonnollinen paikka niiden debuggaamiseen on selaimessa. Esimerkiksi google chrome ja mozilla firefox tarjoavat debuggausympäristöt, joilla voi tutkia sivuja. Debuggausympäristöt aukeavat yleensä nappia f12-painamalla. Oleellisin osio lienee konsoli, mistä näkee esimerkiksi JavaScript-suorituksessa tapahtuvat virheviestit.</p>

	<p>Tutustu Chrome Developer Toolseihin osoitteessa <a href="https://developers.google.com/chrome-developer-tools/" target="_blank">https://developers.google.com/chrome-developer-tools/</a></p>

	<h3>NetBeans</h3>

	<p>Kurssilla käytetään oletuksena NetBeans-ohjelmointiympäristön uusinta versiota (tätä kirjoitettaessa 8.0.2). Kurssin tehtävät palautetaan TMC:n kautta. Kaikille avointen verkkokurssien mooc.fi -sivusto tarjoaa hyvät <a href="http://mooc.fi/courses/general/ohjelmointi/asentaminen/" target="_blank">asennusohjeet NetBeansille ja TMC:lle</a>. Jos et halua käyttää NetBeansia, tehtävät voi palauttaa myös TMC:n <a href="https://tmc.mooc.fi/hy" target="_blank">web-sivujen</a> kautta.</p>

	<p>Huom! Toisin kuin kurssilla web-palvelinohjelmointi, TMC <em>ei</em> tarkasta tehtävien oikeellisuutta. Palauttaessasi tehtävän lupaat sen olevan oikein.</p>

	<p>Seuraa <a href="http://mooc.fi/courses/general/ohjelmointi/asentaminen/" target="_blank">asennusohjeita</a> ja asenna tarvitsemasi työvälineet. Valitse TMC NetBeansin asetuksista palvelimeksi <code>https://tmc.mooc.fi/hy</code> ja kurssiksi <code>kesa2015-weso</code>. Kun teet käyttäjätunnusta TMC:hen, käytä opiskelijanumeroasi käyttäjätunnuksena.</p>


	<h3>Internet</h3>

	<p>Web on täynnä selainohjelmointiin liittyviä artikkeleita. Oikeasti! Googlehaku lauseella "html5 introduction" palauttaa hieman yli 30000 sivua (helmikuu 2015). Jos avainsanat ovat erikseen, tuloksia on lähes neljä miljoonaa. Kun teet kurssin tehtäviä, käytä googlea avuksi. Tätä materiaalia ei yritetäkään rakentaa kaiken kattavaksi, vaan joudut etsimään tietoa myös internetistä. </p>

	<p>Jos mietit että miten vaikkapa <code>article</code>-elementille asetetaan reunat, voit googlettaa esimerkiksi avainsanoilla "html5 article css border". Ensimmäisen kymmenen artikkelin joukossa on (lähes) varmasti sinua auttava artikkeli. Itseasiassa, informaation hakeminen netistä on taito siinä missä ohjelmointikin -- sitä kannattaa ja pitää harjoitella.</p>


	<h2>HTML</h2>

	<p>HTML on kieli web-sivustojen luomiseen. HTML ei ole ohjelmointikieli, vaan kuvauskieli, jonka avulla kuvataan sekä web-sivun rakenne että sivun sisältämä teksti. HTML-sivujen rakenne määritellään HTML-kielessä määritellyillä elementeillä, ja yksittäinen HTML-dokumentti koostuu sisäkkäin ja peräkkäin olevista elementeistä.</p>

	<p>Sivujen rakenteen määrittelevät elementit erotellaan pienempi kuin (&lt;) ja suurempi kuin (&gt;) -merkeillä. Elementti avataan elementin nimen sisältävällä pienempi kuin -merkillä alkavalla ja suurempi kuin -merkkiin loppuvalla merkkijonolla, esim. <code>&lt;html&gt;</code>, ja suljetaan merkkijonolla jossa elementin pienempi kuin -merkin jälkeen on vinoviiva, esim <code>&lt;/html&gt;</code>. Yksittäisen elementin sisälle voi laittaa muita elementtejä.</p>

  <p>Suurin osa elementeistä tulee sulkea lopuksi. Osa HTML5:n elementeistä &ndash; esimerkiksi <code>&lt;br&gt;</code> &ndash; on kuitenkin ns. tyhjiä ("void"), eikä niille kirjoiteta erillistä lopetusta. Halutessaan tyhjät elementit voi lopettaa X(HT)ML-tyyliseen /-merkkiin, esimerkiksi seuraavasti: <code>&lt;br /&gt;</code>.</p>


	<h3>HTML-dokumentin runko</h3>


	<p>Tyypillisen HTML-dokumentin runko näyttää seuraavalta:</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Selaimen palkissa ja suosikeissa näkyvä otsikko&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;

        &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä.&lt;/p&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

	<p>Yllä olevassa HTML-dokumentissa on dokumentin tyypin kertova erikoiselementti <code>&lt;!DOCTYPE html&gt;</code>, joka kertoo dokumentin olevan HTML-sivu. Tätä seuraa elementti <code>&lt;html&gt;</code>, joka aloittaa HTML-dokumentin. Elementti <code>&lt;html&gt;</code> sisältää yleensä kaksi elementtiä, elementit <code>&lt;head&gt;</code> ja <code>&lt;body&gt;</code>. Elementti <code>&lt;head&gt;</code> sisältää sivun otsaketiedot, eli esimerkiksi sivun käyttämän merkistön <code>&lt;meta charset="utf-8" /&gt;</code> ja otsikon <code>&lt;title&gt;</code>. Elementti <code>&lt;body&gt;</code> sisältää selaimessa näytettävän sivun rungon. Ylläolevalla sivulla on ensimmäisen tason otsake-elementti <code>h1</code> (<em>header 1</em>) ja tekstielementti <code>p</code> (<em>paragraph</em>).</p>

	<p>Elementit voivat sisältää attribuutteja, joilla voi olla yksi tai useampi arvo. Yllä olevassa HTML-dokumentissa elementille <code>meta</code> on määritelty erillinen attribuutti <code>charset</code>, joka kertoo dokumentissa käytettävän merkistön: "utf-8". Attribuuttien lisäksi elementit voivat sisältää <em>tekstisolmun</em>. Esimerkiksi yllä olevat elementit <code>title</code>, <code>h1</code> ja <code>p</code> kukin sisältävät tekstisolmun eli tekstiä. Tekstisolmulle ei ole erillistä elementtiä tai määrettä, vaan se näkyy tekstinä.</p>

	<p>Puhe tekstisolmuista antaa viitettä jonkinlaisesta puurakenteesta. HTML-dokumentit, aivan kuten XML-dokumentit, ovat rakenteellisia dokumentteja, joiden rakenne on usein helppo ymmärtää puumaisena kaaviona. Ylläolevan web-sivun voi esittää esimerkiksi seuraavanlaisena puuna (attribuutit ja dokumentin tyyppi on jätetty merkitsemättä).</p>

<pre>
                   html
               /          \
             /              \
          head              body
        /       \         /      \
     meta       title     h1      p
                 :        :       :
              tekstiä  tekstiä tekstiä
</pre>

	<p>Koska HTML-dokumentti on rakenteellinen dokumentti, on elementtien sulkemisjärjestyksellä väliä. Elementit tulee sulkea samassa järjestyksessä kuin ne on avattu. Esimerkiksi, järjestys <code>&lt;body&gt;&lt;p&gt;whoa, minttutee!&lt/body&gt;&lt;/p&gt;</code> on väärä, kun taas järjestys <code>&lt;body&gt;&lt;p&gt;whoa, minttutee!&lt;/p&gt;&lt/body&gt;</code> on oikea.</p>

	<p>Kaikki elementit eivät kuitenkaan sisällä tekstisolmua, eikä niitä suljeta erikseen. Yksi näistä poikkeuksista on <a href="http://www.w3schools.com/tags/tag_link.asp" target="_blank">link</a>-elementti.</p>

	<p>Kun selaimet lataavat HTML-dokumenttia, ne käyvät sen läpi ylhäältä alas, vasemmalta oikealle. Kun selain kohtaa elementin, se luo sille uuden solmun. Seuraavista elementeistä luodut solmut menevät aiemmin luodun solmun alle kunnes aiemmin kohdattu elementti suljetaan. Aina kun elementti suljetaan, puussa palataan ylöspäin edelliselle tasolle.</p>


<aside class="pohdi">
    <p><strong>Web-sivujen läpikäynti</strong></p>

    <p>Miltä seuraavaa HTML-dokumenttia kuvaava puu näyttää?</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;PSY: Gangnam Style&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;p&gt;"Gangnam Style" is a single by South Korean rapper PSY, that has been viewed
        over 2 billion times on &lt;a href="http://www.youtube.com"&gt;YouTube&lt;/a&gt;&lt;/p&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>


    <p>Entä seuraavalla HTML-dokumentilla?</p>


<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;PSY: Gangnam Style&lt;/title&gt;
    &lt;body&gt;

        &lt;p&gt;"Gangnam Style" is a single by South Korean rapper PSY, that has been viewed
        over 2 billion times on &lt;a href="http://www.youtube.com"&gt;YouTube&lt;/p&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

</aside>


<div class="tehtavat">
  <h3>Ascii Artist</h3>

  <p>Huom! Jos NetBeans ei suostu avaamaan tehtäviä ja valittaa esimerkiksi "failed to download exercises", varmista että käytössäsi on HTML5-tuki. Tämän tuen saa ladattua NetBeansin Tools->Plugins -valikosta. Ladattu liitännäinen aktivoituu viimeistään kun luot uuden HTML5-projektin (File -> New Project -> HTML5 -> ...).</p>

  <p>Tehtäväpohjassa olevassa kansiossa <code>src</code> (tai Site Root) on dokumentti <code>index.html</code>. Muokkaa dokumenttia siten, että sen katsominen selaimessa näyttää seuraavannäköisen ASCII-taideteoksen (käytettävän fontin ei tarvitse olla sama).</p>

  <img src="img/ascii-artist.png" alt="käytä pre-elementtiä tekstimuotoisen taideteoksen luomiseen" border=1/>

  <p>Huom! Yllä näkyvän kuvakaappauksen ympärille asetettuja reunoja ei tarvitse piirtää omaan sivuun.</p>


  <p>Koska taideteos on ASCII-taidetta, et luonnollisestikaan saa käyttää sivussa kuvaa. Vinkki taideteoksen tekemiseen on yllä olevassa kuvassa. Kun taideteoksesi toimii Chromessa, palauta tehtävä TMC:lle.</p>

</div>


    <h3>Listaelementit</h3>

    <p>Sivuille voi lisätä listoja mm. <code>ol</code> (<em>ordered list</em>) ja <code>ul</code> (<em>unordered list</em>) -elementtien avulla. Elementeillä <code>ol</code> tai <code>ul</code> aloitetaan lista, ja listan sisälle asetettavat yksittäisiin listaelementteihin käytetään <code>li</code> (<em>list item</em>)-elementtiä. Yksittäiset listaelementit voivat taas sisältää esimerkiksi tekstisolmun tai lisää html-elementtejä.</p>


<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Selaimen palkissa ja suosikeissa näkyvä otsikko&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;

        &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä,
        listaelementtiä voi käyttää esimerkiksi ostoslistan tekemiseen.&lt;/p&gt;

        &lt;ol&gt;
            &lt;li&gt;kauraa&lt;/li&gt;
            &lt;li&gt;puuroa&lt;/li&gt;
            &lt;li&gt;omenaa&lt;/li&gt;
        &lt;/ol&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>Yllä oleva lista näyttää seuraavalta ilman muita elementtejä.</p>

<div class="naytto">
  <p>
    <ol>
      <li>kauraa</li>
      <li>puuroa</li>
      <li>omenaa</li>
    </ol>
  </p>
</div>


    <h3>Kuvien lisääminen</h3>

    <p>Jokaisen web-sivuja rakentavan ihmisen tulee ainakin kerran elämässään lisätä kuva web-sivuilleen. Sivuille saa lisättyä kuvia elementillä <code>img</code>, jolla on attribuutti <code>src</code>, jonka arvona on kuvan sijainti. Kuvan sijainti riippuu kuvan näyttävän html-tiedoston sijainnista. Jos kuva on samassa kansiossa <code>html</code>-dokumentin kanssa, tarvitsee <code>img</code>-elementin <code>src</code>-attribuutin arvoksi asettaa vain kuvan nimi.</p>

    <p>Esimerkiksi, jos tämän html-tiedoston sisältämässä kansiossa on kansio nimeltä "img", ja siellä kuvatiedosto nimeltä "lamppu.png", saa kuvatiedoston sivuille näkyville elementillä <code>&lt;img src="img/lamppu.png" /&gt;</code>. Koska kuvaelementti <code>img</code> ei sisällä muita elementtejä tai tekstiä, voi sen sulkea suoraan.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Selaimen palkissa ja suosikeissa näkyvä otsikko&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;

        &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä,
        listaelementtiä voi käyttää esimerkiksi ostoslistan tekemiseen.&lt;/p&gt;

        &lt;ol&gt;
            &lt;li&gt;kauraa&lt;/li&gt;
            &lt;li&gt;puuroa&lt;/li&gt;
            &lt;li&gt;omenaa&lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;Kuvan saa taas näytettyä img-elementillä. Välähtikö?&lt;/p&gt;

        &lt;img src="img/lamppu.png" /&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Kuva ilman muita sivujen elementtejä näyttää seuraavalta.</p>

<div class="naytto">
  <img src="img/lamppu.png"/>
</div>

    <h4>Kuvien oikeuksista</h4>

    <p>Netissä olevat kuvat ja tiedostot eivät ole vapaasti kaikkien käytettävissä. Jos teet sivuja itsellesi, tutuille tai kavereille, ja käytät niissä netistä löytynyttä materiaalia, muista varmistaa että käyttämäsi kuvat ovat laillisesti käytettäviä. Kuvien käyttöoikeuksien varmistaminen ei ole aina helppoa tai edes mahdollista -- kannattaakin käyttää vain sivustoja, joiden oikeuksista on varmuus.</p>

    <p>Esimerkiksi flickr-sivustolla on erillinen <code>creative commons</code>-osio, joka listaa kuvia, joiden käyttö on sallittua <em>tietyin ehdoin</em>. Löydät eri ehdot ja kuvia osoitteesta <a href="http://www.flickr.com/creativecommons/" target="_blank">http://www.flickr.com/creativecommons/</a>. On myös sivuja, jotka tarkoituksella keräävät materiaalia tiettyihin aiheisiin liittyen. Esimerkiksi sivusto <a href="http://opengameart.org/" target="_blank">OpenGameArt</a> tarjoaa vapaasti peleissä käytettäviä materiaaleja.</p>

    <h4>Kuvat ja käytettävyys</h4>

    <p>Riippuen käytössä olevasta laitteesta, sen asetuksista, ja lukijasta, kuvat eivät näy aina toivotulla tavalla. Sivuston käytettävyyttä voi helpottaa huomattavasti lisäämällä kuvaelementteihin <code>alt</code>-attribuutti, millä kerrotaan tekstuaalisesti mitä kuvassa on.</p>

    <p>Tällöin, jos kuvat eivät näy käyttäjälle, voi hän kuitenkin lukea kuvaan liittyvän kuvauksen, mikä mahdollisesti selkiyttää sivun ymmärrettävyyttä.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Selaimen palkissa ja suosikeissa näkyvä otsikko&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;p&gt;...&lt;/p&gt;

        &lt;img src="img/lamppu.png" alt="Kuva lampusta" /&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>


    <h3>Linkit toisille sivuille</h3>

    <p>Elementin <code>a</code> (<em>anchor</em>) avulla voi luoda linkin sivulta toiselle. Sivu, jolle käyttäjä siirtyy, merkitään elementin <code>a</code> attribuutin <code>href</code> arvolla. Jos sovelluksessasi on kaksi sivua, <code>index.html</code> ja <code>oma.html</code>, voi sivulta <code>oma.html</code> luoda linkin sivulle <code>index.html</code> komennolla <code>&lt;a href="index.html"&gt;index.html&lt;/a&gt;</code>. Sivulta voi lisätä myös linkin täysin toiselle sivulle. Alla olevassa esimerkissä on linkki <code>YouTube</code>-sivustolle.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Selaimen palkissa ja suosikeissa näkyvä otsikko&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;

        &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä,
        listaelementtiä voi käyttää esimerkiksi ostoslistan tekemiseen.&lt;/p&gt;

        &lt;ol&gt;
            &lt;li&gt;kauraa&lt;/li&gt;
            &lt;li&gt;puuroa&lt;/li&gt;
            &lt;li&gt;omenaa&lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;Kuvan saa taas näytettyä img-elementillä. Välähtikö?&lt;/p&gt;

        &lt;img src="img/lamppu.png" /&gt;

        &lt;p&gt;Linkkejä saa lisättyä a-elementillä: &lt;a href="http://www.youtube.com/watch?v=9bZkp7q19f0"&gt;klikkaamalla
        liityt miljoonien joukkoon.&lt;/a&gt;&lt;/p&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Yllä olevan sivun viimeinen tekstielementti näyttää seuraavalta:</p>

<div class="naytto">
  <p>Linkkejä saa lisättyä a-elementillä: <a href="http://www.youtube.com/watch?v=9bZkp7q19f0">klikkaamalla liityt miljoonien joukkoon.</a></p>
</div>

    <p>Linkki-elementeille voi lisätä myös attribuutin <code>target</code>, jolla voi ilmaista tietyn ikkunan, johon sivu avataan. Jos attribuutille <code>target</code> antaa arvon "_blank", avataan linkki aina uuteen ikkunaan.</p>


    <h3>HTML5 ja apuvälineet sivun rakenteen määrittelyyn</h3>


    <p><a href="http://www.w3.org/html/wg/html5/" target="_blank">HTML5</a>, eli HTML-kuvauskielen uusin (vielä kesken oleva) versio, toi mukanaan sivun rakenteen suunnittelua helpottavia elementtejä. Sivun rakenteen määrittelyä helpottavat elementit <code>header</code>, jonka sisälle kirjoitetaan sivun yleinen alkuosa kuten <code>h1</code>-elementti ja valikko, <code>nav</code>, joka sisältää sivun valikon, <code>section</code>-elementti, joka esimerkiksi nivoo yhteen toisiinsa liittyviä osia, <code>article</code>, joka sisältää yksittäisen sivulla olevan dokumentin, ja <code>footer</code>, joka kertoo sivun loppuosan. Näiden avulla sivun saa jaettua loogisiin osakokonaisuuksiin.</p>

    <p>Rakennetta helpottavien elementtien käyttö ja toiminta liittyy elementtiin, jonka sisällä ne ovat. Jos elementtiä <code>header</code> käytetään elementin <code>article</code> sisällä, on <code>header</code> luonnollisesti artikkelin otsaketiedot. Jos taas <code>header</code>-elementti on <code>body</code>-elementin sisällä, liittyy <code>header</code>-elementin sisältö itse sivuun. </p>

    <p>Sivut koostuvat yleensä <code>header</code>-elementillä merkittävästä yläosasta, jossa on otsikko ja mahdollisesti <code>nav</code>-elementillä merkitty valikko. Näitä seuraa yksi tai useampi tekstiosa, joka merkitään <code>article</code>-elementillä. Sivun lopussa on elementti <code>footer</code>, joka sisältää esimerkiksi yhteystiedot.</p>

    <p>Seuraavassa on esimerkki, jossa <code>h1</code>-otsikko on asetettu <code>header</code>-elementin sisään. Sivulla on kaksi erillistä kirjoitusosaa, jotka on eroteltu <code>article</code>-elementeillä. Näitä seuraa lopulta <code>footer</code>-elementillä merkitty alaosa.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;header&gt;
            &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;
        &lt;/header&gt;

        &lt;article&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä.&lt;/p&gt;
        &lt;/article&gt;

        &lt;article&gt;
            &lt;ol&gt;
                &lt;li&gt;kauraa&lt;/li&gt;
                &lt;li&gt;puuroa&lt;/li&gt;
                &lt;li&gt;omenaa&lt;/li&gt;
            &lt;/ol&gt;
        &lt;/article&gt;

        &lt;footer&gt;
            &lt;p&gt;alatunniste, esimerkiksi tekijöiden nimet.&lt;/p&gt;
        &lt;/footer&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>


<div class="naytto">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
  </header>

  <article>
    <p>Sivuilla näytettävä normaali teksti on p-elementin sisällä.</p>
  </article>

  <article>
    <ol>
      <li>kauraa</li>
      <li>puuroa</li>
      <li>omenaa</li>
    </ol>
  </article>

  <footer>
    <p>alatunniste, esimerkiksi tekijöiden nimet.</p>
  </footer>
</div>

    <h4>Rakenteellinen lähestymistapa sivujen sisällön määrittelyyn</h4>

    <p>HTML-kuvauskieltä käytetään sivujen rakenteen määrittelyyn. Ennen HTML5:ttä sivun elementtejä eroteltiin toisistaan <code>div</code> (<em>divider</em>)-elementeillä, joille määriteltiin attribuuttina sivun osa, jonka <code>div</code>-elementti sisälsi. Yllä olevan sivun rakenne voidaan luoda myös <code>div</code>-elementeillä.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;div class="header"&gt;
            &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;
        &lt;/div&gt;

        &lt;div class="article"&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä.&lt;/p&gt;
        &lt;/div&gt;

        &lt;div class="article"&gt;
            &lt;ol&gt;
                &lt;li&gt;kauraa&lt;/li&gt;
                &lt;li&gt;puuroa&lt;/li&gt;
                &lt;li&gt;omenaa&lt;/li&gt;
            &lt;/ol&gt;
        &lt;/div&gt;

        &lt;div class="footer"&gt;
            &lt;p&gt;alatunniste, esimerkiksi tekijöiden nimet.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Huomannet että ero on käytännössä hyvin pieni. Oleellisinta on loogisten osakokonaisuuksien erottelu toisistaan. HTML5 tarjoaa siihen työvälineet, joita kannattaa käyttää.</p>


<div class="tehtavat">
  <h3>Kampuskuoro</h3>

  <p>Luo tehtäväpohjassa olevaan kansioon <code>src</code> (tai Site Root) uusi sivu <code>index.html</code>. Muokkaa sivua siten, että se näyttää seuraavalta selaimessa:</p>

  <img src="img/kampuskuoro.png" border=1/>

  <p>Otsikon tulee olla <code>header</code>-elementin sisällä, kuvaus ja laululista omien <code>article</code>-elementtien sisällä. Ei haittaa jos tekstin leveys on eri kuin yllä olevassa kuvassa! Kun olet valmis, ja sivusi näyttää oikealta Chromessa, palauta tehtävä TMC:lle.</p>
</div>


    <h3>Lomakkeet</h3>

	<p>Lomakkeita käytetään tiedon syöttämiseen web-sivuille. Tietoa voi lähettää joko erilliselle palvelimelle, tai käsitellä osana sivustoa JavaScript-kielen avulla. Lomakkeet aloitetaan HTML-elementillä <code>&lt;form&gt;</code>. Lomake-elementin sisälle voi asettaa useita erilaisia kenttiä. Palvelimelle dataa lähetettäessä jokaisella kentällä tulee olla attribuutti <code>name</code>, jota käytetään palvelimella tiedon identifiointiin.</p>


	<p>Erilaisia lomakekenttiä on useita:</p>

	<ul>
	  <li>tekstikenttä: <br/><input type="text" name="kentan_nimi" />
    <pre class="sh_html">&lt;input type="text" /&gt;</pre></li>

      <li>salasanakenttä: <br/><input type="password" name="kentan_nimi" />
    <pre class="sh_html">&lt;input type="password" /&gt;</pre></li>

      <li>tekstialue: <br/><textarea name="tekstialue"></textarea><br/>Toisin kuin monet muut lomakkeen kenttäelementit, tekstialue tulee sulkea erillisellä elementillä.
    <pre class="sh_html">&lt;textarea name="tekstialue"&gt;&lt/textarea&gt;</pre></li>

      <li>valintaruutu: <br/>
    <input type="checkbox" name="porkkanaa" /> Porkkanaa<br/>
    <input type="checkbox" name="naurista" /> Naurista<br/>
    <input type="checkbox" name="kaalia" /> Kaalia<br/>
    Selaimesta riippuen valintaruudun tiedot lähetetään lomakkeen mukana vain kentän ollessa valittuna.
    <pre class="sh_html">&lt;input type="checkbox" name="porkkanaa" /&gt; Porkkanaa &lt;br/&gt;
&lt;input type="checkbox" name="naurista" /&gt; Naurista &lt;br/&gt;
&lt;input type="checkbox" name="kaalia" /&gt; Kaalia &lt;br/&gt;</pre>
      </li>

      <li>valintanappi:<br/>
    <input type="radio" name="valinta" value="porkkanaa"/> Porkkanaa<br/>
    <input type="radio" name="valinta" value="naurista"/> Naurista<br/>
    <input type="radio" name="valinta" value="kaalia"/> Kaalia<br/>
    Valintanappia käytettäessä vain yksi saman name-attribuutin omistava radio-tyyppinen input-elementti voi olla valittuna. Lomaketta lähetettäessä valitun elementin attribuutin <code>value</code> arvo lähetetään <code>name</code> attribuutin arvona.
    <pre class="sh_html">&lt;input type="radio" name="valinta" value="porkkanaa"/&gt; Porkkanaa&lt;br/&gt;
&lt;input type="radio" name="valinta" value="naurista"/&gt; Naurista&lt;br/&gt;
&lt;input type="radio" name="valinta" value="kaalia"/&gt; Kaalia&lt;br/&gt;</pre></li>


      <li>painettava nappi:<br/>
    <input type="button" value="Painettava nappi" /><br/>
    Painettavaa nappia painettaessa mitään ei tapahdu, ellei siihen ole erikseen lisätty toiminnallisuutta esimerkiksi javascript-kielellä.
    <pre class="sh_html">&lt;input type="button" value="Painettava nappi" /&gt;</pre></li>

      <li>lähetysnappi:<br/>
    <input type="submit" value="Lähetä" /><br/>
    Lähetysnappia painettaessa lomakkeen tiedot lähetetään lomake-elementissä määriteltyyn osoitteeseen (lomake-elementin <code>action</code> -attribuutin arvo) valitulla lähestytavalla (lomake-elementin <code>method</code>-attribuutin arvo).
    <pre class="sh_html">&lt;input type="submit" value="Lähetä" /&gt;</pre></li>

    </ul>


    <h4>Lomakkeen lähettäminen</h4>

    <p>Kun lomake lähetetään selain ohjaa käyttäjän <code>form</code>-elementissä olevan <code>action</code>-attribuutin määrittelemään osoitteeseen. Pyynnössä lähetetään lomakkeeseen kirjoitetut tiedot. Jos lomakkeen lähetystapa on <code>GET</code>, liitetään lomakkeen tiedot osaksi osoitetta. Lähetystavassa <code>POST</code> arvot tulevat osana pyynnön runkoa.</p>

    <p><a href="http://www.w3schools.com/tags/ref_httpmethods.asp" target="_blank">Lisätietoa..</a></p>

    <p>Alla oleva lomake lähettää lomakkeen tiedot <em>tälle</em> sivulle GET-pyyntönä, eli pyynnön tiedot lisätään osaksi haettavaa osoitetta.</p>

    <div class="naytto">
      <p>
    <form method="GET" action="index.html">
      <label>Käyttäjätunnus: <input type="text" name="tunnus" /></label>
      <label>Salasana: <input type="password" name="salasana" /></label>
      <input type="submit" />
    </form>
      </p>
    </div>

<pre class="sh_html">
&lt;form method="GET" action="index.html"&gt;
    &lt;label&gt;Käyttäjätunnus: &lt;input type="text" name="tunnus" /&gt;&lt;/label&gt;
    &lt;label&gt;Salasana: &lt;input type="password" name="salasana" /&gt;&lt;/label&gt;
    &lt;input type="submit" /&gt;
&lt;/form&gt;
</pre>


<aside class="extra">
  <p><strong>Moarr!</strong></p>

  <p>Mikään yksittäinen HTML-opas ei itsessään kata kaikkea HTMLään liittyvää. Tässäkin dokumentissa tehtiin pieni pintaraapaisu HTMLn ominaisuuksiin. Erityisesti selainsovelluksia rakennettaessa uusinta informaatiota jaetaan mm. blogeissa ja muissa webissä julkaistavissa artikkeleissa. Web on täynnä timanttisia sivustoja kuten <a href="http://www.html5rocks.com/" target="_blank">http://www.html5rocks.com/</a>, <a href="http://html5-demos.appspot.com/" target="_blank">http://html5-demos.appspot.com/</a>, ... </p>

  <p>Kuten yllä olevista linkeistä huomaat, "puhekielessä" HTML5 sisältää HTML-syntaksin lisäksi CSSn ja JavaScriptin. Avain onneen on pienestä liikkeelle lähteminen: toteutta joku webissä oleva hieno sivu itse sivun lähdekoodia seuraten. Muokkaile lähdekoodia, ja ota selvää mitä eri komennot tekevät. Kun joku komento on epäselvä, <a href="http://lmgtfy.com/?q=Ep%C3%A4selv%C3%A4t+avainsanat" target="_blank"><em>google auttaa</em></a> -- myös esimerkiksi <a href="http://www.w3schools.com/" target="_blank">W3Schools</a> on kätevä.</p>
</aside>


    <h2>CSS</h2>


    <p>CSS (<em>cascading style sheets</em>)-tyylitiedostot ovat tiedostoja, joissa määritellään <em>miten web-sivun elementit tulee näyttää käyttäjälle</em>. HTML-kuvauskielellä määritellään web-sivun rakenne ja sisältö, tyylitiedostoilla sen ulkoasu.</p>


    <p>Tyylitiedostoilla voi tehdä <em>ison</em> eron siihen, miltä sivu näyttää. Voit kokeilla tätä itse avaamalla minkä tahansa mielestäsi hienolta näyttävän sivun, avata selaimen Developer Tools-työvälineet (painamalla F12), valitsemalla elements-välilehti, ja poistamalla kaikki css-tiedostoviittaukset. Tiedostoviittaukset voi poistaa elements-välilehdeltä klikkailemalla niitä oikealla hiirennapilla ja valitsemalla delete.</p>

    <p>Lähdetään kuitenkin pienestä liikkeelle. Tyylitiedosto on HTML-dokumentista erillinen tiedosto, joka sisältää erilaisia tyylimäärittelyjä. Tyylitiedostoja voi olla useita. Jotta HTML-dokumentti saa tyylitiedoston käyttöönsä, tulee tyylitiedoston sijainti määritellä <code>head</code>-elementin sisälle tyylitiedoston lataavaan elementtiin <code>link</code>.</p>


<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;
        &lt;link rel="stylesheet" type="text/css" href="stylesheets/style.css"&gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;!-- sivun sisältö: näin sivuille saa kommentin --&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>


    <p>Elementille <code>link</code> kerrotaan viitattavan tiedoston tyyli (rel="stylesheet"), tyyppi (type="text/css") ja sijainti (href="sijainti.css"). Sijainnin tulee kertoa tyylitiedoston nimi. Tyylitiedostojen päätteenä käytetään merkkijonoa <code>.css</code>.  Esimerkiksi jos tyylitiedosto tämän tiedoston sisältämän kansion sisällä olevassa kansiossa "stylesheets" ja tyylitiedoston nimi on <code>style.css</code>, asetetaan elementin <code>link</code> attribuutin <code>href</code> arvoksi "stylesheets/style.css".</p>

    <h3>Tyylitiedosto</h3>

    <p>Tyylitiedosto on tyypillisesti erillinen tiedosto. Luodaan tiedosto <code>style.css</code>, jonka sisältö on seuraavanlainen:</p>

<pre class="sh_css">
body {
    background-color: rgb(200, 200, 200);
    margin: 0;
    padding: 0;
}
</pre>

    <p>Yllä olevassa tyylitiedostossa sanotaan, että elementin <code>body</code> (eli HTML-dokumentin rungon) taustaväri on <code>rgb</code>-arvolla kerrottuna 200, 200, 200, eli vaaleahko. Väriarvo <code>rgb</code> tulee sanoista <code>red</code>, <code>green</code>, ja <code>blue</code>, ja jokaisella arvolla kerrotaan värin määrän. Kunkin värin määrä ilmaistaan numerolla nollan ja 255 välillä. Jos jokaisen värin arvo on 0, on väri musta, ja jos jokaisen värin arvo on 255, on väri valkoinen.</p>

    <p>Kukin tyylimäärittely alkaa tyyliteltävän elementin kertovalla valitsimella ja avaavalla aaltosululla <code>{</code>, joita seuraa listaus käytettävistä tyyleistä. Kun käytettävät tyylit on määritelty, tyylimäärittely lopetetaan sulkevalla aaltosululla <code>}</code>. Kullakin tyylillä on nimi ja arvo, jotka erotetaan toisistaan kaksoispisteellä <code>:</code>. Yksittäisen tyylin (nimi ja arvo) jälkeen lisätään puolipiste <code>;</code>. Yhteen tyylimäärittelyyn voi sisällyttää useita tyylejä, ja yksittäinen tyyli voi riippuen tyylistä saada useita arvoja.</p>

<pre class="sh_css">
<em>valitsin</em> {
    <em>tyylin-nimi</em>: <em>tyylin-arvo</em>;
    <em>toisen-tyylin-nimi</em>: <em>arvo</em> <em>toinen-arvo</em>;
}
</pre>

    <p>Tyylimäärittely voi myös sisältää useita tyyliteltäviä elementtejä, tällöin valitsimet erotellaan toisistaan pilkulla.</p>


<pre class="sh_css">
<em>valitsin</em>, <em>valitsin2</em> {
    <em>tyylin-nimi</em>: <em>tyylin-arvo</em>;
    <em>toisen-tyylin-nimi</em>: <em>arvo</em> <em>toinen-arvo</em>;
}
</pre>

    <p>Valitsimia voi käyttää myös <a href="http://en.wikipedia.org/wiki/Tree_(data_structure)" target="_blank">lasten</a> valintaan, esimerkiksi seuraavassa valitaan ensimmäisen valitsimen joukosta toisen valitsimen tyyppinen lapsi.</p>

<pre class="sh_css">
<em>valitsin</em> &gt; <em>valitsin2</em> {
    <em>tyylin-nimi</em>: <em>tyylin-arvo</em>;
    <em>toisen-tyylin-nimi</em>: <em>arvo</em> <em>toinen-arvo</em>;
}
</pre>


    <h3>Valitsimet</h3>

    <p>Jokaiselle sivun elementille voidaan määritellä oma tyyli. Jos halutaan että sama tyyli esiintyy kaikissa elementeissä, voidaan valitsimena käyttää elementin nimeä. Esimerkiksi seuraava tyylitiedosto muuttaa kaikkien <code>p</code>-elementtien tekstin värin punaiseksi.</p>

<pre class="sh_css">
p {
    color: rgb(255, 0, 0);
}
</pre>


    <h4>Luokka-attribuutti</h4>

    <p>Silloin tällöin tyyli halutaan asettaa vain tietylle elementille tai elementtijoukolle. Elementeille voidaan määritellä luokka-attribuutti <code>class</code>, jonka arvoksi asetetaan joku tietty arvo, esimerkiksi "blue". Luokka-attribuuttien tyylit voi asettaa erillisellä <code>class</code>-attribuutteja valitsevalla valitsimella, pisteellä. Esimerkiksi kaikki elementit, joilla on luokka-attribuutin arvo "blue" voi valita seuraavasti (kaikille asetetaan alla tekstin väriksi sininen):</p>

<pre class="sh_css">
.blue {
    color: rgb(0, 0, 255);
}
</pre>

      <p>Itse sivulla olevat elementit näyttävät seuraavalta luokka-attribuutin kanssa. Osalla elementeistä on luokka-attribuutti "blue", ja osalla ei.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;
        &lt;link rel="stylesheet" type="text/css" href="stylesheets/style.css"&gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;header&gt;
            &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;
        &lt;/header&gt;


        &lt;article&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä.&lt;/p&gt;
            &lt;p class="blue"&gt;Kuten edellinen elementti, mutta tällä on luokka-attribuutti, jonka arvo on "blue".
            Tyylimäärittely .blue asettaa tekstin värin siniseksi.&lt;/p&gt;
        &lt;/article&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>


<style>
.blue-esim-luokka-attr {
    color: rgb(0, 0, 255);
}
</style>



<div class="naytto">

  <h1>Sivulla näkyvä otsikko</h1>

  <p>Sivuilla näytettävä normaali teksti on p-elementin sisällä.</p>
  <p class="blue-esim-luokka-attr">Kuten edellinen elementti, mutta tällä on luokka-attribuutti, jonka arvo on "blue".</p>

</div>

    <h4>Tunnus-attribuutti</h4>

    <p>Luokka-attribuuttia käytetään joukolle tyylejä. Yksittäisiä elementtejä tyyliteltäessä tapana on käyttää erillistä tunnus-attribuuttia, joka määritellään nimellä <code>id</code>. Kuten luokka-attribuutille, myös tunnus-attribuutille asetetaan arvo. Tunnus-attribuuttiin pääsee käsiksi tyylitiedostossa risuaita (<code>#</code>) -etuliitteellä. Luodaan sivu, jossa on useampia artikkeleita, joista yhtä halutaan korostaa.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;
        &lt;link rel="stylesheet" type="text/css" href="stylesheets/style.css" &gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;header&gt;
            &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;
        &lt;/header&gt;


        &lt;article id="highlighted-article"&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä.&lt;/p&gt;
        &lt;/article&gt;

        &lt;article&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä.&lt;/p&gt;
        &lt;/article&gt;

        &lt;article&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä.&lt;/p&gt;
        &lt;/article&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Luodaan sivu siten, että artikkeleilla on pyöreät kulmat ja vaaleahko taustaväri. Korostettavalla artikkelilla on oma tyylinsä, jossa sille asetetaan hieman vaaleampi taustaväri.</p>

<pre class="sh_css">
article {
    background-color: rgb(200, 200, 200);
    margin: 1em;
    padding: 1em;
    width: 40%;

    /* pyöreät kulmat -- useampi määrittely sillä tyylispesifikaatio vielä kesken */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

#highlighted-article {
    width: 42%;
    background-color: rgb(240, 240, 240);

    /* fiilistellään css3-tyylien kanssa */
    -webkit-transform: rotate(-2deg); /* chrome, safari */
    -moz-transform: rotate(-2deg); /* firefox */
    -o-transform: rotate(-2deg); /* opera */
    transform: rotate(-2deg);
}
</pre>

<style>
.padded-article {
    background-color: rgb(200, 200, 200);
    margin: 1em;
    padding: 1em;
    width: 40%;

    /* pyöreät kulmat -- useampi määrittely sillä tyylispesifikaatio vielä kesken */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

#highlighted-article {
    background-color: rgb(240, 240, 240);
    width: 42%;

    /* fiilistellään css3-tyylien kanssa */
    -webkit-transform: rotate(-2deg); /* chrome, safari */
    -moz-transform: rotate(-2deg); /* firefox */
    -o-transform: rotate(-2deg); /* opera */
    transform: rotate(-2deg);
}
</style>

<div class="naytto">
        <header>
            <h1>Sivulla näkyvä otsikko</h1>
        </header>


        <article class="padded-article" id="highlighted-article">
            <p>Sivuilla näytettävä normaali teksti on p-elementin sisällä.</p>
        </article>

        <article class="padded-article">
            <p>Sivuilla näytettävä normaali teksti on p-elementin sisällä.</p>
        </article>

        <article class="padded-article">
            <p>Sivuilla näytettävä normaali teksti on p-elementin sisällä.</p>
        </article>

</div>


    <h3>Tyylien vaikutus elementteihin</h3>

    <p>Edellä olevassa esimerkissä tyyli <code>#highlighted-article</code> ei sisältänyt reunojen pyöristystä, mutta silti korostetun artikkelin reunat pyöristettiin silti. Miksi?</p>

    <p>Elementti käyttää kaikkia sille määriteltyjä tyylejä. Esimerkiksi tyyli <code>#highlighted-article</code> on osana <code>article</code>-elementtiä, jolla taas on siihen liittyvä tyyli. Mielenkiintoinen kohta liittyy artikkelin leveyteen (tyylimäärittely <code>width</code>): tyylissä <code>#highlighted-article</code> oleva määrittely <code>width</code> korvaa tyylissä <code>article</code> määritellyn leveyden. Jos leveyttä ei olisi korvattu, olisi myös leveys peritty.</p>

    <p>Koska HTML-dokumentti on puu, voi tyylien periytymistä ajatella myös puumaisena periytymisenä. Jos elementille <code>body</code> määritellään tietynlainen tyyli, on kaikilla sen lapsisolmuilla <code>body</code>-elementissä määritelty tyyli, ellei lapsisolmu korvaa tyyliä.</p>

    <p>Kaikki tyylit eivät kuitenkaan periydy. Tutustu tarkemmin tyylimäärittelyihin ja standardiin osoitteessa <a href="http://www.w3.org/TR/CSS/#properties" target="_blank">http://www.w3.org/TR/CSS/#properties</a>.</p>


    <div class="tehtavat">
      <h3>CSS Askeleet</h3>

      <p>Luo tehtäväpohjan kansioon <code>src</code> tyylitiedosto <code>style.css</code>, ja viittaa siihen tiedostosta <code>index.html</code>. Muokkaa tyylitiedostoa <code>style.css</code> siten, että sivu <code>index.html</code> näyttää seuraavanlaiselta.</p>

      <img src="img/css-askeleet.png" border=1/>

      <p>Tässä muutama hyödyllinen väri:</p>

      <ul>
    <li>rgb(242, 242, 242)</li>
    <li>rgb(155, 155, 155)</li>
    <li>rgb(10, 10, 10)</li>
    <li>rgb(252,179,21)</li>
      </ul>

      <p>Sivu käyttää seuraavaa määrittelyä fontin valintaan..</p>

      <pre class="sh_css">    font-family: 'Trebuchet MS', Trebuchet, Arial, sans-serif;</pre>


      <p>Kun olet valmis, ja sivusi näyttää oikealta Chromessa, palauta tehtävä TMC:lle.</p>
    </div>



    <h3>Case: Listojen tyylit</h3>

    <p>Tyylitiedostoilla saa muokattua oikeastaan kaikkea sivulla olevaa. Listalle voi asettaa taustavärin, ja siitä voi poistaa numeroinnin tai pallot. Luodaan tyyliluokka <code>menu</code>, jossa listan taustaväri on vaalean harmaa, ja listan palloja ei näytetä.</p>

<pre class="sh_css">
.menu {
    /* listan tausta on harmaa */
    background-color: rgb(230, 230, 230);

    /* ei näytetä palloja */
    list-style-type: none;

    /* lisätään reunoille hieman tilaa (1em = 1 standardimerkin leveys) */
    padding: 1em;
}
</pre>

<pre class="sh_html">
  &lt;ul class="menu"&gt;
    &lt;li&gt;Eka pallukka&lt;/li&gt;
    &lt;li&gt;Toka pallukka&lt;/li&gt;
    &lt;li&gt;Kolmas pallukka&lt;/li&gt;
  &lt;/ul&gt;
</pre>

    <p>Nyt lista näyttää seuraavalta:</p>

<style>
.menu-ex {
    background-color: rgb(230, 230, 230);
    list-style-type: none;
    padding: 1em;
}
</style>

<div class="naytto">
  <ul class="menu-ex">
    <li>Eka pallukka</li>
    <li>Toka pallukka</li>
    <li>Kolmas pallukka</li>
  </ul>
</div>

    <p>Muutetaan listan elementtejä siten, että ne asetellaan vierekkäin. Luodaan tyyliluokka <code>menuelement</code>, joka asettaa listaelementit vierekkäin, ja lisää niille hieman tilaa sivuille.</p>

<pre class="sh_css">
.menuelement {
    /* 1 standardimerkin leveyden verran tilaa jokaiselle puolelle */
    padding: 1em;
    /* näytetään menuelementit vierekkäin */
    display: inline;
}
</pre>

    <p>Lisätään listan elementeille tyyliluokka listaelementti.</p>


<pre class="sh_html">
  &lt;ul class="menu"&gt;
    &lt;li class="menuelement"&gt;Eka pallukka&lt;/li&gt;
    &lt;li class="menuelement"&gt;Toka pallukka&lt;/li&gt;
    &lt;li class="menuelement"&gt;Kolmas pallukka&lt;/li&gt;
  &lt;/ul&gt;
</pre>

    <p>Nyt lista näyttää seuraavalta:</p>


<style>
.menuelement-ex {
    /* 1 standardimerkin leveyden verran tilaa jokaiselle puolelle */
    padding: 1em;
    display: inline;
}
</style>

<div class="naytto">
  <ul class="menu-ex">
    <li class="menuelement-ex">Eka pallukka</li>
    <li class="menuelement-ex">Toka pallukka</li>
    <li class="menuelement-ex">Kolmas pallukka</li>
  </ul>
</div>

    <p>Valikkoihin halutaan usein jonkinlaista dynaamista toiminnallisuutta. Lisätään toiminnallisuus, jossa vaihtoehdon taustaväri muuttuu kun sen päälle viedään hiiri. Valitsimen lisämääreellä <code>:hover</code> voidaan määritellä tyyli, joka näkyy vain kun hiiri on tyylitellyn alueen päällä. Lisätään toinen <code>menuelement</code>-tyyliluokka, ja sille lisämääre <code>:hover</code>.</p>


<pre class="sh_css">
.menuelement {
    /* 1 standardimerkin leveyden verran tilaa jokaiselle puolelle */
    padding: 1em;
    /* näytetään menuelementit vierekkäin */
    display: inline;
}

.menuelement:hover {
    /* vaaleampi taustaväri kun hiiri on tyylin päällä */
    background-color: rgb(245, 245, 245);
}
</pre>

<style>
.menuelement-ex2 {
    /* 1 standardimerkin leveyden verran tilaa jokaiselle puolelle */
    padding: 1em;
    /* näytetään menuelementit vierekkäin */
    display: inline;
}

.menuelement-ex2:hover {
    /* vaaleampi taustaväri kun hiiri on tyylin päällä */
    background-color: rgb(245, 245, 245);
}
</style>

    <p>Tässä meidän ei tarvitse muokata HTML-dokumenttia, sillä tyyliluokka <code>menuelement</code> on jo määritelty HTML-dokumenttiin.</p>


<div class="naytto">
  <ul class="menu-ex">
    <li class="menuelement-ex2">Eka pallukka</li>
    <li class="menuelement-ex2">Toka pallukka</li>
    <li class="menuelement-ex2">Kolmas pallukka</li>
  </ul>
</div>



    <p>Vielä noin 5 vuotta sitten pyöreät kulmat tehtiin erillisillä kuvilla. Ei enää! Pyöreät kulmat eivät ole vielä ihan helpon komennon takana, vaan niihin tarvitaan kolme erillistä komentoa. Erillisiä komentoja tarvitaan selainyhteensopivuuden varmistamiseksi: pyöreät kulmat määrittelevä standardi ei ole vielä lopullinen...). Pyöreät kulmat saa lisättyä tyyliluokkaan <code>menu</code> seuraavasti:</p>

<pre class="sh_css">
.menu {
    /* tämä on muuten kommentti, eli kone ei tee sillä mitään */
    /* listan tausta on harmaa */
    background-color: rgb(230, 230, 230);

    /* ei näytetä palloja */
    list-style-type: none;

    /* lisätään reunoille hieman tilaa (1em = 1 standardimerkin leveys) */
    padding: 1em;

    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}
</pre>

<style>
.menu-ex2 {
    /* tämä on muuten kommentti, eli kone ei tee sillä mitään */
    /* listan tausta on harmaa */
    background-color: rgb(230, 230, 230);

    /* ei näytetä palloja */
    list-style-type: none;

    /* lisätään reunoille hieman tilaa (1em = 1 standardimerkin leveys) */
    padding: 1em;

    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}
</style>


    <p>Lista näyttää nyt seuraavalta:</p>

<div class="naytto">
      <ul class="menu-ex2">
    <li class="menuelement-ex2">Eka pallukka</li>
    <li class="menuelement-ex2">Toka pallukka</li>
    <li class="menuelement-ex2">Kolmas pallukka</li>
      </ul>
</div>

    <h4>Tyylivalitsimet ja menu</h4>

    <p>Yllä oleva lähestymistapa, vaikkakin hieno, on hieman kömpelö. Jouduimme lisäämään jokaiselle tyyliteltävälle elementille oman luokkamäärittelyn. Aiemmin näimme, että tyylejä voi määritellä listana seuraavasti:</p>

<pre class="sh_css">
<em>valitsin</em>, <em>valitsin2</em> {
    <em>tyylin-nimi</em>: <em>tyylin-arvo</em>;
    <em>toisen-tyylin-nimi</em>: <em>arvo</em> <em>toinen-arvo</em>;
}
</pre>

    <p>Tutustutaan seuraavaksi toiseen tapaan. Tavoitteenamme on tyylitellä alla olevan sivun <code>header</code>-osio uudestaan. Huomaa jo nyt, että sivun <code>header</code>-osioon ei ole määritelty luokkia tai tunnuksia!</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;
        &lt;link rel="stylesheet" type="text/css" href="stylesheets/style.css" &gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;header&gt;
            &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;

            &lt;nav&gt;
                &lt;ul&gt;
                    &lt;li&gt;&lt;a href="#"&gt;linkki&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href="#"&gt;linkki&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href="#"&gt;linkki&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href="#"&gt;linkki&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/nav&gt;

        &lt;/header&gt;

        &lt;!-- muu sisältö --&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>



<div class="naytto">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
    <nav>
      <ul>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
      </ul>
    </nav>
  </header>
</div>


    <p>Toinen tapa valita tyyliteltäviä elementtejä liittyy niiden järjestykseen osana dokumenttia. Voimme tyylitellä <code>header</code>-elementin sisällä olevan <code>h1</code>-elementin seuraavasti. Huomaa että tämä tyylittely <em>ei</em> muuta kaikkia <code>h1</code>-elementtejä, vain vaan ne, jotka ovat <code>header</code>-elementin sisällä.</p>

<pre class="sh_css">
header h1 {
    color: rgb(80, 80, 80);
}
</pre>


<style>
#ex-1 header h1 {
    color: rgb(80, 80, 80);
}

</style>


<div class="naytto" id="ex-1">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
    <nav>
      <ul>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
      </ul>
    </nav>
  </header>
</div>

    <p>Jatketaan esimerkkiä muokkaamalla <code>header</code>-elementissä olevan <code>nav</code>-elementin sisältämää listaa. Listan taustaväriksi asetetaan lähes musta, ja sillä on pyöristetyt kulmat.</p>


<pre class="sh_css">
header h1 {
    color: rgb(40, 40, 40);
}

header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;


    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}
</pre>


<style>
#ex-2 header h1 {
    color: rgb(40, 40, 40);
}

#ex-2 header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;


    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}
</style>


<div class="naytto" id="ex-2">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
    <nav>
      <ul>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
      </ul>
    </nav>
  </header>
</div>



    <p>Ei mitenkään kovin komea, muutamat selaimet näyttävät myös listaelementit listan ulkopuolella. Lisätään listaelementeille määrittely, jossa ne asetetaan vierekkäin.</p>


<pre class="sh_css">
header h1 {
    color: rgb(40, 40, 40);
}

header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;


    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

header nav ul li {
    float: left;
    display: inline;
}
</pre>


<style>
#ex-3 header h1 {
    color: rgb(40, 40, 40);
}

#ex-3 header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;


    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

#ex-3 header nav ul li {
    float: left;
    display: inline;
}
</style>

<div class="naytto" id="ex-3">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
    <nav>
      <ul>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
      </ul>
    </nav>
  </header>
</div>



    <p>Ei vieläkään komea, mutta selviämme tästä kyllä. Muutetaan linkkielementtien väri valkoiseksi, suurennetaan niiden fonttia, ja asetetaan niille hieman tilaa ympärille.</p>

<pre class="sh_css">
header h1 {
    color: rgb(40, 40, 40);
}

header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;


    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

header nav ul li {
    float: left;
    display: inline;
}


header nav ul li a {
    color: rgb(255, 255, 255);
    display: inline-block;
    padding: 5px 1.5em;
    text-decoration: none;
}
</pre>


<style>
#ex-4 header h1 {
    color: rgb(40, 40, 40);
}

#ex-4 header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;


    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}


#ex-4 header nav ul li {
    float: left;
    display: inline;
}

#ex-4 header nav ul li a {
    color: rgb(255, 255, 255);
    display: inline-block;
    padding: 5px 1.5em;
    text-decoration: none;
}
</style>

    <p>Nyt sivumme yläosa näyttää seuraavalta.</p>


<div class="naytto" id="ex-4">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
    <nav>
      <ul>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
      </ul>
    </nav>
  </header>
</div>

    <p>Lisätään vielä linkkielementeille toiminnallisuus, jossa niiden taustaväri muuttuu kun hiiri viedään elementin päälle. Asetetaan taustaväri tällöin valkoiseksi, ja linkin fontti aiemmin käytetyksi tummaksi väriksi.</p>

<pre class="sh_css">
header h1 {
    color: rgb(40, 40, 40);
}

header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;

    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

header nav ul li {
    float: left;
    display: inline;
}

header nav ul li a {
    color: rgb(255, 255, 255);
    display: inline-block;
    padding: 5px 1.5em;
    text-decoration: none;
}

header nav ul li a:hover {
    background-color: rgb(255, 255, 255);
    color: rgb(40, 40, 40);
}
</pre>


<style>
#ex-5 header h1 {
    color: rgb(40, 40, 40);
}

#ex-5 header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;

    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

#ex-5 header nav ul li {
    float: left;
    display: inline;
}

#ex-5 header nav ul li a {
    color: rgb(255, 255, 255);
    display: inline-block;
    padding: 5px 1.5em;
    text-decoration: none;
}

#ex-5 header nav ul li a:hover {
    background-color: rgb(255, 255, 255);
    color: rgb(40, 40, 40);
}
</style>

<div class="naytto" id="ex-5">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
    <nav>
      <ul>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
      </ul>
    </nav>
  </header>
</div>


      <p>Done! Tyylimaailman sopivuudesta jokainen saa toki päättää itse :).</p>


    <div class="tehtavat">
      <h3>Suosikit</h3>

      <p>Tehtäväpohjassa on lista suosikkeja. Tehtävänäsi on lisätä sivulle tyyli, joka tekee sivusta seuraavannäköisen. Huomaa, että sivun artikkeli-elementtien tulee kääntyä hieman kun hiiri viedään niiden päälle.</p>


      <img src="img/suosikit.png" border=1/>


      <p>Edellisessä tehtävässä määrittelemistäsi tyyleistä on hyötyä tässä tehtävässä. Kun olet valmis, ja sivusi näyttää oikealta Chromessa, palauta tehtävä TMC:lle.</p>

    </div>



<aside class="extra">
  <p><strong>Moar!</strong></p>

  <p>Web on pullollaan myös CSSään liittyviä sivuja; <a href="http://www.css3.com/" target="_blank">http://www.css3.com/</a>, <a href="http://www.smashingmagazine.com/learning-css3-useful-reference-guide/" target="_blank">http://www.smashingmagazine.com/learning-css3-useful-reference-guide/</a>, ...</p>

  <p>Viimeisin versio löytyy osoitteesta <a href="http://www.w3.org/Style/CSS/current-work" target="_blank">http://www.w3.org/Style/CSS/current-work</a> -- kyseessä on jatkuvasti päivittyvä standardi.</p>
</aside>




    <h2>JavaScript</h2>


    <p>Siinä missä HTML on kuvauskieli web-sivujen rakenteen ja sisällön luomiseen, ja CSS on kieli web-sivustojen tyylin määrittelyyn, JavaScript on kieli dynaamisen toiminnan lisäämiselle. Suomen kielioppia ajatellen HTML:ää voi ajatella substantiiveina, CSS:ää adjektiiveina, ja JavaScriptiä verbeinä. Käytännössä JavaScript on ohjelmakoodia, jota suoritetaan tarvittaessa komento kerrallaan -- ylhäältä alas, vasemmalta oikealle.</p>


<script>
function evalElementContent(elementId) {
    eval(document.getElementById(elementId).value);
}
</script>

    <p>Ensimmäinen komento jonka opimme on <code>alert("tulostettava merkkijono")</code>. Funktio <code>alert("jotain")</code> on JavaScriptin valmis funktio, ja se avaa uuden pop-up -ikkunan jossa näkyy funktion <code>alert</code> parametrina saama arvo. Funktiolle alert voi antaa parametrina oikeastaan minkälaisia arvoja tahansa. Voit testata <code>alert</code>-funktion toimintaa alla olevassa laatikossa. Painamalla nappia "Suorita koodi!", selaimesi suorittaa laatikossa olevan koodin.</p>

    <div class="test-js">
      <p><textarea id="js-alert" rows="4" cols="80">alert("heippa!");</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-alert')" value="Suorita koodi!"></input></p>
    </div>

    <p>Ohjelmakoodia suoritettaessa selain käy läpi laatikossa olevat komennot yksi kerrallaan ylhäältä alas, vasemmalta oikealle, ja toimii niiden mukaan. JavaScript-koodi suoritetaan siis omalla koneellasi omassa selaimessasi. Kukin komento loppuu puolipisteeseen (<code>;</code>), ja komentoja voi olla useampia. Mitä käy jos muutat <code>alert</code>-komennossa olevaa tekstiä, tai lisäät useamman <code>alert</code>-komennon?</p>

    <p>Komennon <code>alert</code> yhteydessä on hyvä kertoa heti komennosta <code>console.log</code>, minkä avulla voidaan kirjoittaa selaimen JavaScript-konsoliin viestejä. Käynnistä selaimen debug-työvälineet (F12) ja valitse käyttöön Console. Kirjoita tämän jälkeen yllä olevaan laatikkoon komento <code>console.log("hello world");</code> ja paina "Suorita koodi!"-nappia. Komennolle <code>console.log</code> annettu teksti ilmestyy konsoliin tarkasteltavaksi -- tätä voi käyttää mm. oman koodin debuggauksessa. </p>


<aside class="extra">
  <p>Vaikkakin käytämmekin komentoja <code>alert</code> ja <code>console.log</code> melko intensiivisesti, eivät ne ole osa JavaScript-spesifikaatiota. </p>
  <p>&nbsp;</p>
</aside>




    <h3>Funktiot</h3>


    <p>Jos ylläoleva koodi asetetaan lähdekooditiedostoon, se suoritetaan <em>heti</em> kun selain lataa tiedoston. Haluamme kuitenkin usein siirtää koodin suoritusta tulevaisuuteen, ja kiinnittää se esimerkiksi johonkin tiettyyn tapahtumaan. Tätä varten on olemassa funktiot. Funktioilla määritellään ohjelmakoodia, joka suoritetaan myöhemmin.</p>

    <p>Funktio määritellään merkkijonolla <code>function funktionNimi() { <em>suoritettava koodi</em>}</code>. Ensin avainsana <code>function</code>, joka kertoo että seuraavaksi on tulossa funktion määrittely. Tätä seuraa funktion nimi ja sulut, joita seuraa aukeava aaltosulku <code>{</code>. Aaltosulun jälkeen tulee funktiota kutsuttaessa suoritettava ohjelmakoodi, jonka jälkeen tulee sulkeva aaltosulku <code>}</code>.</p>

    <p>Alla on määritelty funktio, joka kysyy käyttäjältä nimeä, tallentaa nimen muuttujaan <code>nimi</code>, ja lopulta käyttää funktiota <code>console.log</code> nimen tulostamiseen selaimen JavaScript-konsoliin.</p>

    <div class="test-js">
      <p><textarea id="js-kysynimi-funktio" rows="6" cols="80">function kysyNimiJaTervehdi() {
    var nimi = prompt("Mikä on nimesi?");
    console.log(nimi);
}
      </textarea></p>
      <p><input type="button" onclick="evalElementContent('js-kysynimi-funktio')" value="Suorita koodi!"></input></p>
    </div>

      <p>Kun painat nappia "Suorita koodi!", huomaat ettei mitään tapahdu. Tämä johtuu siitä, että funktiota ei kutsuta mistään, eli funktion suorittamista ei pyydetä. Lisätään funktiokutsu. Funktion kutsuminen onnistuu sanomalla funktion nimi ja sulut, sekä puolipiste. Esimerkiksi <code>funktionNimi();</code>. Alla olevassa koodissa on sekä funktion <code>kysyNimiJaTervehdi</code> määrittely, että funktion <code>kysyNimiJaTervehdi</code> kutsu.</p>

      <div class="js-test">
      <p><textarea id="js-kysynimi-funktio-ja-kutsu" rows="8" cols="80">function kysyNimiJaTervehdi() {
    var nimi = prompt("Mikä on nimesi?");
    console.log(nimi);
}

kysyNimiJaTervehdi();</textarea></p>
      </div>
      <p><input type="button" onclick="evalElementContent('js-kysynimi-funktio-ja-kutsu')" value="Suorita koodi!"></input></p>



      <h3>JavaScriptin lisääminen omille sivuille</h3>

      <p>Aivan kuten CSS-tyylimäärittelyt, JavaScript-lähdekoodit tulee erottaa HTML-dokumentista.</p>

      <p>JavaScript-tiedoston pääte on yleensä <code>.js</code> ja siihen viitataan elementillä <code>script</code>. Elementillä <code>script</code> on attribuutti <code>src</code>, jolla kerrotaan lähdekooditiedoston sijainti. Jos lähdekoodi on kansiossa <code>javascript</code> olevassa tiedostossa <code>code.js</code>, käytetään <code>script</code>-elementtiä seuraavasti: <code>&lt;script src="javascript/code.js"&gt;&lt;/script&gt;</code>. Huomaa että <code>script</code>-elementti suljetaan poikkeuksellisesti erikseen vaikka se ei sisälläkään tekstiä.</p>

      <p>Hyvä käytäntö JavaScript-lähdekoodien lataamiseen on ladata ne juuri ennen niiden tarvitsemista. Jos lähdekoodia ei tarvita kuin vasta sivun ollessa kokonaan latautunut, kannattaa lähdekoodien hakeminen asettaa sivun loppuun. Tämä johtuu mm. siitä, että selaimen kohdatessa JavaScript-tiedoston, se lähtee hakemaan tiedostoa ja asettaa kaikki muut toiminnot odottamaan. Kun lähdekooditiedosto ladataan vasta sivun lopussa, käyttäjä <em>näkee</em> sivun sisältöä jo ennen lähdekoodin latautumista: tämä luo tunteen nopeammin reagoivista sivuista.</p>

      <p>Luodaan kansioon <code>javascript</code> lähdekooditiedosto <code>code.js</code>. Tiedostossa <code>code.js</code> on funktio <code>sayHello</code>, joka tulostaa konsoliin viestin "BAD = browser application development".</p>


<pre class="sh_javascript_dom">
function sayHello() {
    console.log("BAD = browser application development");
}
</pre>

      <p>HTML-dokumentti, jossa lähdekooditiedosto ladataan, näyttää seuraavalta:</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;
        &lt;link rel="stylesheet" type="text/css" href="stylesheets/style.css"&gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;header&gt;
            &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;
        &lt;/header&gt;

        &lt;article&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä. Alla on nappi,
            jota painamalla kutsutaan funktiota "sayHello".&lt;/p&gt;
            &lt;input type="button" value="Tervehdi" onclick="sayHello();" /&gt;
        &lt;/article&gt;

        &lt;!-- ladataan JavaScript-koodit tiedoston lopussa! --&gt;
        &lt;script src="javascript/code.js"&gt;&lt;/script&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Itse sivu näyttää seuraavalta:</p>

<div class="naytto">
        <header>
            <h1>Sivulla näkyvä otsikko</h1>
        </header>

        <article>
            <p>Sivuilla näytettävä normaali teksti on p-elementin sisällä. Alla on nappi,
            jota painamalla kutsutaan funktiota "sayHello".</p>
            <input type="button" value="Tervehdi" onclick="sayHello();" />
        </article>
        <!-- funktio määritelty osana sivua, ei hyvä! pitäisi oikeasti ladata tiedostosta! -->
        <script>
function sayHello() {
    console.log("BAD = browser application development");
}
        </script>
</div>


    <div class="tehtavat">

      <h3>Mitä eläin sanoo?</h3>

      <p>Tehtäväpohjassa tulevalla sivulla on kolme erillistä eläintä. Luo tehtäväpohjaan erillinen javascript-tiedosto, ja lataa se sivun käyttöön. Lisää toiminnallisuus, jonka avulla lehmän nappia painettaessa käyttäjälle tulostetaan viesti "muu muu", porsaan nappia painettaessa "nöf nöf", ja kanan nappia painettaessa "kot kot".</p>

      <p>Varmista sivusi toiminnallisuus. Kun olet valmis, palauta tehtävä TMC:lle.</p>
    </div>


      <h3>JavaScriptin alkeita</h3>

      <p>Tässä osiossa käydään pikaisesti läpi JavaScriptin alkeita.</p>

      <h4>Muuttuja</h4>

      <p>Jotta sama tieto olisi käytössä useammassa paikassa, tarvitsemme jonkun tavan tallentaa tietoa. Javascriptissä, kuten lähes kaikissa muissakin ohjelmointikieliessä, tähän käytetään muuttujia. Muuttujat esitellään sanomalla <code>var muuttujanNimi</code>, eli ensin sana <code>var</code>, jota seuraa nimi muuttujalle. Tämän jälkeen seuraa yhtäsuuruusmerkki, jota seuraa muuttujaan asetettava arvo, esimerkiksi <code>var vitonen = 5;</code>. Edellinen komento luo muuttujan <code>vitonen</code>, ja asettaa siihen arvon <code>5</code>.</p>

      <p>Alla olevassa koodissa asetamme ensin muuttujaan <code>kolme</code> arvon <code>3</code>, ja kutsumme aiemmin näkemäämme <code>console.log</code>-komentoa siten, että <code>console.log</code>-komento saa parametrina muuttujassa <code>kolme</code> olevan arvon.</p>

      <div class="test-js">
      <p><textarea id="js-muuttuja-ja-alert" rows="5" cols="80">var kolme = 3;
console.log(kolme);
console.log(kolme);</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-muuttuja-ja-alert')" value="Suorita koodi!"></input></p>
      </div>

      <p>Olemassaoleviin muuttujiin voi sijoittaa uuden arvon. Seuraava koodi näyttää ensin numeron <code>3</code>, ja sitten numeron <code>4</code>. Huomaa että sana <code>var</code> esiintyy vain kun muuttuja esitellään ensimmäisen kerran. Tämän jälkeen muuttuja on jo olemassa ja sanaa <code>var</code> ei enää tarvita.</p>

      <div class="test-js">
      <p><textarea id="js-muuttuva-muuttuja-ja-alert" rows="6" cols="80">var kolme = 3;
console.log(kolme);
kolme = 4;
console.log(kolme);</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-muuttuva-muuttuja-ja-alert')" value="Suorita koodi!"></input></p>
      </div>


      <p>Muuttujia voi myös laskea yhteen. Koulussa opittu pluslasku toimii kuten tähänkin mennessä.</p>

      <div class="test-js">
      <p><textarea id="js-muuttujien-yhteenlasku-ja-alert" rows="6" cols="80">var kolme = 3;
var nelja = 4;
var seitseman = kolme + nelja;
console.log(seitseman);</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-muuttujien-yhteenlasku-ja-alert')" value="Suorita koodi!"></input></p>
      </div>

      <p>Yllä luodaan ensin muuttuja <code>kolme</code>, ja asetetaan siihen arvo 3. Tämän jälkeen luodaan uusi muuttuja nimeltä <code>nelja</code>, ja asetetaan siihen arvo 4. Tämän jälkeen luodaan uusi muuttuja <code>seitseman</code>, ja asetetaan siihen aiemmin määriteltyjen muuttujien (<code>kolme</code> ja <code>nelja</code>) arvojen summa.</p>


      <h4>Muuttujien tyypit</h4>


      <p>JavaScript, toisin kuin peruskursseillamme käytetty Java, ei ole vahvasti tyypitetty ohjelmointikieli. Tämä tarkoittaa sitä, että ohjelmointikieli ei rajoita muuttujissa käytettävien arvojen tyyppiä. Muuttujan tyyppi voi olla numero, merkkijono tai vaikkapa funktio (palaamme tähän myöhemmin...). Muuttujaan voi siis asettaa myös merkkijonon. Merkkijono aloitetaan ja lopetetaan hipsuilla (<code>""</code>).</p>

      <div class="test-js">
      <p><textarea id="js-merkkijono-muuttujassa-alert" rows="4" cols="80">var teksti = "Silloin kun minä olin nuori, koodattiin basicilla";
console.log(teksti);</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-merkkijono-muuttujassa-alert')" value="Suorita koodi!"></input></p>
      </div>

      <p>Merkkijonojen katenaatio eli yhdistäminen onnistuu summamerkillä Javasta tutulla tavalla. </p>

      <div class="test-js">
      <p><textarea id="js-merkkijonojen-katenointi-alert" rows="6" cols="80">var eka = "2";
var toka = "3";
var summa = eka + toka;
console.log(summa);</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-merkkijonojen-katenointi-alert')" value="Suorita koodi!"></input></p>
      </div>

      <p>Yllä muuttujaan <code>summa</code> asetetaan muuttujien <code>eka</code> ja <code>toka</code> liitos, eli merkkijono <code>"23"</code>.</p>

      <p>Jos merkkijonot haluaa muuttaa luvuiksi, tulee muunnoksessa käyttää JavaScriptin <code>parseInt</code>-funktiota. Komento <code>parseInt</code> muuttaa parametrina saadun merkkijonon kokonaisluvuksi.</p>

      <div class="test-js">
      <p><textarea id="js-merkkijonojen-katenointi-parseint-alert" rows="6" cols="80">var eka = "2";
var toka = "3";
var summa = parseInt(eka) + parseInt(toka);
console.log(summa);</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-merkkijonojen-katenointi-parseint-alert')" value="Suorita koodi!"></input></p>
      </div>


      <h4>Arvojen vertaileminen ja lisää tyypeistä</h4>

      <p>Ohjelmiin tuodaan vaihtoehtoista toiminnallisuutta muuttujien ja vertailuoperaatioiden yhteistyöllä. Luodaan ohjelma, joka kysyy käyttäjältä numeroa. Jos käyttäjän antama numero on <code>5</code>, sanotaan "Oikein meni!". Vertailu onnistuu <code>if</code>-lauseella ja kahdella yhtäsuuruusmerkillä. Koska funktio <code>prompt</code> palauttaa merkkijonon, muunnetaan saatu luku numeroksi JavaScriptin <code>parseInt</code>-funktiolla.</p>

      <div class="test-js">
      <p><textarea id="js-kysyluku-funktio-ja-kutsu" rows="8" cols="80">var numero = prompt("Kirjoita numero");
numero = parseInt(numero);

if (numero == 5) {
    console.log("Oikein meni!");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-kysyluku-funktio-ja-kutsu')" value="Suorita koodi!"></input></p>
      </div>

      <p>Jos haluamme sanoa "Oikein meni!" kun käyttäjä antaa numeron <code>5</code> tai <code>7</code>, voimme tehdä erillisen <code>else if</code>-vertailun. Vertailu <code>else if</code> tulee aina vertailun <code>if</code> jälkeen, ja vertailua <code>else if</code> ei voi käyttää ilman <code>if</code>-vertailua.</p>

      <div class="test-js">
      <p><textarea id="js-kysyluku-viisi-tai-seitseman-funktio-ja-kutsu" rows="10" cols="80">var numero = prompt("Kirjoita joku numero?");
numero = parseInt(numero);

if (numero == 5) {
    console.log("Oikein meni!");
} else if (numero == 7) {
    console.log("Oikein meni!");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-kysyluku-viisi-tai-seitseman-funktio-ja-kutsu')" value="Suorita koodi!"></input></p>
      </div>

      <p>Lauseita <code>else if</code> voi olla peräkkäin rajoittamaton määrä. Ohjelmakoodissa voi käyttää myös Javasta tuttuja <code>||</code> (<em>tai</em>) ja <code>&&</code> (<em>ja</em>) -operaatioita vertailutulosten yhdistämiseksi.</p>

      <div class="test-js">
      <p><textarea id="js-kysyluku-joku-funktio-ja-kutsu" rows="8" cols="80">var numero = prompt("Kirjoita joku numero?");
numero = parseInt(numero);

if (numero == 5 || numero == 7) {
    console.log("Oikein meni!");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-kysyluku-joku-funktio-ja-kutsu')" value="Suorita koodi!"></input></p>
      </div>

      <p>Joskus haluamme tulostaa jotain, vaikka yksikään vertailu ei onnistuisi. Tällöin käytämme ehtoa <code>else</code>, joka tarkoittaa "muutoin". Lisätään yllä olevaan luvun tarkistamiseen <code>else</code>-lause, joka suoritetaan kun yksikään aiemmista ehdoista ei onnistunut.</p>

      <div class="test-js">
      <p><textarea id="js-kysyluku-elsella-funktio-ja-kutsu" rows="10" cols="80">var numero = prompt("Kirjoita joku numero?");
numero = parseInt(numero);

if (numero == 5 || numero == 7) {
    console.log("Oikein meni!");
} else {
    console.log("Ei onnistunut");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-kysyluku-elsella-funktio-ja-kutsu')" value="Suorita koodi!"></input></p>
      </div>

      <p>Muutkin Javasta tutut vertailuoperaatiot ovat käytössä. Suurempi kuin <code>&gt;</code> merkillä tarkistetaan onko luku suurempi kuin joku luku, ja pienempi kuin <code>&lt;</code> merkillä tarkistetaan onko luku pienempi kuin joku luku. Tehdään ohjelma, joka kysyy ikää, ja sanoo "Huijaat!", jos ikä on pienempi kuin 0 tai suurempi kuin 120. Muulloin ohjelma sanoo &quot;Et huijannut! :)&quot; .</p>


      <div class="test-js">
      <p><textarea id="kysyika-funktio-ja-kutsu" rows="10" cols="80">var ika = prompt("Mikä on ikäsi?");
ika = parseInt(ika);

if (ika < 0 || ika > 120) {
    console.log("Huijaat!");
} else {
    console.log("Et huijannut!");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('kysyika-funktio-ja-kutsu')" value="Suorita koodi!"></input></p>
      </div>

      <p>Yllä olemme vertailleet juurikin <em>muuttujien arvoja</em>. Vertailuoperaattorin <code>==</code> yksi päänvaivaa tuottava ominaisuus on se, että vertailuoperaatio ei välitä muuttujan tyypistä. Esimerkiksi seuraava vertailu tulostaa viestin "Ehdottomasti totta!".</p>

      <div class="test-js">
      <p><textarea id="js-vertailun-tyyppi" rows="7" cols="80">var auton_merkki = "";

if(auton_merkki == false) {
    console.log("Ehdottomasti totta!");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-vertailun-tyyppi')" value="Suorita koodi!"></input></p>
      </div>

      <p>Jotta vertailussa otettaisiin huomioon myös muuttujan <em>sen hetkinen</em> tyyppi, käytetään kolmatta yhtäsuuri kuin -merkkiä. Jotta muuttujan tyypin saa otettua huomioon, tulee yhtäsuuruusvertailu toteuttaa kolmella yhtäsuuri kuin -merkillä (<code>===</code>).</p>

      <div class="test-js">
      <p><textarea id="js-vertailun-tyyppi-tyypilla" rows="9" cols="80">var auton_merkki = "";

if(auton_merkki === false) {
    console.log("Ehdottomasti totta!");
} else {
    console.log("Makes sense!");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-vertailun-tyyppi-tyypilla')" value="Suorita koodi!"></input></p>
      </div>


      <p>Sama pätee myös erisuuri kuin (<code>!=</code>) -vertailulle.</p>

      <h4>Toistolauseet</h4>

      <p>JavaScriptissä on käytössä for- ja while-toistolauseet.</p>

      <div class="test-js">
      <p><textarea id="js-for" rows="5" cols="80">for (var i = 0; i < 5; i++) {
    console.log(i);
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-for')" value="Suorita koodi!"></input></p>
      </div>

      <div class="test-js">
      <p><textarea id="js-while" rows="8" cols="80">var i = 0;

while(i < 5) {
    console.log(i);
    i++;
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-while')" value="Suorita koodi!"></input></p>
      </div>

      <h4>Funktiot, parametrit, ja arvon palauttaminen</h4>

      <p>Funktioille voi antaa arvoja, joita voidaan käyttää osana funktion lähdekoodia. Tämä on kätevää erityisesti silloin, kun samanlaista toiminnallisuutta tehdään useassa paikassa: toiminnallisuudesta voi tehdä funktion, jota voi kutsua. Funktiot voivat myös palauttaa arvon, joka asetetaan muuttujaan -- muuttujaa taas voidaan käyttää osana muuta ohjelmakoodia.</p>

      <p>Funktioiden parametrit toimivat seuraavasti:</p>

<pre class="sh_javascript_dom">
function tulostaViesti(viesti) {
    console.log(viesti);
}
</pre>


      <p>Kun ylläolevaa funktiota kutsutaan, sille tulee antaa parametri. Parametrille luodaan funktiokutsussa oma muuttuja <code>viesti</code>, johon parametrin arvo kopioidaan. Funktiota <code>tulostaViesti</code> suoritettaessa funktiolle <code>console.log</code> annetaan aina sen arvon kopio, jonka funktio <code>tulostaViesti</code> saa parametrina.</p>

      <p>Funktiot voivat myös palauttaa arvon. Arvo palautetaan komennolla <code>return</code>, jota seuraa palautettava arvo. Seuraavassa esimerkissä on funktio <code>kysyNumeroJaTarkista</code> kutsuu komentoa <code>return</code> ja palauttaa arvon -1 jos käyttäjän syöttämä arvo ei ole numero, muulloin palautetaan luettu arvo.</p>

<pre class="sh_javascript_dom">function kysyNumeroJaTarkista() {
    var syote = prompt("Kirjoita numero");

    if(isNaN(Number(syote))) {
        console.log("Et kirjoittanut numeroa!");
        return -1;
    }

    numero = parseInt(syote);

    if (numero == 5 || numero == 7) {
        console.log("Oikein meni!");
    }

    return numero;
}
</pre>

    <p>Jos komennolle <code>return</code> ei anna palautettavaa arvoa, funktiokutsusta poistutaan ilman arvon palauttamista.</p>

      <h4>Muuttujien näkyvyys</h4>

      <p>JavaScriptissä muuttujilla on kaksi näkyvyystyyppiä: paikallinen ja globaali. Paikalliset muuttujat ovat olemassa vain siinä funktiossa missä ne on esitelty. Globaalit muuttujat ovat olemassa kaikkialla. Muuttujia <em>voi</em> esitellä ilman määrettä <code>var</code>, jolloin ne ovat globaaleja. Tämä johtaa ennen pitkää kaaokseen. Testaa alla olevia koodeja, ja huomaa niiden ero!</p>


      <div class="test-js">
      <p><textarea id="js-varscope" rows="11" cols="80">function summaa(eka, toka) {
    summa = eka + toka;
    return summa;
}

summa = 100;
var tulos = summaa(25, 10);

console.log(summa);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-varscope')" value="Suorita koodi!"></input></p>
      </div>

      <div class="test-js">
      <p><textarea id="js-varscope-proper" rows="11" cols="80">function summaa(eka, toka) {
    var summa = eka + toka;
    return summa;
}

summa = 100;
var tulos = summaa(25, 10);

console.log(summa);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-varscope-proper')" value="Suorita koodi!"></input></p>
      </div>

<aside class="extra">
  <p>Mitä ylläolevissa esimerkeissä oikein tapahtuu? Miksi?</p>
</aside>

      <p>Käytä avainsanaa <code>var</code> <strong>aina</strong> kun esittelet muuttujan -- kunnes toisin sanotaan.</p>


      <h4>Taulukot</h4>

      <p>Taulukkotyyppisiä muuttujia voidaan luoda komennolla <code>new Array()</code>, jolle annetaan parametrina taulukon koko. Esimerkiksi seuraavassa luodaan 3 paikkaa sisältävä taulukko. Taulukkomuuttujan indeksointi tapahtuu hakasuluilla.</p>

<pre class="sh_javascript_dom">
var salasanat = new Array(3);
salasanat[0] = "salasana";
salasanat[1] = "alasanas";
salasanat[2] = "lasanasa";
</pre>


      <p>Jos taulukon arvot tiedetään ennalta, voidaan taulukko luoda myös suoraan konstruktorikutsussa.</p>

<pre class="sh_javascript_dom">
var salasanat = new Array("salasana", "alasanas", "lasanasa");
</pre>

      <p>Taulukot voivat sisältää myös erityyppisiä muuttujia.</p>

<pre class="sh_javascript_dom">
var tiedot = new Array("Mikke", 1984);
</pre>


      <h4>Oliot</h4>

      <p>Taulukoiden lisäksi JavaScriptissä tiedon käsittelyyn käytetään <code>Object</code>-tyyppisiä muuttujia, eli olioita. Olio luodaan komennolla <code>new Object()</code>, jonka jälkeen oliolle voi asettaa arvoja.</p>

<pre class="sh_javascript_dom">
var mikke = new Object();
mikke.nimi = "Mikke";
mikke.syntymavuosi = 1984;
</pre>

      <p>Olioiden luontiin liittyy myös hieman kevyempi syntaksi, joka saattaa olla joillekin palvelinohjelmointi-kurssilla olleille tutun näköinen.</p>

<pre class="sh_javascript_dom">
var mikke = {nimi: "Mikke", syntymavuosi: 1984};
</pre>

      <p>Olioiden rakenne ei ole ennalta määrätty. Voimme esimerkiksi luoda muuttujalle <code>mikke</code> vaimon helposti.</p>

<pre class="sh_javascript_dom">
var mikke = {nimi: "Mikke", syntymavuosi: 1984};

/* miken vaimo on ikinuori */
var kate = {nimi: "Kate", syntymavuosi: new Date().getFullYear() - 21};

mikke.vaimo = kate;

/* nyt voimme selvittää miken vaimon nimen seuraavasti */
console.log(mikke.vaimo.nimi);
</pre>


      <div class="test-js">
      <p><textarea id="js-mikke-ja-kate" rows="11" cols="80">var mikke = {nimi: "Mikke", syntymavuosi: 1984};

/* miken vaimo on ikinuori */
var kate = {nimi: "Kate", syntymavuosi: new Date().getFullYear() - 25};

mikke.vaimo = kate;

/* nyt voimme kysyä miken vaimon nimeä seuraavasti */
console.log(mikke.vaimo.nimi + " on syntynyt vuonna " + mikke.vaimo.syntymavuosi);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-mikke-ja-kate')" value="Suorita koodi!"></input></p>
      </div>


      <h3>Web-sivun elementtien arvojen käsittely</h3>


      <p>Palataan web-maailmaan. JavaScriptiä käytetään ennenkaikkea dynaamisen toiminnallisuuden lisäämiseksi web-sivuille. Esimerkiksi web-sivuilla oleviin elementteihin tulee pystyä asettamaan arvoja. JavaScriptissä pääsee käsiksi dokumentissa oleviin elementteihin komennolla <code>document.getElementById("tunnus")</code>, joka palauttaa elementin, jonka <code>id</code>-attribuutti on "tunnus".</p>

      <p>Alla olevassa esimerkissä on luotu tekstikenttä, jonka HTML-koodi on <code>&lt;input type="text" id="tekstikentta"/&gt;</code>. Kentän tunnus on siis <code>tekstikentta</code>. Javascriptillä on komento <code>document.getElementById("tunnus")</code>, jonka avulla voidaan hakea tietyn nimistä elementtiä. Tekstikenttäelementillä on attribuutti <code>value</code>, joka voidaan tulostaa.</p>


<div class="test-js">
      <p><input type="text" id="tekstikentta"/></p>

      <p><textarea id="js-tulosta-tekstikentan-arvo" rows="4" cols="80">var arvo = document.getElementById("tekstikentta").value;
console.log("Tekstikentän arvo oli " + arvo);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-tulosta-tekstikentan-arvo')" value="Suorita koodi!"></input></p>
</div>


      <p>Tekstikentälle voidaan asettaa arvo kuten muillekin muuttujille. Alla olevassa esimerkissä haetaan edellisen esimerkin tekstikenttä, ja asetetaan sille arvo <code>5</code>.</p>

      <div class="test-js">
    <p><textarea id="js-aseta-tekstikenttaan-arvo" rows="3" cols="80">document.getElementById("tekstikentta").value = 5;
</textarea></p>
    <p><input type="button" onclick="evalElementContent('js-aseta-tekstikenttaan-arvo')" value="Suorita koodi!"></input></p>
      </div>

      <p>Tehdään vielä ohjelma, joka kysyy käyttäjältä syötettä, ja asettaa sen yllä olevan tekstikentän arvoksi.</p>

      <div class="test-js">
    <p><textarea id="js-kysy-ja-aseta-tekstikenttaan-arvo" rows="3" cols="80">document.getElementById("tekstikentta").value = prompt("Kirjoita jotain!");</textarea></p>
    <p><input type="button" onclick="evalElementContent('js-kysy-ja-aseta-tekstikenttaan-arvo')" value="Suorita koodi!"></input></p>
      </div>




      <h4>Arvon asettaminen osaksi tekstiä</h4>

      <p>Yllä tekstikentälle asetettiin arvo sen <code>value</code>-attribuuttiin. Kaikilla elementeillä ei ole <code>value</code>-attribuuttia, vaan joillain näytetään niiden elementin <em>sisällä</em> oleva arvo. Elementin sisälle asetetaan arvo muuttujaan liittyvällä attribuutilla <code>innerHTML</code>. Tässä alapuolella on esimerkiksi <code>p</code>-elementti, jonka <code>id</code> on <code>js-hidden-p-element</code>, ja jolla ei ole mitään arvoa.</p>

      <p id="js-hidden-p-element"></p>

      <div class="test-js">
    <p><textarea id="js-kysy-ja-aseta-phen-arvo" rows="4" cols="80">var syote = prompt("Kirjoita jotain!");
document.getElementById("js-hidden-p-element").innerHTML = syote;
</textarea></p>
    <p><input type="button" onclick="evalElementContent('js-kysy-ja-aseta-phen-arvo')" value="Suorita koodi!"></input></p>
      </div>


      <p>Vastaavasti tekstin keskelle voi myös asettaa arvoja. Elementti <code>span</code> on tähän aivan mainio. <strong><span id="spanelementti">Tämä teksti on span-elementin sisällä, jonka tunnus on "spanelementti"</span></strong>.


      <div class="test-js">
    <p><textarea id="js-kysy-ja-aseta-spaniin-arvo" rows="4" cols="80">var syote = prompt("Kirjoita jotain!");
document.getElementById("spanelementti").innerHTML = syote;
</textarea></p>
    <p><input type="button" onclick="evalElementContent('js-kysy-ja-aseta-spaniin-arvo')" value="Suorita koodi!"></input></p>
      </div>


      <h3>Case: Laskin</h3>


      <p>Luodaan oma laskin. Laskimella on kaksi toiminnallisuutta: pluslasku ja kertolasku. Luodaan ensin laskimelle javascriptkoodi, joka on tiedostossa <code>laskin.js</code>. Javascript-koodissa oletetaan, että on olemassa <code>input</code>-tyyppiset elementit tunnuksilla "eka" ja "toka" sekä <code>span</code>-tyyppinen elementti tunnuksella "tulos". Funktiossa <code>plus</code> haetaan elementtien "eka" ja "toka" arvot, ja asetetaan pluslaskun summa elementin "tulos" arvoksi. Kertolaskussa tehdään lähes sama, mutta tulokseen asetetaan kertolaskun tulos. Koodissa on myös apufunktio, jota käytetään arvojen muuttamiseksi numeroiksi.</p>

<pre class="sh_javascript_dom">
function haeNumero(tunnus) {
    return parseInt(document.getElementById(tunnus).value);
}

function asetaTulos(tulos) {
    document.getElementById("tulos").innerHTML = tulos;
}

function plus() {
    asetaTulos(haeNumero("eka") + haeNumero("toka"));
}

function kerto() {
    asetaTulos(haeNumero("eka") * haeNumero("toka"));
}
</pre>

      <p>Laskimen käyttämä HTML-dokumentti näyttää seuraavalta:</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;
        &lt;title&gt;Laskin&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;header&gt;
            &lt;h1&gt;Plus- ja Kertolaskin&lt;/h1&gt;
        &lt;/header&gt;

        &lt;section&gt;
            &lt;p&gt;
                &lt;input type="text" id="eka" value="0"/ &gt;
                &lt;input type="text" id="toka" value="0" /&gt;
            &lt;/p&gt;

            &lt;p&gt;
                &lt;input type="button" value="+" onclick="plus();" /&gt;
                &lt;input type="button" value="*" onclick="kerto();" /&gt;
            &lt;/p&gt;


            &lt;p&gt;Laskimen antama vastaus: &lt;span id="tulos"&gt;&lt/span&gt;&lt;/p&gt;
        &lt;/section&gt;

        &lt;script src="laskin.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>Laskin itsessään näyttää seuraavalta:</p>

<div class="naytto">
        <header>
            <h1>Plus- ja Kertolaskin</h1>
        </header>

        <section>
            <p>
                <input type="text" id="eka" value="0"></input>
                <input type="text" id="toka" value="0"></input>
            </p>

            <p>
                <input type="button" value="+" onclick="laskinPlus();"></input>
                <input type="button" value="*" onclick="laskinKerto();"></input>
            </p>


            <p>Laskimen antama vastaus: <span id="tulos"></span></p>
        </section>

        <script>
function laskinHaeNumero(tunnus) {
    return parseInt(document.getElementById(tunnus).value);
}

function laskinAsetaTulos(tulos) {
    document.getElementById("tulos").innerHTML = tulos;
}

function laskinPlus() {
    laskinAsetaTulos(laskinHaeNumero("eka") + laskinHaeNumero("toka"));
}

function laskinKerto() {
    laskinAsetaTulos(laskinHaeNumero("eka") * laskinHaeNumero("toka"));
}
</script>
</div>



<div class="tehtavat">
      <h3>Laskimen jatkokehitys</h3>

      <p>Yllä oleva laskin tulee mukana tehtäväpohjassa. Tehtävänäsi on ensin lisätä laskimelle myös miinus- ja jakolaskut. Kun miinus- ja jakolasku toimii, integroi visualisoinnista tykkäävän kaverisi alla oleva koodi osaksi laskimen toimintaa. Alla oleva koodi lisää laskimeen piirtoelementin, sekä piirtää ruudulle liikkuvan neliön, jonka vauhti riippuu tuloksesta.</p>


      <pre class="sh_html">
        &lt;section&gt;
            &lt;canvas id="alusta" width="300" height="200" &gt;&lt;/canvas&gt;
        &lt;/section&gt;</pre>


      <pre class="sh_javascript_dom">
window.requestAnimFrame = (function(){
    return window.requestAnimationFrame       ||
           window.webkitRequestAnimationFrame ||
           window.mozRequestAnimationFrame    ||
           window.oRequestAnimationFrame      ||
           window.msRequestAnimationFrame     ||
           function(/* kutsuttava funktio */ callback, /* elementti */ element){
               window.setTimeout(callback, 1000 / 60);
           };
    })();


function ajasta() {
    piirra();
    requestAnimFrame( ajasta );
}

function piirra() {
    var piirturi = document.getElementById("alusta").getContext("2d");
    var nopeus = parseInt(document.getElementById("tulos").innerHTML);
    if(!nopeus) {
        nopeus = 2;
    }

    if(nopeus < 0) {
        nopeus = 1 / (nopeus * -1);
    }

    var aika = new Date().getTime() * 0.001 * nopeus;
    var x = Math.sin( aika ) * 100 + 125;

    //  piirretään ensin valkoinen tausta
    piirturi.fillStyle = "rgb(255, 255, 255)";
    piirturi.fillRect( 0, 0, 300, 200 );

    // ja sitten neliö
    piirturi.fillStyle = "rgb(255,0,0)";
    piirturi.fillRect(x, 50, 50, 50);
}

ajasta();
      </pre>

      <p>Kun olet valmis, ja sivun ladatessa näet liikkuvan punaisen neliön, jonka vauhti riippuu laskimen tuloksesta, palauta tehtävä TMC:lle.</p>
    </div>
</div>



      <h3>Case: Tyylien muuttaminen JavaScriptillä</h3>


      <p>JavaScriptiä voi käyttää myös tyylien muokkaamiseen. Attribuutin <code>class</code> arvoa voi muuttaa dokumentista saatavan olion attribuutilla <code>className</code>. Tehdään vielä esimerkki, jossa sivulla oleva tieto vaihtuu linkkiä klikkaamalla, <em>mutta</em> selain ei oikeasti siirry sivulta toiselle. Luodaan ensiksi HTML-dokumentti, jossa on valmiiksi paikat tyylitiedostolle <code>style.css</code> ja lähdekoodille <code>script.js</code>.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;link rel="stylesheet" href="style.css" type="text/css" &gt;
    &lt;/head&gt;
    &lt;body onload="init();" &gt;
        &lt;header&gt;
            &lt;h1&gt;Kindler&lt;/h1&gt;

            &lt;nav&gt;
                &lt;!-- komento return false; estää selaimen siirtymisen toiselle sivulla --&gt;
                &lt;a href="#" onclick="displayArticle(0);return false;"&gt;Eka artikkeli&lt;/a&gt;
                &lt;a href="#" onclick="displayArticle(1);return false;"&gt;Toka artikkeli&lt;/a&gt;
            &lt;/nav&gt;
        &lt;/header&gt;

        &lt;article&gt;
      &lt;h1&gt;Eka artikkeli&lt;/h1&gt;

      &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit...&lt;/p&gt;
    &lt;/article&gt;

        &lt;article&gt;
      &lt;h1&gt;Toka artikkeli&lt;/h1&gt;

      &lt;p&gt;Morbi a elit enim, sit amet iaculis massa. Vivamus blandit...&lt;/p&gt;
    &lt;/article&gt;

        &lt;article&gt;
      &lt;h1&gt;Kolmas artikkeli&lt;/h1&gt;

      &lt;p&gt;Now that we know who you are, I know who I am. I'm...&lt;/p&gt;
    &lt;/article&gt;


        &lt;script src="script.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>Luodaan seuraavaksi sivulle tyylitiedosto. Määritellään <code>article</code>-elementille tyyliluokka "hidden": jos article-elementillä on tyyliluokka hidden, sitä ei näytetä selaimessa.</p>

<pre class="sh_css">
article.hidden {
    display: none;
}
</pre>

      <p>Luodaan seuraavaksi JavaScript-toiminnallisuus. Emme käsittele sivua tunnusten avulla, vaan käytämme elementtien läpikäyntiin niiden tyyppejä. Haluamme käytännössä käsitellä kaikkia sivulla olevia <code>article</code>-elementtejä. Tähän on kätevä komento <code>document.getElementsByTagName("elementinNimi")</code>, joka palauttaa taulukon elementeistä, joiden elementin nimi on "elementinNimi". Haluamme myös, että kun sivu on ladattu, näytetään vain ensimmäinen artikkeli. Tätä varten <code>body</code>-elementille on olemassa attribuutti <code>onload</code>, jolle voi määritellä funktion nimen, jota kutsutaan kun sivun lataaminen on valmis.</p>

<pre class="sh_javascript_dom">
function init() {
    displayArticle(0);
}

function displayArticle(index) {
    var articles = document.getElementsByTagName("article");

    for(var i = 0; i < articles.length; i++) {
        if (index == i) {
            articles[i].className='';
        } else {
            articles[i].className='hidden';
        }
    }
}
</pre>


    <div class="tehtavat">
      <h3>PerusMOOC (3p)</h3>

      <p>Huom! Tämä tehtävä on kolmen pisteen arvoinen: palauta se vain jos teet tehtävän kokonaan.</p>

      <p>Tehtävässä on käytetty seuraavia värejä:</p>

      <ul>
    <li>rgb(233, 229, 217);</li>
    <li>rgb(73, 69, 69);</li>
    <li>rgb(66, 126, 120);</li>
      </ul>

      <p>Fonttien määrittely on muotoa</p>
<pre class="sh_css">
    font-family: 'Trebuchet MS', Trebuchet, Arial, sans-serif;
</pre>


      <p>Tehtävän mukana tuleva sivu näyttää seuraavanlaiselta:</p>

      <img src="img/perusmooc-1.png" border=1/>

      <p>Tehtävänäsi on ensin lisätä sivulle tyylitiedosto, jonka avulla sivusta tulee seuraavannäköinen. Kun lisäät tyylitiedostoa, lisää valikkoon myös toiminnallisuus, jonka avulla linkin tausta muuttuu kun hiiri on sen päällä.</p>

      <img src="img/perusmooc-2.png" border=1/>

      <p>Kun tyylit ovat valmiit, lisää sivulle toiminnallisuus, jossa vain ensimmäinen osio näkyy ensin. Linkkejä klikkaamalla sivulla vaihdetaan osiosta toiseen. Alla olevassa kuvassa osiota "Materiaali" on juuri klikattu.</p>

      <img src="img/perusmooc-3.png" border=1/>

      <p>Kun olet valmis, ja sivusi näyttää oikealta Chromessa, palauta tehtävä TMC:lle.</p>

    </div>


    <h2>DOM</h2>

    <p>DOM (<em>Document Object Model</em>) on ohjelmointirajapinta HTML (ja XML) -dokumenttien rakenteen ja sisällön muokkaamiseksi. Se sisältää kuvauksen HTML-dokumentin elementeistä ja niiden asemoinnista dokumentissa. HTML-dokumentti kuvataan usein puumaisena tietorakenteena, jossa jokainen sivun elementti on puun solmu (oksa) tai lehti (solmu, josta ei lähde oksia). Jokaisella elementillä on myös nimi, jolla siihen pääsee käsiksi.</p>

    <p>Suurin osa nykyaikaisista web-selaimista toteuttaa <a href="http://www.w3.org/DOM/" target="_blank">W3C DOM</a>-standardin, sekä usein tarjoavat omia lisävälineitä dokumenttien muokkaamiseen. W3C DOM-standardi sisältää esimerkiksi aiemmin käyttämämme kutsun <code>document.getElementById("tunnus")</code>, jonka avulla päästään käsiksi dokumentin sisältämään elementtiin, jonka attribuutin <code>id</code> arvo on "tunnus".</p>

    <p>HTML-dokumentin elementit ja niihin liittyvät ominaisuudet (attribuutit, tapahtumat, ...) on jäsennelty erilaisiin olioihin. Osaan pääsee käsiksi suoraan. Esimerkiksi <code>window</code>-oliolla päästään käsiksi mm. selainikkunassa tapahtuviin tapahtumiin (esim. näppäimistön kuuntelu), <code>document</code>-olio taas liittyy HTML-dokumenttiin ja sen sisältämiin elementteihin. Kaikkiin dokumentin elementteihin pääsee käsiksi <code>document</code>-elementin kautta.</p>

    <p>Esimerkiksi dokumentissa olevan <code>canvas</code>-elementin saa haettua siihen liittyvällä tunnuksella <code>document</code>-oliota käyttäen. Mozillan sovelluskehittäjien sivustolla on hyvä kuvaus elementteihin liittyvistä rajapinnoista, kts. <a href="https://developer.mozilla.org/en-US/docs/Gecko_DOM_Reference#HTML_element_interfaces" target="_blank">https://developer.mozilla.org/en-US/docs/Gecko_DOM_Reference#HTML_element_interfaces</a>.</p>

    <p>DOM-standardi sisältää useita tasoja, eli versioita. <a href="http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/" target="_blank">Taso 1</a> sisältää mm. dokumentin elementtien luomisen sekä hakemisen <code>getElementsByTagName</code>-komennolla. Kutsu <code>getElementsByTagName</code> attribuutilla <code>*</code> palauttaa listan, joka sisältää kaikki sivun elementit. Lähes kaikki nykyään käytössä olevat selaimet tukevat tason 1 toiminnallisuutta. <a href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/" target="_blank">Taso 2</a> sisältää mm. tuen dokumentin tyylien muokkaamiseen DOM-puun kautta sekä erilaisten tapahtumien (mm. hiiri, näppäimistö) käsittelyä tukevan järjestelmän. <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/" target="_blank">Taso 3</a> laajentaa tason 2 toiminnallisuutta mm. dokumentin elementtien ja tapahtumien käsittelyssä.</p>

    <p>DOM-spesifikaatio sisältää useita eri komponentteja. Alla kuva DOM-arkkitehtuurista.</p>

    <p><img src="img/dom-architecture.png"></p>

    <p>W3C työskentelee tällä hetkellä (1.11.2012) tason 4 spesifikaation kanssa. <a href="http://www.w3.org/TR/domcore/" target="_blank">Taso 4</a> tulee olemaan laajennus aiempiin tasoihin, joka tarjoaa mm. selvennyksiä tapahtumien käsittelyyn ja lisätoiminnallisuuksia dokumentin identifiointiin.</p>

    <aside class="extra">
      <p><strong>Selaintuki</strong></p>

      <p>Uusimpien DOM-spesifikaatioiden ja lisäosien tuki on rikkinäinen osassa selaimia. Selainvalmistajat eivät usein kiinnitä huomiota vanhempiin selainversioihin, jolloin uudet ominaisuudet ovat käytössä vasta uudemmissa selaimissa. Sivusto "Can I Use..." (<a href="http://caniuse.com" target="_blank">http://caniuse.com</a> on yksi monista sivustoista, jotka tarjoavat spesifikaatioiden ja lisäosien yhteensopivuuslistauksia eri selaimille.</p>

    </aside>


<!--
query selectorit http://www.w3.org/TR/selectors-api/
-->

    <h3>Elementtien valinta</h3>

    <p>Olemme käyttäneet dokumentin <code>getElementById</code>-kutsua tietyn elementin hakemiseen. Kaikki sivun elementit voi taas hakea esimerkiksi <code>getElementsByTagName("*")</code>-kutsulla. Molemmat ovat kuitenkin hieman kömpelöjä jos tiedämme mitä haluamme hakea verrattuna esimerkiksi CSS:n käyttämään elementtien valintatyyliin (kts. <a href="http://www.w3.org/TR/selectors/#selectors" target="_blank">http://www.w3.org/TR/selectors/#selectors</a>.</p>

    <p>W3C DOM-määrittely sisältää myös paremman ohjelmointirajapinnan elementtien läpikäyntiin. <a href="http://www.w3.org/TR/selectors-api/" target="_blank">Selectors API</a> sisältää mm. <code>querySelector</code>-kutsun, jolla saadaan CSS-valitsinten kaltainen kyselytoiminnallisuus.</p>

    <p>Selector APIn tarjoamien <code>querySelector</code> (yksittäisen osuman haku) ja <code>querySelectorAll</code> (kaikkien osumien haku) -komentojen avulla kyselyn rajoittaminen vain <code>header</code>-elementissä oleviin <code>a</code>-elementteihin on helppoa.</p>

<pre class="sh_javascript_dom">
var linkit = document.querySelectorAll("nav a");
// linkit-muuttuja sisältää nyt kaikki a-elementit, jotka ovat nav-elementin sisällä
</pre>

    <p>Vastaavasti <code>header</code>-elementin sisällä olevat linkit voi hakea seuraavanlaisella kyselyllä.</p>

<pre class="sh_javascript_dom">
var linkit = document.querySelectorAll("header a");
// linkit-muuttuja sisältää nyt kaikki a-elementit, jotka ovat header-elementin sisällä
</pre>


    <p>Myös tietyn luokan toteuttavien elementtien haku on helppoa. Alla olevassa esimerkissä on kolme tekstikenttää, joista 2 on piilotettu. Piilotettujen tekstikenttien tyyliluokka on <code>dom-esim-1-hidden</code>.</p>

<style>
.dom-esim-1-hidden {
    display: none;
}
</style>

<div class="naytto">
  <article class="dom-esim-1">
    <p class="dom-esim-1-hidden">text 1</p>
    <p>text 2</p>
    <p class="dom-esim-1-hidden">text 3</p>
  </article>
</div>

    <div class="test-js">
      <p><textarea id="dom-esim-1-js" rows="4" cols="80">var elementit = document.querySelectorAll(".dom-esim-1-hidden");
for(var i = 0; i < elementit.length; i++) {
    elementit[i].className = "";
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('dom-esim-1-js')" value="Suorita koodi!"></input></p>
    </div>


    <p>Voimme hakea querySelectorin avulla myös elementtejä, joilta puuttuu tietty ominaisuus. Alla haemme kaikki tyyliluokan <code>dom-esim-2</code> toteuttavan elementin sisällä olevat <code>p</code>-elementit, joilla ei ole tyyliluokkaa <code>dom-esim-2-hidden</code>. Lopuksi lisäämme kyselyssä löydetyille elementeille tyyliluokan <code>dom-esim-2-hidden</code>, jolloin elementit piilotetaan.</p>

    <p>Alla olevan sivun lähdekoodi on seuraavanlainen (tyyliluokkien oudot nimet johtuvat tämän dokumentin rakenteesta -- haluamme että esimerkit eivät vaikuta toisiin esimerkkeihin).</p>

<pre class="sh_html">
  &lt;article class="dom-esim-2"&gt;
    &lt;p class="dom-esim-2-hidden"&gt;text 1&lt;/p&gt;
    &lt;p&gt;text 2&lt;/p&gt;
    &lt;p class="dom-esim-2-hidden"&gt;text 3&lt;/p&gt;
  &lt;/article&gt;
</pre>

<style>
.dom-esim-2-hidden {
    display: none;
}
</style>

<div class="naytto">
  <article class="dom-esim-2">
    <p class="dom-esim-2-hidden">text 1</p>
    <p>text 2</p>
    <p class="dom-esim-2-hidden">text 3</p>
  </article>
</div>

    <div class="test-js">
      <p><textarea id="dom-esim-2-js" rows="5" cols="100">var elementit = document.querySelectorAll(".dom-esim-2 p:not(.dom-esim-2-hidden)");
for(var i = 0; i < elementit.length; i++) {
    elementit[i].className = "dom-esim-2-hidden";
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('dom-esim-2-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Mitä käy jos poistat ylläolevasta kyselystä alkuosan <code>dom-esim-2</code> ja suoritat kyselyn? Pohdi ennen kokeilemista!</p>


    <h3>Elementtien lisääminen</h3>

    <p>HTML-dokumenttiin lisätään uusia elementtejä <code>document</code>-olion <code>createElement</code>-metodilla. Esimerkiksi alla luodaan <code>p</code>-elementti, joka asetetaan muuttujaan <code>tekstiElementti</code>. Tämän jälkeen luodaan tekstisolmu, joka sisältää tekstin "o-hai". Lopulta tekstisolmun lisätään tekstielementtiin.</p>

<pre class="sh_javascript_dom">
var tekstiElementti = document.createElement("p");
var tekstiSolmu = document.createTextNode("o-hai");

tekstiElementti.appendChild(tekstiSolmu);
</pre>

    <p>Ylläoleva esimerkki ei luonnollisesti muuta HTML-dokumentin rakennetta sillä uutta elementtiä ei lisätä osaksi HTML-dokumenttia. Olemassaoleviin elementteihin voidaan lisätä sisältöä elementin <code>appendChild</code>-metodilla. Alla olevan tekstialue sisältää <code>article</code>-elementin, jonka tunnus on <code>dom-esim-3</code>. Voimme lisätä siihen elementtejä elementin <code>appendChild</code>-metodilla.</p>

    <div class="naytto">
      <div id="dom-esim-3">
      </div>
    </div>

    <div class="test-js">
      <p><textarea id="dom-esim-3-js" rows="7" cols="80">var tekstiElementti = document.createElement("p");
var tekstiSolmu = document.createTextNode("o-noes!");

tekstiElementti.appendChild(tekstiSolmu);

var alue = document.getElementById("dom-esim-3");
alue.appendChild(tekstiElementti);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('dom-esim-3-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Artikkelielementin sekä sen sisältämien tekstielementtien lisääminen onnistuu vastaavasti. Alla olevassa esimerkissä käytössämme on seuraavanlainen <code>section</code>-elementti.</p>

<pre class="sh_html">
&lt;!-- .. dokumentin alkuosa .. --&gt;
    &lt;section id="dom-esim-4"&gt;&lt;/section&gt;
&lt;!-- .. dokumentin loppuosa .. --&gt;
</pre>

    <p>Uusien artikkelien lisääminen onnistuu helposti aiemmin näkemällämme <code>createElement</code>-metodilla.</p>

    <div class="naytto">
      <section id="dom-esim-4">
      </section>
    </div>

    <div class="test-js">
      <p><textarea id="dom-esim-4-js" rows="12" cols="80">var artikkeli = document.createElement("article");

var teksti1 = document.createElement("p");
teksti1.appendChild(document.createTextNode("Lorem ipsum... 1"));
artikkeli.appendChild(teksti1);

var teksti2 = document.createElement("p");
teksti2.appendChild(document.createTextNode("Lorem ipsum... 2"));
artikkeli.appendChild(teksti2);

document.getElementById("dom-esim-4").appendChild(artikkeli);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('dom-esim-4-js')" value="Suorita koodi!"></input></p>
    </div>

    <div class="tehtavat">

      <h3>DOM Walker</h3>

      <p>Luo tehtäväpohjaan koodi, joka käy läpi kaikki sivun <code>body</code>-elementin sisällä olevat elementit, ja tulostaa niiden tägien nimet elementtiin, joka on tunnukseltaan "dom". Älä tulosta "dom"-tunnuksella varustettuun elementtiin "dom"-tunnuksellista elementtiä tai sen sisällä olevia elementtejä -- vältä siis loputonta toistoa. Koodi tulee suorittaa kun sivu on ladattu.</p>

      <p>Tehtäväpohjan mukana olevan sivun kanssa koodi tulostaa sivun loppuun seuraavanlaisen listan elementtejä. Voit käyttää <code>p</code>-elementtiä tägien nimien erotteluun.</p>

<pre>
HEADER

H1

NAV

UL

LI

A

LI

A

SECTION

HEADER

H1

ARTICLE

P

SECTION

HEADER

H1

ARTICLE

P

SCRIPT
</pre>

      <p>Kun sovellus toimii toivotusti, palauta se TMC:lle.</p>


    </div>

</section>

<section class="week">
    <header>
        <a name="viikko2"></a>
        <h1 data-week-id="2">Viikko 2</h1>
    </header>


<!--
elementtien lisääminen ja poistaminen js:llä
elementtien lapset ja niiden läpikäynti
-->

    <h3>Elementtien poistaminen</h3>

    <p>Dokumentin puumaisen rakenteen takia elementin lisääminen tapahtuu elementin vanhempaan liittyvällä <code>appendChild</code>-metodilla. Koska elementin vanhempi pitää kirjaa kaikista sen lapsista, tulee elementti myös poistaa sen vanhemman kautta.</p>


    <p>DOM-puun elementtien toteuttamat <a href="https://developer.mozilla.org/en-US/docs/DOM/element#Methods" target="_blank">metodit</a> sisältävät metodin <code><a href="https://developer.mozilla.org/en-US/docs/DOM/Node.removeChild" target="_blank">removeChild</a></code>, jota voi käyttää lapsielementin poistamiseen. Alla olevassa esimerkissä haluamme poistaa elementin, jonka tunnus on "poistettava".</p>

<pre class="sh_javascript_dom">
// myös document.getElementById("poistettava") käy
var poistettava = document.querySelector("#poistettava");
poistettava.parentNode.removeChild(poistettava);</pre>


<pre class="sh_html">
&lt;!-- .. dokumentin alkuosa .. --&gt;
    &lt;article id="poistettava"&gt;
        &lt;p&gt;Lorem Ipsum jne..&lt;/p&gt;
    &lt;/article&gt;
&lt;!-- .. dokumentin loppuosa .. --&gt;</pre>

<div class="naytto">
  <article id="poistettava">
    <p>Lorem Ipsum jne..</p>
  </article>
</div>

    <div class="test-js">
      <p><textarea id="dom-esim-5-js" rows="3" cols="80">var poistettava = document.querySelector("#poistettava");
poistettava.parentNode.removeChild(poistettava);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('dom-esim-5-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Yllä olevan koodin suorituksen jälkeen elementti on poistettu DOM-puusta. Nykyaikaisissa selaimissa oleva roskienkeruumekanismi poistaa myös poistettavien elementtien lapsielementit.</p>

    <h3>Tapahtumien käsittely</h3>

    <p>Tason 2 DOM-spesifikaatiossa määriteltiin tuki tapahtumien käsittelylle, kts. <a href="http://www.w3.org/TR/DOM-Level-2-Events/" target="_blank">http://www.w3.org/TR/DOM-Level-2-Events/</a>. Tason 3 spesifikaatio ei ole vielä valmis, mutta sen viimeisin versio löytyy <a href="http://www.w3.org/TR/DOM-Level-3-Events/" target="_blank">täältä</a>).</p>

    <p>Käytännössä tapahtumien käsittely toimii tapahtumaohjatusti. Jokaisella toiminnolla on kohde, johon se liittyy. Kun sivuilla esimerkiksi klikataan hiiren nappia, DOM-toteutus ohjaa tapahtuman nappiin mahdollisesti liitetylle tapahtumankuuntelijalle. Jos napille on rekisteröity tapahtumankuuntelija, suoritetaan tapahtumankuuntelijan koodi.</p>

    <p>Tapahtumien käsittelyä varten sivuille tulee määritellä funktioita. Olemme aiemmin määritelleet tapahtumien sattuessa kutsuttavat funktiot osaksi HTML-dokumenttia seuraavasti.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;link rel="stylesheet" href="style.css" type="text/css" &gt;
    &lt;/head&gt;
    &lt;body onload="init();" &gt;
        &lt;header&gt;
            &lt;h1&gt;Kindler&lt;/h1&gt;

            &lt;nav&gt;
                &lt;!-- komento return false; estää selaimen siirtymisen toiselle sivulla --&gt;
                &lt;a href="#" onclick="displayArticle(0);return false;"&gt;Eka artikkeli&lt;/a&gt;
                &lt;a href="#" onclick="displayArticle(1);return false;"&gt;Toka artikkeli&lt;/a&gt;
            &lt;/nav&gt;
        &lt;/header&gt;

        &lt;!-- muu sisältö --&gt;

        &lt;!-- lähdekooditiedostojen lataus --&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Vastuiden erottamisen näkökulmasta yllä oleva lähestymistapa on huono, ja haluamme eriyttää sovelluslogiikan käyttöliittymästä. Äärinäkökulmasta katsottuna ainoa HTML-dokumentissa sallittu JavaScript-kutsu on <code>body</code>-elementin <code>onload</code>-attribuutille määriteltävä kutsu, joka suoritetaan kun sisältö on ladattu.</p>

    <p>Yksi tapa poistaa ylläolevassa dokumentissa olevat JavaScript-kutsut on lisätä init-metodiin tapahtumankäsittelijöiden lisääminen. Käytetään aiemmin oppimaamme <code>querySelector</code>-toteutusta siten, että lisäämme tapahtumankäsittelijät vain menuvalikon linkkeihin. Jotta saisimme tapahtumankäsittelijän toimimaan oikein <code>a</code>-elementissä, meidän tulee myös kieltää linkin seuraaminen. Tämä onnistuu tapahtumaan liittyvällä kutsulla <code>preventDefault()</code>.</p>

<pre class="sh_javascript_dom">
function init() {
    var navLinks = document.querySelectorAll("header nav a");
    for(var i = 0; i < navLinks.length; i++) {
        var link = navLinks[i];

        // lisätään elementille id, josta päätellään näytettävä artikkeli
        link.id = i;

        link.onclick = function(eventInformation) {
            var origin = eventInformation.target;

            // kutsutaan erillistä displayArticle-funkiota, joka
            // näyttää halutun artikkelin
            displayArticle(origin.id);

            // kielletään selainta tekemästä oletustoiminto (siirtyminen)
            eventInformation.preventDefault();
        }
    }

    // ...
}
</pre>

    <p>Nyt aiempi sivumme toimii myös seuraavannäköisenä.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;link rel="stylesheet" href="style.css" type="text/css" &gt;
    &lt;/head&gt;
    &lt;body onload="init();" &gt;
        &lt;header&gt;
            &lt;h1&gt;Kindler&lt;/h1&gt;

            &lt;nav&gt;
                &lt;a href="#"&gt;Eka artikkeli&lt;/a&gt;
                &lt;a href="#"&gt;Toka artikkeli&lt;/a&gt;
            &lt;/nav&gt;
        &lt;/header&gt;

        &lt;!-- muu sisältö --&gt;

        &lt;!-- lähdekooditiedostojen lataus --&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>

    <p>Oikeastaan yllä käyttämämme lähestymistapa on myös hieman hölmö. Kun määrittelemme <code>onclick</code>-funktion, korvaamme aiemman funktion. Fiksumpaa olisi lisätä uusi funktio aiempien lisäksi. Tämä onnistuu elementteihin liittyvällä metodilla <code>addEventListener</code>. Metodille <code>addEventListener</code> määritellään tapahtuman nimi (esim <code>click</code>, huomaa ero!), funktio jota kutsutaan (joko funktion nimi tai konkreettinen toteutus), ja totuusarvoinen muuttuja, jolla kerrotaan tuleeko muun dokumentin reagoida tapahtumaan. Tällöinkin tapahtumaan reagoivat vain elementit, jotka ovat tapahtuman laukaisevan elementin vanhempia.</p>


<pre class="sh_javascript_dom">
function init() {
    var navLinks = document.querySelectorAll("header nav a");
    for(var i = 0; i < navLinks.length; i++) {
        var link = navLinks[i];

        // lisätään elementille id, josta päätellään näytettävä artikkeli
        link.id = i;

        // lisätään tapahtumankuuntelija tapahtumalle click. huom! ero onclick-attribuuttiin
        link.addEventListener('click', function(eventInformation) {
            var origin = eventInformation.target;

            // kutsutaan erillistä displayArticle-funkiota, joka
            // näyttää halutun artikkelin
            displayArticle(origin.id);

            // kielletään selainta tekemästä oletustoiminto (siirtyminen)
            eventInformation.preventDefault();
        }, false);
    }

    // ...
}
</pre>

    <p>Tapahtumankäsittelyyn liittyvän funktion voi määritellä myös erikseen, jolloin tapahtumankäsittelijää lisättäessä funktioon viitataan sen nimellä.</p>


<pre class="sh_javascript_dom">
function handleLinkClick(eventInformation) {
    var origin = eventInformation.target;

    // kutsutaan erillistä displayArticle-funkiota, joka
    // näyttää halutun artikkelin
    displayArticle(origin.id);

    // kielletään selainta tekemästä oletustoiminto (siirtyminen)
    eventInformation.preventDefault();
}

function init() {
    var navLinks = document.querySelectorAll("header nav a");
    for(var i = 0; i < navLinks.length; i++) {
        var link = navLinks[i];

        // lisätään elementille id, josta päätellään näytettävä artikkeli
        link.id = i;

        // lisätään tapahtumankuuntelija tapahtumalle click. huom! ero onclick-attribuuttiin
        link.addEventListener('click', handleLinkClick, false);
    }

    // ...
}
</pre>

    <p>Lisää eri tapahtumatyypeistä ja tapahtumankäsittelystä löydät esim. <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html" target="_blank">täältä</a>.</p>


    <div class="tehtavat">
      <NEXTWEEK></NEXTWEEK>

      <h3>PerusMOOC, jatkoa</h3>

      <p>Tehtäväpohjassa on viime viikon loppupuolelta alustava PerusMOOC-sivu. Sivulla on kuitenkin vielä ongelma: html-sivu sisältää JavaScriptiä enemmän kuin on sallittu.</p>

      <p>Muuta sivustoa siten, että ainoa <code>index.html</code>-sivun JavaScript-kutsu on <code>body</code>-elementin <code>onload</code>-attribuutille asetettu <code>init();</code>-funktiokutsu. Sivun toiminnallisuuden tulee pysyä ennallaan.</p>

      <p>Varaudu myös siihen, että linkeille saatetaan asettaa myöhemmin toteutettavissa koodeissa uusia tapahtumankäsittelijöitä.</p>

      <p>Kun sovellus toimii toivotusti, palauta se TMC:lle.</p>

    </div>


    <h2>Lisää JavaScriptistä</h2>

    <p>Käydään läpi hieman tarkemmin JavaScriptiin liittyviä mielenkiintoisuuksia, sekä tutustutaan hyviin ohjelmointikäytänteisiin.</p>

    <h3>Muuttujien näkyvyys</h3>

    <p>Olemme aiemmin todenneet, että JavaScriptissä muuttujilla on kaksi eri näkyvyystyyppiä, paikallinen ja globaali. Paikallisella näkyvyydellä tarkoitetaan että muuttujat ovat olemassa vain funktion sisällä, ja globaalilla sitä, että muuttujat ovat näkyvissä kaikkialla. Kun muuttuja määritellään <code>var</code>-etuliitteellä, on se olemassa funktiossa, jossa se on määritelty.</p>

    <p>Mitä tarkoittaa "muuttuja on olemassa funktiossa, jossa se on määritelty"? Pohdi seuraavaa ohjelmaa ja päättele mitä tapahtuu kun painat "Suorita koodi!"-nappia.</p>

    <div class="test-js">
      <p><textarea id="js-nakyvyys" rows="11" cols="80">var summa = 21;

function mitaKay() {
    if (false) {
        var summa = 42;
    }

    alert(summa);
}

mitaKay();</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-nakyvyys')" value="Suorita koodi!"></input></p>
    </div>


    <p>Uskoisimme, että et arvannut lopputulosta, jollet tuntenut JavaScriptiä ennalta.</p>

    <p>Käytännössä JavaScript siirtää muuttujien määrittelyt funktion alkuun, mutta muuttujien arvon asetus tapahtuu alkuperäisen koodin määrittelemässä kohdassa. Ylläoleva koodi tulkitaan JavaScript-tulkin toimesta seuraavasti.</p>

<pre class="sh_javascript_dom">
var summa = 21;

function mitaKay() {
    var summa;

    if (false) {
        summa = 42;
    }

    alert(summa);
}

mitaKay();
</pre>

    <p>Koska ylläolevassa ohjelmakoodissa funktion <code>mitaKay</code> sisällä määritellylle muuttujalle <code>summa</code> ei koskaan aseteta arvoa, on sen arvo <code>undefined</code>.</p>


    <h3>Olio-ohjelmointi ja prototyyppimalli</h3>

    <p>Olio-ohjelmoinnissa kyse on ennen kaikkea ongelma-alueen käsitteiden mallintamisesta osana ohjelmakoodia. Olio-ohjelmoinnissa ohjelmoijat pyrkivät puhumaan samoilla käsitteillä kuin ohjelmistoa tilaavat asiakkaat. Käsitteet liittyvät maailmassa olevaan dataan, ja ovat interaktiossa toisten käsitteiden kanssa olioihin liittyvien metodien kautta.</p>

    <p>Kommunikaation ja käsitemaailman helpottamisen lisäksi olio-ohjelmoinnissa ohjelma hajoitetaan hallittaviksi osiksi, jotka kapseloivat pienempää toiminnallisuutta. Kukin olio voi sisältää dataa sekä lähettää ja vastaanottaa informaatiota.</p>

    <p>JavaScriptissä ei ole mm. Javasta tuttuja luokkia, vaan uusien olioiden luominen tapahtuu funktiokutsuilla. JavaScript-kielen oliomalli perustuu funktioihin, joiden prototyyppeihin voidaan liittää uusia funktioita.</p>

    <p>Tutkitaan hieman erilaisia koodiesimerkkejä.</p>

    <p>Luodaan uusi olio <code>new Object()</code>-kutsulla. Oliolle asetetaan muuttujat <code>nimi</code> ja <code>ika</code>.</p>

<pre class="sh_javascript_dom">
var mikke = new Object();
mikke.nimi = "Michael Knight";
mikke.ika = 17;

console.log(mikke.nimi);
</pre>

    <p>Ylläoleva ohjelmakoodi vastaa allaolevaa olion luomista.</p>

<pre class="sh_javascript_dom">
var mikke = {nimi: "Michael Knight", ika: 17};
console.log(mikke.nimi);
</pre>

    <p>Olion muuttujiin pääsee käsiksi myös seuraavanlaisen notaation avulla. Notaatio saattaa olla tuttu mikäli on aiemmin ohjelmoinut esimerkiksi PHP:llä tai perlillä.</p>

<pre class="sh_javascript_dom">
var mikke = {nimi: "Michael Knight", ika: 17};
console.log(mikke["nimi"]);
</pre>

    <p>Käytännössä oliot JavaScriptissä ovat kokoelmia avain-arvo -pareja. Jokaisella oliolla voi olla omanlaisensa avaimet ja niiden arvot. Kaikki JavaScriptin oliot laajentavat valmista <code>Object</code>-oliota.</p>


    <h4>Omien olioiden tai "luokkien" luonti</h4>

    <p>Omien olioiden luonti tapahtuu funktioiden avulla. Huomaa heti alkuun hyvä nimeämiskäytäntö: funktiot, joita käytetään olioiden luomiseen nimetään isolla alkukirjaimella. Luodaan funktio <code>Opiskelija</code>, jota käytetään opiskelija-olioiden luomiseen (Javalla ohjelmoineet voivat ajatella allaolevaa myös luokkana). Opiskelijalla on kaksi attribuuttia: nimi ja opintopisteet.</p>

<pre class="sh_javascript_dom">
function Opiskelija(nimi) {
    this.nimi = nimi;
    this.opintopisteet = 0;
}
</pre>

    <p>Huomaa ylläolevan määrittelyn määre <code>this</code>. Määreellä <code>this</code> kerrotaan, että käsitellyn muuttujan arvo liittyy juuri tähän olioon. Kun funktio <code>Opiskelija</code> on määritelty, voimme luoda uusia opiskelijaolioita seuraavasti.</p>

<pre class="sh_javascript_dom">
var mikke = new Opiskelija("Michael");
var kasper = new Opiskelija("Casper");
kasper.opintopisteet = 400;

console.log("Nimi " + mikke.nimi + ", noppia: " + mikke.opintopisteet);
console.log("Nimi " + kasper.nimi + ", noppia: " + kasper.opintopisteet);
</pre>

    <p>Ohjelma tuottaa konsoliin seuraavan tekstin</p>

<pre>
Nimi Michael, noppia: 0
Nimi Casper, noppia: 400
</pre>

    <p>Jokaisella funktiolla on prototyyppi, joka sisältää tiedon funktioon liittyvistä attribuuteista. Prototyypin kautta lisättävien funktioiden avulla pääsemme käsiksi olioiden this-viitteeseen, mikä mahdollistaa olion sisäisen tilan muuttamisen.</p>

    <p>Koska attribuutit voivat olla myös funktioita, funktion prototyypille voidaan määritellä uusia metodeja, joilla olion tilaa voidaan muokata. Lisätään funktiolle <code>Opiskelija</code> prototyyppifunktio <code>opiskeleYksin</code>, joka kasvattaa opintopisteiden määrää yhdellä.</p>

<pre class="sh_javascript_dom">
Opiskelija.prototype.opiskeleYksin = function() {
    this.opintopisteet++;
}
</pre>

<pre class="sh_javascript_dom">
var mikke = new Opiskelija("Michael");
var kasper = new Opiskelija("Casper");
kasper.opintopisteet = 400;

mikke.opiskeleYksin();

console.log("Nimi " + mikke.nimi + ", noppia: " + mikke.opintopisteet);
console.log("Nimi " + kasper.nimi + ", noppia: " + kasper.opintopisteet);
</pre>

    <p>Nyt näemme viestit</p>

<pre>
Nimi Michael, noppia: 1
Nimi Casper, noppia: 400
</pre>

    <p>Lisätään funktiolle <code>Opiskelija</code> vielä toinen prototyyppifunktio <code>opiskeleYhdessa</code>, joka saa parametrina toisen opiskelijan. Voimme tarkistaa että parametrina saatu muuttuja on jotain tiettyä tyyppiä <code>instanceof</code>-vertailuoperaatiolla. Viitettä <code>this</code> voi käyttää olioon liittyvien funktioiden kutsumisessa.</p>

<pre class="sh_javascript_dom">
Opiskelija.prototype.opiskeleYhdessa = function(kanssaOpiskelija) {
    if(!(kanssaOpiskelija instanceof Opiskelija)) {
        this.opiskeleYksin();
        return;
    }

    this.opintopisteet += 2;
    kanssaOpiskelija.opintopisteet += 2;
}
</pre>

<pre class="sh_javascript_dom">
var mikke = new Opiskelija("Michael");
var kasper = new Opiskelija("Casper");
kasper.opintopisteet = 400;

mikke.opiskeleYksin();
mikke.opiskeleYhdessa(kasper);

mikke.opiskeleYhdessa("porkkana");

console.log("Nimi " + mikke.nimi + ", noppia: " + mikke.opintopisteet);
console.log("Nimi " + kasper.nimi + ", noppia: " + kasper.opintopisteet);
</pre>

<pre>
Nimi Michael, noppia: 4
Nimi Casper, noppia: 402
</pre>


    <div class="tehtavat">
      <h3>Oliolaskuri</h3>

      <p>Luo tehtäväpohjan mukana tulevalle HTML-sivulle toiminnallisuus, jossa nappia painettaessa sivulla näkyvässä tekstissä olevan numeron arvo kasvaa aina yhdellä. HTML-sivulle saa asettaa vain yhden JavaScript-kutsun, joka tulee <code>body</code>-elementin <code>onload</code>-attribuuttiin.</p>

      <p>Toteuta apuvälineeksi olion luova funktio <code>Laskin</code> jolla on muuttuja <code>luku</code>. Lisää funktiolle <code>Laskin</code> funktiot <code>kasvata</code>, joka kasvattaa olion luvun arvoa yhdellä, ja <code>annaLuku</code>, joka palauttaa olion luvun arvon.</p>

      <p>Varaudu siihen, että napille voidaan asettaa myöhemmin uusia tapahtumankäsittelijöitä.</p>

      <p>Kun sovellus toimii toivotusti, palauta se TMC:lle.</p>

    </div>


    <h4>Esimerkki: Kurssikirjanpito</h4>

    <p>Luodaan Opiskelijan lisäksi vielä funktiot Kurssin ja Kurssisuorituksen luomiseen. Kurssilla on nimi ja opintopistemäärä, kurssisuoritus sisältää viitteen suoritettuun kurssiin ja opiskelijaan sekä suorituspäivämäärän ja arvosanan. Suorituspäivämääränä käytetään suoritusolion luontipäivämäärää.</p>

<pre class="sh_javascript_dom">
function Kurssi(nimi, opintopisteet) {
    this.nimi = nimi;
    this.opintopisteet = opintopisteet;
}

function Kurssisuoritus(opiskelija, kurssi, arvosana) {
    this.opiskelija = opiskelija;
    this.kurssi = kurssi;
    this.arvosana = arvosana;
    this.paivamaara = new Date();
}
</pre>

    <p>Näiden lisäksi käytössämme on Kirjanpito, johon voi lisätä opiskelijoiden suorituksia. Kirjanpito tarjoaa nopean pääsyn kurssiin liittyviin suorituksiin ja opiskelijan suorituksiin. Alla oletetaan, että kurssien ja opiskelijoiden nimet ovat yksikäsitteiset.</p>

<pre class="sh_javascript_dom">
function Kirjanpito() {
    // kaikki suoritukset
    this.kurssisuoritukset = new Array();

    // opiskelijakohtaiset suoritukset
    this.opiskelijanSuoritukset = {};

    // kurssikohtaiset suoritukset
    this.kurssinSuoritukset = {};
}

Kirjanpito.prototype.lisaaSuoritus = function(kurssi, opiskelija, arvosana) {
    var suoritus = new Kurssisuoritus(opiskelija, kurssi, arvosana);

    // metodilla push lisätään listaan
    this.kurssisuoritukset.push(suoritus);

    // erilliset metodit opiskelijakohtaisten ja kurssikohtaisten suoritusten
    // lisäämiseen
    this.lisaaOpiskelijanSuoritus(opiskelija.nimi, suoritus);
    this.lisaaKurssinSuoritus(kurssi.nimi, suoritus);
}

Kirjanpito.prototype.lisaaOpiskelijanSuoritus = function(opiskelijanNimi, suoritus) {
    // jos opiskelijan nimellä ei ole yhtäkään suoritusta, on nimellä
    // saatava arvo false -- luodaan tällöin lista suorituksille
    if(!this.opiskelijanSuoritukset[opiskelijanNimi]) {
        this.opiskelijanSuoritukset[opiskelijanNimi] = new Array();
    }

    this.opiskelijanSuoritukset[opiskelijanNimi].push(suoritus);
}

Kirjanpito.prototype.lisaaKurssinSuoritus = function(kurssinNimi, suoritus) {
    if(!this.kurssinSuoritukset[kurssinNimi]) {
        this.kurssinSuoritukset[kurssinNimi] = new Array();
    }

    this.kurssinSuoritukset[kurssinNimi].push(suoritus);
}

Kirjanpito.prototype.haeOpiskelijanKurssisuoritukset = function(opiskelijanNimi) {
    return this.opiskelijanSuoritukset[opiskelijanNimi];
}

Kirjanpito.prototype.haeKurssinSuoritukset = function(kurssinNimi) {
    return this.kurssinSuoritukset[kurssinNimi];
}

Kirjanpito.prototype.haeKaikkiSuoritukset = function() {
    return this.kurssisuoritukset;
}
</pre>


    <p>Kirjanpidon käyttäminen on helpohkoa. Alla olevassa esimerkissä luodaan kurssi, opiskelija ja kirjanpito-olio, sekä lisätään suoritus kirjanpitoon. Tämän jälkeen kaikki suoritukset lisätään dokumentissa olevaan "data"-tunnuksella merkittyyn elementtiin. Käytössämme on myös apufunktio <code>lisaaSuoritusteksti</code>, joka lisää annettuun elementtiin tekstielementin, jossa on suorituksen tiedot.</p>

<pre class="sh_javascript_dom">
function lisaaSuoritusteksti(elementti, suoritus) {
   var teksti = suoritus.kurssi.nimi + " " + suoritus.opiskelija.nimi + " " + suoritus.arvosana;
   elementti.appendChild(document.createTextNode(teksti));
}

var weso = new Kurssi("Web-selainohjelmointi");
var mikke = new Opiskelija("Michael");
var kirjanpito = new Kirjanpito();

kirjanpito.lisaaSuoritus(weso, mikke, 1);

var suoritukset = kirjanpito.haeKaikkiSuoritukset();
var data = document.getElementById("data");

for(var i = 0; i < suoritukset.length; i++) {
    var elementti = document.createElement("p");

    lisaaSuoritusteksti(elementti, suoritukset[i]);
    data.appendChild(elementti);
}
</pre>

    <p>Ylläolevaa sovellusta voisi käyttää hyvin myös käyttöliittymästä. Käytännössä tällöin HTML-dokumenttiin luotaisi lomake, jonka kautta kurssisuorituksia lisättäisiin. Näiden lisäksi todennäköisesti käytössä olisi omat lomakkeet kurssien ja opiskelijoiden lisäämiselle, jolloin kurssin ja opiskelijan voisi hakea kätevästi listasta.</p>

    <div class="tehtavat">

      <h3>Tavara, Matkalaukku, Ruuma</h3>

      <p>Jokaisella tavaralla on nimi ja paino. Matkalaukkuun lisätään tavaroita, ja matkalaukulla on maksimipaino. Ruumaan taas lisätään matkalaukkuja, ja myös ruumalla on maksimipaino. Matkalaukkuun voi lisätä vain tavaroita, ja ruumaan vain matkalaukkuja. Jos matkalaukun ja uuden tavaran yhteispaino on suurempi kuin matkalaukun maksimipaino, ei tavaraa voida lisätä. Vastaavasti ruumalle.</p>

      <p>Toteuta olioita luovat funktiot <code>Tavara</code>, <code>Matkalaukku</code>, ja <code>Ruuma</code> lähdekooditiedostoon <code>code.js</code>. Voit käyttää alla olevaa (ja tehtäväpohjassa tulevaa) testikoodia toteutustesi testaamiseen.</p>

<pre class="sh_javascript_dom">
var kivi = new Tavara("kivi", 3);
var kirja = new Tavara("kirja", 7);
var pumpuli = new Tavara("pumpuli", 0.001);

var laukku = new Matkalaukku(10);
var vuitton = new Matkalaukku(3);

var schenker = new Ruuma(15);


laukku.lisaa(kivi);
console.log("laukun paino, pitäisi olla 3: " + laukku.paino());
laukku.lisaa(kivi); // virhe: "Tavara lisätty jo, ei onnistu!"

laukku.lisaa(kirja);
console.log("laukun paino, pitäisi olla 10: " + laukku.paino());

laukku.lisaa(pumpuli); // virhe: "Liian painava, ei pysty!"

console.log("laukun paino, pitäisi olla 10: " + laukku.paino());


schenker.lisaa(laukku);
schenker.lisaa(pumpuli); // virhe: Vääränlainen esine, ei onnistu!

console.log("Ruuman paino, pitäisi olla 10: " + schenker.paino());

vuitton.lisaa(pumpuli);
schenker.lisaa(vuitton);
console.log("Ruuman paino, pitäisi olla noin 10.001: " + schenker.paino());

pumpuli.paino = 300;
console.log("Ruuman paino, pitäisi olla 310: " + schenker.paino()); // hups!</pre>

      <p>Palauta tehtävä TMC:lle kun se toimii toivotusti.</p>

    </div>



    <h3>Moduulit</h3>


    <p>Kun tutkimme edellistä esimerkkiä tarkemmin, huomaamme että prototyyppien avulla määritelty oliotoiminnallisuus ei kapseloi olioiden muuttujia, vaan niihin pääsee käsiksi suoraan. Attribuuttien kapseloinnista on kuitenkin monia hyötyjä, joista tärkein lienee se, että olion sisäistä rakennetta voidaan muuttaa ilman että sitä käyttäviä sovelluksia tarvitsee muuttaa.</p>

    <p>Ylläolevaa kirjanpitoa käyttävä ohjelmoija voisi epähuomiossa lisätä uusia kurssisuorituksia esimerkiksi suoraan kirjanpidon sisäiseen muuttujaan <code>kurssisuoritukset</code>, jolloin opiskelijakohtaisia suoritustietoja ei löytyisi nykyisellä toteutuksella.</p>

<pre class="sh_javascript_dom">
var weso = new Kurssi("Web-selainohjelmointi");
var mikke = new Opiskelija("Michael");
var kirjanpito = new Kirjanpito();

kirjanpito.kurssisuoritukset.push(new Kurssisuoritus(weso, mikke, 1));
</pre>

    <p>Kun ohjelmoijat käyttävät Kirjanpito-funktion määrittelemää ohjelmointirajapintaa, eli sen funktioita, on ohjelman laajentaminen helpompaa. Tällöin ei tarvitse huolehtia siitä, että esimerkiksi suorituspäivämäärän perusteella tapahtuva haku olisi rikki jo alusta lähtien koska joku käyttää valmista koodia väärin.</p>

    <p>Eräs tapa tiedon kapselointiin on Module Pattern-suunnittelumallia. Ennen siihen tutustumista, tutustutaan kuitenkin anonyymeihin funktioihin ja sulkeumiin (<em>Closure</em>).</p>


    <h4>Anonyymit funktiot</h4>


    <p>Anonyymit funktiot ovat funktioita, joita ei kiinnitetä muuttujiin, jolloin ne eivät saa nimeä. Esimerkiksi seuraavassa ohjelmassa käytetään anonyymiä funktiota lukuvälin lukujen summan laskemiseen. Mielenkiintoista alla olevassa koodissa on se, että funktio on olemassa vain sen suorituksen ajan.</p>


<pre class="sh_javascript_dom">
var lopputulos = (function(alku, loppu) {
                      var summa = 0;
                      for (var i = alku; i < loppu; i++) {
                          summa += i;
                      }
                      return summa;
                  })(1, 3);

console.log(lopputulos); // 3
</pre>


    <h4>Sulkeumat</h4>


    <p>Sulkeumat ovat yleisesti ottaen lauseita, jotka voivat sisältää muuttujia, mutta jotka piilottavat muuttujat sisäänsä. Käytännössä sulkeumia luodaan luomalla funktioita funktion sisään, jolloin ulompi funktio kapseloi sisältönsä. Tutustutaan sulkeumiin hieman tarkemmin.</p>

    <p>Olemme aiemmin huomanneet, että funktioiden sisällä määritellyt <code>var</code> -muuttujat eivät näy koko ohjelmalle, vaan ne ovat näkyvillä vain sen funktion sisällä, jossa ne on määritelty. Esimerkiksi seuraavassa funktiossa <code>rajoitettuSumma</code> funktio sisältää muuttujan <code>summa</code>, jota ei näy funktion ulkopuolelle. Kun funktio palauttaa arvon, se palauttaa kopion <code>summa</code>-muuttujan sisällöstä.</p>

<pre class="sh_javascript_dom">
function rajoitettuSumma(alku, loppu) {
    var summa = 0;
    for (var i = alku; i < loppu; i++) {
        summa += i;
    }

    return summa;
}
</pre>

<pre class="sh_javascript_dom">
var tulos = rajoitettuSumma(1, 2);
console.log(tulos); // 1
</pre>

    <p>Koska JavaScriptissä muuttujat voivat olla funktioita, voimme palauttaa funktiosta toisen funktion.</p>

<pre class="sh_javascript_dom">
function pankki() {
    return function(alku, loppu) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        return summa;
    }
}
</pre>

    <p>Kun käyttäjä kutsuu ylläolevaa funktiota, palauttaa funktio toisen funktion. Palautettu funktio toteuttaa aiemmin näkemämme funktion <code>rajoitettuSumma</code> toiminnallisuuden.</p>

<pre class="sh_javascript_dom">
var funktio = pankki();
console.log(funktio(1, 2)); // 1
</pre>

    <p>Oikeastaan, funktion <code>pankki</code> sisälle voi luoda muuttujan <code>rajoitettuSumma</code>, jonka voimme palauttaa.</p>

<pre class="sh_javascript_dom">
function pankki() {

    var rajoitettuSumma = function(alku, loppu) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        return summa;
    };

    return rajoitettuSumma;
}
</pre>

    <p>Yllä oleva toiminnallisuus vastaa aiempaa funktiota. Muutetaan funktion <code>rajoitettuSumma</code> toimintaa siten, että muuttuja <code>loppu</code> määritellään funktion <code>pankki</code> sisällä paikalliseksi muuttujaksi.</p>

<pre class="sh_javascript_dom">
function pankki() {
    var loppu = 2;

    var rajoitettuSumma = function(alku) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        return summa;
    };

    return rajoitettuSumma;
}
</pre>

    <p>Koska JavaScriptissä on funktionäkyvyys, näkyy muuttuja <code>loppu</code> funktion <code>pankki</code> sisällä olevalle funktiolle. Funktiossa <code>rajoitettuSumma</code> voidaan muuttaa muuttujan <code>loppu</code> arvoa -- itseasiassa muuttuja loppu on olemassa useamman <code>rajoitettuSumma</code>-funktiokutsun ajan.</p>

<pre class="sh_javascript_dom">
function pankki() {
    var loppu = 2;

    var rajoitettuSumma = function(alku) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        loppu++;
        return summa;
    };

    return rajoitettuSumma;
}
</pre>

<pre class="sh_javascript_dom">
var funktio = pankki();
console.log(funktio(1)); // tulostaa 1
console.log(funktio(1)); // tulostaa 3
console.log(funktio(1)); // tulostaa 6
console.log(funktio(1)); // tulostaa 10
</pre>

    <p>Voimme palauttaa pankista olion. Alla olevassa esimerkissä palautamme olion, jonka attribuutti <code>alhaaltaRajoitettuSumma</code> käyttää funktiota <code>rajoitettuSumma</code>.</p>

<pre class="sh_javascript_dom">
function pankki() {
    var loppu = 2;

    var rajoitettuSumma = function(alku) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        loppu++;
        return summa;
    };

    return {
        alhaaltaRajoitettuSumma: rajoitettuSumma
    };
}
</pre>

    <p>Nyt funktio <code>pankki</code> palauttaa olion, jolla on attribuutti <code>alhaaltaRajoitettuSumma</code>. Attribuuttiin pääsee käsiksi aivan kuten olioiden attribuutteihin normaalistikin.</p>


<pre class="sh_javascript_dom">
var funktio = pankki();
console.log(funktio.alhaaltaRajoitettuSumma(1)); // tulostaa 1
console.log(funktio.alhaaltaRajoitettuSumma(1)); // tulostaa 3
console.log(funktio.alhaaltaRajoitettuSumma(1)); // tulostaa 6
console.log(funktio.alhaaltaRajoitettuSumma(1)); // tulostaa 10

// MUTTA!
console.log(funktio.rajoitettuSumma(1)); // ei onnistu!
</pre>

    <p>Funktioon <code>rajoitettuSumma</code> ei kuitenkaan pääse suoraan käsiksi!</p>

    <p>Luodaan pankille vielä toinen funktio, joka asettaa muuttujan <code>loppu</code> arvon.</p>

<pre class="sh_javascript_dom">
function pankki() {
    var loppu = 2;

    var rajoitettuSumma = function(alku) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        loppu++;
        return summa;
    };

    var asetaLoppu = function(uusiLoppu) {
        loppu = uusiLoppu;
    }

    return {
        alhaaltaRajoitettuSumma: rajoitettuSumma,
        asetaLoppu: asetaLoppu
    };
}
</pre>

<pre class="sh_javascript_dom">
var funktio = pankki();
console.log(funktio.alhaaltaRajoitettuSumma(1)); // tulostaa 1

funktio.asetaLoppu(4);
console.log(funktio.alhaaltaRajoitettuSumma(1)); // tulostaa 10
</pre>

    <p>Yllä olevat funktiot voidaan kirjoittaa myös siten, että niille määritellään nimi osana funktiomäärittelyä. Tällöin erilliselle muuttujalle ei ole tarvetta.</p>

<pre class="sh_javascript_dom">
function pankki() {
    var loppu = 2;

    function rajoitettuSumma(alku) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        loppu++;
        return summa;
    };

    function asetaLoppu(uusiLoppu) {
        loppu = uusiLoppu;
    }

    return {
        alhaaltaRajoitettuSumma: rajoitettuSumma,
        asetaLoppu: asetaLoppu
    };
}
</pre>



<aside class="pohdi">
  <p><strong>So Not?</strong></p>

  <p>Tutustu myös Mozillan artikkeliin <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank">teemasta</a>.</p>

  <p>Mitä hyötyä edellä esitetystä tekniikasta on käytännössä?</p>
</aside>



    <h4>Moduulit</h4>

    <p><a href="http://en.wikipedia.org/wiki/Module_pattern" target="_blank">Module Pattern</a> hyödyntää sekä anonyymejä funktioita että sulkeumia sovelluksen toimintalogiikan kapselointiin. Ajatuksena on luoda ensin nimiavaruudessa käytettävä muuttuja, jonka kautta sovelluksen eri osia käytetään. Luodaan olio <code>hallinta</code>, johon lisätään kirjanpitotoiminnallisuus.</p>

<pre class="sh_javascript_dom">
// huom! luodaan tyhjä olio, jolle voi lisätä attribuutteja
var hallinta = {};

hallinta.kirjanpito = (function() {
    var kurssisuoritukset = new Array();
    var opiskelijanSuoritukset = {};
    var kurssinSuoritukset = {};

    function lisaaSuoritus(kurssi, opiskelija, arvosana) {
        var suoritus = new Kurssisuoritus(opiskelija, kurssi, arvosana);

        // metodilla push lisätään listaan
        kurssisuoritukset.push(suoritus);

        // erilliset metodit opiskelijakohtaisten ja kurssikohtaisten suoritusten
        // lisäämiseen
        lisaaOpiskelijanSuoritus(opiskelija.nimi, suoritus);
        lisaaKurssinSuoritus(kurssi.nimi, suoritus);
    }

    function haeOpiskelijanKurssisuoritukset(opiskelijanNimi) {
        return opiskelijanSuoritukset[opiskelijanNimi];
    }

    function haeKurssinSuoritukset(kurssinNimi) {
        return kurssinSuoritukset[kurssinNimi];
    }

    function haeKaikkiSuoritukset() {
        return kurssisuoritukset;
    }

    // apufunktiot
    function lisaaOpiskelijanSuoritus(opiskelijanNimi, suoritus) {
        // jos opiskelijan nimellä ei ole yhtäkään suoritusta, on nimellä
        // saatava arvo false -- luodaan tällöin lista suorituksille
        if(!opiskelijanSuoritukset[opiskelijanNimi]) {
            opiskelijanSuoritukset[opiskelijanNimi] = new Array();
        }

        opiskelijanSuoritukset[opiskelijanNimi].push(suoritus);
    }

    function lisaaKurssinSuoritus(kurssinNimi, suoritus) {
        if(!kurssinSuoritukset[kurssinNimi]) {
            kurssinSuoritukset[kurssinNimi] = new Array();
        }

        kurssinSuoritukset[kurssinNimi].push(suoritus);
    }

    // julkaistava rajapinta
    return {
        lisaaSuoritus: lisaaSuoritus,
        haeOpiskelijanSuoritukset: haeOpiskelijanKurssisuoritukset,
        haeKurssinSuoritukset: haeKurssinSuoritukset,
        haeKaikkiSuoritukset: haeKaikkiSuoritukset
    };
})();
</pre>

    <p>Yllä oleva moduuli kapseloi kurssihallinnan siten, että hallinnan kapseloimiin tietueisiin ei pääse käsiksi. Voimme jatkossa käyttää kirjanpito-ohjelmaa seuraavasti:</p>

<pre class="sh_javascript_dom">
var weso = new Kurssi("Web-selainohjelmointi");
var mikke = new Opiskelija("Michael");

// EI ONNISTU!
// hallinta.kirjanpito.kurssisuoritukset.push(new Kurssisuoritus(weso, mikke, 1));

// ONNISTUU!
hallinta.kirjanpito.lisaaSuoritus(weso, mikke, 1);
</pre>

<aside class="pohdi">
  <p><strong>Module Pattern ja Oliot</strong></p>

  <p>Miten module pattern liittyy olioihin? Voiko module patternia käytettäessä samasta moduulista luoda useampia olioita?</p>

</aside>

    <div class="tehtavat">
      <h3>Kapseloitu laskuri</h3>

      <p>Toteuta tehtäväpohjaan laskin aiemmin esitellyllä Module Patternilla. Laskimen tulee kapseloida muuttuja <code>luku</code> ja tarjoata funktiot <code>kasvata</code>, joka kasvattaa luvun arvoa yhdellä, ja <code>annaLuku</code>, joka palauttaa luvun. Luo laskin tehtäväpohjassa esiteltyyn muuttujaan <code>var laskin;</code>.</p>

      <p>Huom! Laskimen sisäiseen rakenteeseen ei tule voida vaikuttaa muuten kuin funktioiden <code>kasvata</code> ja <code>annaLuku</code> kautta.</p>

      <p>Palauta sovelluksesi TMC:lle kun se toimii toivotusti.</p>


      <h3>Henkilolista</h3>

      <p>Tehtäväpohjaan on hahmoteltu henkilöiden hallintaan sopivan sovelluksen rakennetta. Tehtäväsi on jatkaa sitä eteenpäin siten, että henkilöiden lisääminen sovellukseen onnistuu.</p>

      <img src="img/personmanager.png" border=1/>

      <p>Tehtävänäsi on toteuttaa:</p>

      <ol>
    <li>Lomakkeen napin käsittelytoiminnallisuus (manager.gui.buttonPressed())</li>
    <li>Henkilön lisääminen (manager.data.addPerson(person))</li>
    <li>Henkilöiden listaaminen (manager.data.list())</li>
      </ol>

      <p>Sekä lisätä manager.data-moduuliin funktioiden sopiva näkyvyys. Tehtäväpohjassa on lisää ohjeita.</p>

      <p>Huom! Älä poikkea jo hahmotellusta module pattern-suunnittelumallia seuraavasta rakenteesta. Ainoa <code>manager</code>-nimialueen ulkopuolella oleva funktiokutsu on sovellukseen jo määritelty <code>init</code>.</p>

      <p>Kun sovelluksesi toimii palauta se TMC:lle.</p>

    </div>



    <h2>Keskustelu palvelimen kanssa</h2>


    <p>Selaimessa toimivia ohjelmistoja rakennettaessa yhdeksi kysymykseksi tulee sovelluksen käyttämän datan säilöminen. Jotta sovelluksen sisältämä tieto olisi kaikkien käyttäjien saatavilla, tulee se tallentaa erilliselle palvelimelle, jonne kaikilla on pääsy. Palvelinohjelmistojen suunnittelu ja toteuttaminen on hyvin laaja alue, jota esimerkiksi kurssi Web-palvelinohjelmointi raapaisee. Kurssin materiaali löytyy osoitteesta <a href="https://wepa-2014.herokuapp.com/material/public_html/index.html" target="_blank">https://wepa-2014.herokuapp.com/material/public_html/index.html</a>.</p>

    <p>Käytännössä keskustelu palvelimen kanssa tapahtuu HTTP-protokollaa käyttäen. HTTP-protokolla on tekstimuotoinen protokolla, joka sisältää pyyntötyyppejä erilaisten pyyntöjen tekemiseen. Pyyntötyypillä GET haetaan dataa, POST lähetetään dataa palvelimelle, ja DELETE poistetaan dataa. Selaimet tarjoavat abstraktiokerroksen HTTP-protokollan päälle -- itseasiassa kun selaimessa haetaan web-sivua jostain osoitteesta, esimerkiksi osoitteesta <code>http://www.cs.helsinki.fi/group/java/s12-wepa/</code>, selain tekee HTTP-pyynnön osoitteessa <code>www.cs.helsinki.fi</code> -olevalle palvelimelle, ja pyytää sieltä polussa <code>/group/java/s12-wepa/</code> olevaa resurssia.</p>

    <p>Selainohjelmistoja rakennettaessa palvelimelta voidaan pyytää kokonaista HTML-dokumenttia, tai pienempää datamäärää. Nykyään uusissa sovelluksissa suosituin datan siirtoformaatti on JSON.</p>

    <h3>JSON</h3>

    <p><a href="http://www.json.org/" target="_blank">JSON</a> (<em>JavaScript Object Notation</em>) on JavaScriptin käyttämä tiedonsiirtoformaatti, jonka suosio perustuu helppoon JavaScript-olioiksi muuttamiseen. Olemme aiemmin luoneet JavaScript-olioita seuraavanlaisella notaatiolla.</p>

<pre class="sh_javascript_dom">
var mikke = {nimi: "Mikke", syntymavuosi: 1984};
</pre>

    <p>JSON-formaatti on hyvin samannäköinen. JSON-muodossa data kuvataan merkkijonoina. Luodaan ylläolevaa oliota kuvaava JSON-merkkijono <code>mikkeData</code>. Huomaa kahden erilaisen hipsun käyttö!</p>

<pre class="sh_javascript_dom">
var mikkeData = '{"nimi": "Mikke", "syntymavuosi": 1984}';
</pre>


    <p>Nyt käytössämme on merkkijono, jonka sisältö näyttää lähes samalta kuin aiemmin olion luontiin käyttämämme notaatio. Miten tästä saa olion?</p>

    <p>JavaScript tarjoaa toiminnallisuuden merkkijonon JavaScript-olioksi ja takaisin muuttamiseen. Funktio <code>JSON.parse</code> muuttaa parametrina annetun merkkijonon JavaScript-olioksi, ja funktio <code>JSON.stringify</code> muuttaa parametrina annetun JavaScript olion merkkijonoksi.</p>

<pre class="sh_javascript_dom">
var mikkeData = '{"nimi": "Mikke", "syntymavuosi": 1984}';
var mikke = JSON.parse(mikkeData);
console.log(mikke.nimi);

var mikkeKlooni = JSON.stringify(mikke);
console.log(mikkeKlooni);
</pre>

    <div class="test-js">
      <p><textarea id="js-json-muunnos" rows="7" cols="80">var mikkeData = '{"nimi": "Mikke", "syntymavuosi": 1984}';
var mikke = JSON.parse(mikkeData);
console.log(mikke.nimi);

var mikkeKlooni = JSON.stringify(mikke);
console.log(mikkeKlooni);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-json-muunnos')" value="Suorita koodi!"></input></p>
    </div>

    <p>Helppoa kuin heinänteko.</p>



    <h3>Datan hakeminen palvelimelta</h3>


    <p>Datan noutamiseen palvelimelta käytetään muutamaa erillistä lähestymistapaa. Suurin osa selaimista tukee <a href="http://www.w3.org/TR/XMLHttpRequest/" target="_blank">XMLHttpRequest</a>-oliota, jonka avulla voidaan luoda pyyntöjä palvelimelle. Käytännössä pyynnön lähettäminen ja käsittely tapahtuu kolmessa vaiheessa. Ensin luodaan XMLHttpRequest-olio, sitten määritellään oliolle vastauksen käsittelevä funktio, ja lopuksi lähetetään pyyntö.</p>

<pre class="sh_javascript_dom">
// pyyntöolion luonti
var req = new XMLHttpRequest();

// mitä tehdään kun saadaan vastaus (vastauksia voi olla useita)
req.onreadystatechange = function() {
    // jos tila ei ole valmis, ei käsitellä
    if (req.readyState !== this.DONE) {
        console.log("state " + req.readyState);
        return false;
    }

    // jos statuskoodi ei ole 200 (ok), ei käsitellä
    if (req.status !== 200) {
        console.log("status " + req.status);
        return false;
    }

    // näytetään vastaus
    console.log(req.responseText);
}

req.open("GET", "data.json", true);
req.send();
</pre>

    <p>Tutkitaan yllä olevaa koodia hieman tarkemmin. Palvelin voi palauttaa XMLHttpRequest-pyyntöön useamman vastauksen. Attribuutti <code>readyState</code> sisältää arvon väliltä [0, 4], missä 4 tarkoittaa pyynnön olevan valmis. Numeroarvoja vastaavat vakiot (pienimmästä suurimpaan) <code>UNSENT</code>, <code>OPENED</code>, <code>HEADERS_RECEIVED</code>, <code>LOADING</code> sekä <code>DONE</code> joihin päästään käsiksi <code>this</code>:n kautta. Jos attribuutin <code>readyState</code> arvo ei ole neljä (<code>DONE</code>), odotamme lopullista vastausta. Attribuutti <code>status</code> kertoo HTTP-pyynnön statuskoodin. Statuskoodi 200 kertoo pyynnön onnistuneen. Lisää tietoa statuskoodeista löytyy esimerkiksi googlella ja <a href="https://http.cat" target="_blank">täältä</a>.</p>

    <p>Ylläolevassa esimerkiksi vastaus näytetään <code>console.log</code>-komennon avulla. Käytännössä JSON-dataa sisältävän vastauksen voisi muuttaa <code>JSON.parse</code>-funktiolla olioksi.</p>

    <p>Tärkeä osa liittyy pyynnön avaamiseen. Komento <code>req.open("GET", "data.json", true);</code> avaa GET-tyyppisen HTTP-yhteyden <em>nykyiseen sivustoon</em> liittyvään osoitteeseen <code>data.json</code>. Koska viimeinen parametri on <code>true</code>, on pyyntötyyppi asynkroninen, eikä selain jää odottamaan vastausta. Vastaukseen reagoidaan kun vastaus saapuu. Asynkronisuuden määrittävä boolenia ei kuitenkaan vaadita ja pyyntö on oletusarvoisesti asynkroninen jollei toisin määritetä. Täten parametri täytyy erikseen asettaa vain jos sen arvoksi haluaa <code>false</code>.</p>


    <div class="test-js">
      <p><textarea id="js-xmlhttpreq-haku" rows="9" cols="80">var req = new XMLHttpRequest();

req.onreadystatechange = function() {
    console.log(req.readyState + ", " + req.status + ", " + req.responseText);
}

req.open("GET", "data.json");
req.send();
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-xmlhttpreq-haku')" value="Suorita koodi!"></input></p>
    </div>

    <p>Kun kokeilet ylläolevaa koodia eri osoitteilla, huomaat että datan hakeminen ei aina onnistu. XMLHttpRequest-pyyntöihin liittyy tietoturvarajoitteita, jotka oletuksena rajoittavat pyynnön tekemisen samaan osoitteeseen.</p>


    <h4>Pyyntöjen tekeminen oman palvelimen ulkopuolelle</h4>

    <p>Pyyntöjen tekemistä eri osoitteisiin rajoittaa ns. "Same origin policy", jolla pyritään rajoittamaan muunmuassa pyynnön mukana lähetettävän datan (evästeet, kirjautumistiedot ym.) päätymistä vääriin käsiin. Sivustot, jotka koostavat useampia palveluita yhteen kuitenkin tarvitsevat pääsyn ulkopuoliseen dataan.</p>

    <p>W3C työskentelee <a href="http://www.w3.org/TR/cors/" target="_blank">CORS</a> (<em>Cross-origin resource sharing</em>)-spesifikaation kanssa parhaillaan. CORS-spesifikaation tavoitteena on määritellä tuki domain-riippumattomalle resurssien jakamiselle. Käytännössä tuki vaatii sen, että palvelinohjelmiston vastauksessa on otsakkeet, jotka kertovat osoitteet, joissa haettua dataa voi käyttää.</p>

    <p>Rajoituksen kiertämiseen on kehitetty useita tekniikoita, mm. proxy-mekanismi, iframe-elementtien kanssa toimiminen, ja JSONP. Proxy-mekanismissa paikalliselle palvelimelle luodaan skripti, joka hakee kolmannen osapuolen datan paikalliselle palvelimelle, jolloin selaimen näkökulmasta data on paikallista. IFrame-elementtiä käytettäessä taas sivu haetaan erilliseen iframe-elementtiin, josta haetaan tarvitut osat.</p>

<div class="extra">
  <p><strong>Pyyntöjen tekeminen omalle koneelle</strong></p>

  <p>Osa selaimista kieltää pyyntöjen tekemisen suoraan tiedostojärjestelmään. Voit kiertää tämän esimerkiksi chromessa käynnistämällä chromen parametrilla "--disable-web-security".</p>
</div>


    <div class="tehtavat">
      <h3>Chuckles</h3>

      <p>Tutustu <a href="http://www.icndb.com/" target="_blank">ICNDb.com</a>-osoitteessa olevaan <a href="http://www.icndb.com/api/" target="_blank">JSON-apiin</a> ja toteuta toiminnallisuus, jonka avulla voit hakea satunnaisia viestejä.</p>

      <p>Käytä osoitetta <code>http://api.icndb.com/jokes/random/3</code> testaamiseen.</p>

      <p>Yllä olevalla osoitteella sivun tulee näyttää esimerkiksi seuraavalta.</p>

      <img src="img/chuckles.png" border=1 />

      <p>Kun sovelluksesi toimii, ja näet viestit <code>index.html</code>-sivulla, palauta se TMC:lle.</p>

    </div>


    <h4>JSONP</h4>

    <p>JSONP (<em>JSON with padding</em>) hyödyntää tietoa siitä, että <code>script</code>-elementin osoite, eli paikka josta JavaScript-lähdekoodi haetaan, ei ole rajoitettu. Data haetaan asettamalla JavaScriptillä luotavalle <code>script</code>-elementille <code>src</code>-attribuutti, johon asetetaan JSONP-muotoista dataa tarjoavan palvelimen osoite.</p>

    <p>Dataa haettaessa pyynnölle annetaan parametrina funktion nimi, jonka nimisellä funktiolla data tulee kapseloida palvelinpäässä. Esimerkiksi, jos pyyntö tehdään osoitteeseen <code><em>palvelin</em>/data.jsonp?callback=handleResponse</code>, on vastauksessa tulevan datan oltava muotoa <code>handleResponse(<em>data</em>)</code>. Funktio <code>handleResponse</code> on määritelty osana dataa hakevaa sivua.</p>

<pre class="sh_javascript_dom">
// aiemmin määritelty funktio handleResponse
function handleResponse(content) {
    console.log(content);
}
</pre>



<pre class="sh_javascript_dom">
// dataa haettaessa tehtävä kutsu. Haetaan tietyssä osoitteessa olevasta palvelusta
// jsonp-muotoista dataa.
var script = document.createElement("script");
script.setAttribute("src", "<em>osoite</em>/data.jsonp?callback=handleResponse");
document.body.appendChild(script);
</pre>

    <p>Sivu voi palauttaa esimerkiksi seuraavanlaisen vastauksen vastauksen.</p>

<pre>
handleResponse({"nimi":"mikke", "ika":17})
</pre>

<script>
function handleResponse(data) {
    console.log(data);
}
</script>

    <div class="test-js">
      <p><textarea id="js-jsonp-haku" rows="4" cols="80">var script = document.createElement("script");
script.setAttribute("src", "data.jsonp?callback=handleResponse");
document.body.appendChild(script);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-jsonp-haku')" value="Suorita koodi!"></input></p>
    </div>



    <h3>Datan lähettäminen palvelimelle</h3>

    <p>Datan lähettämiseen liittyy samat haasteet kuin datan vastaanottamiseen. Yksinkertaisin tapa lähettää tietoa palvelimelle on XMLHttpRequest-olion GET-pyyntö siten, että lähetettävä data asetetaan mukaan pyynnön osoitteeseen. Käytännössä parametrina oleva data käsitellään palvelinpuolella pyyntöä kuuntelevassa ohjelmistossa.</p>

<pre class="sh_javascript_dom">
// pyyntöolion luonti
var req = new XMLHttpRequest();
var parametrit = "nimi=mikke&ika=17";
req.open("GET", "dataprocessor.html?" + parametrit);
req.send();
</pre>

    <p>GET-pyyntö on hieman huono siinä mielessä, että lähetettävä data näkyy kaikkialle. Esimerkiksi jos pyyntö kulkee useamman reitittimen läpi ennen pääsyä palvelimelle, jokainen reititin näkee parametrit. Toinen vaihtoehto on POST-pyyntö, jossa data lähetetään osana pyynnön runkoa. Tällöin pyynnölle tulee myös määritellä lähetettävän datan muoto. Allaolevassa esimerkissä sanomme datan olevan lomakkeelta.</p>

<pre class="sh_javascript_dom">
var req = new XMLHttpRequest();
var data = "nimi=mikke&ika=17";
req.open("POST", "dataprocessor.html");

req.setRequestHeader("Content-Type","application/x-www-form-urlencoded");

req.send(data);
</pre>

    <p>JSON-muotoisen datan lähettäminen osana POST-pyyntöä onnistuu vastaavasti.</p>

<pre class="sh_javascript_dom">
var mikke = {nimi: "Michael", ika: 17};
var data = JSON.stringify(mikke);

var req = new XMLHttpRequest();
req.open("POST", "jsonprocessor.html");

req.setRequestHeader("Content-Type","application/json");

req.send(data);
</pre>

    <div class="tehtavat">
      <h3>Submission</h3>

      <p>Toteuta tehtäväpohjassa olevaan lähdekooditiedostoon <code>submission.io</code>-moduuli, jolla on kaikille näkyvä funktio <code>send</code>. Funktio <code>send</code> saa parametrina JavaScript-olion, joka tulee lähettää palvelimelle JSON-muodossa.</p>

      <p>Lähetä data osoitteeseen <code>http://bad.herokuapp.com/app/in</code>. Voit tarkistaa menikö data perille osoitteessa <code>http://bad.herokuapp.com/app/out</code>. Ennenkuin aloitat, kannattaa vierailla sivulla <a href="http://bad.herokuapp.com/" target="_blank">http://bad.herokuapp.com/</a> niin varmistat että sovellus on päällä.</p>

      <p>Kun sovelluksesi lähettää dataa palvelimelle, ja näet lähetetyn datan palvelimella, palauta tehtävä TMC:lle. Jos data menee palvelimelle, ja näet virheen "XMLHttpRequest cannot load http://bad.herokuapp.com/app/in. Origin null is not allowed by Access-Control-Allow-Origin." -- älä välitä siitä. Sovellus herokussa ei ole konfiguroitu täysin oikein.</p>


      <h3>Chat-chat (4p)</h3>

      <p>Tämä on avoin tehtävä, jonka tekemisestä saa 4 pistettä. Kannattaa varata tehtävän tekemiseen reilusti aikaa -- voit mahdollisesti myös tehdä tätä tehtävää ennen seuraavan tehtävän.</p>

      <p>Osoitteessa <a href="http://bad.herokuapp.com/app/" target="_blank">http://bad.herokuapp.com/app/</a> toimii chat-sovelluksen backend-toiminnallisuus. Tässä tehtävässä rakennetaan chatille selainpuolen toiminnallisuus.</p>

      <h4>Sisäänkirjautuminen</h4>

      <p>Kun käyttäjä avaa chat-sivun, näytetään hänelle login-näkymä, joka näyttää seuraavalta.</p>

      <p><img src="img/chat-login.png" border="1" /></p>

      <p>Kun käyttäjä kirjoittaa käyttäjätunnuksen ja painaa Login-nappia, selainsovellus lähettää palvelimelle JSON-merkkijonon, joka on muotoa <code>{ "nickname": nick }</code>, missä <code>nick</code> on käyttäjän kirjoittama käyttäjätunnus. Kirjautumispyyntö tehdään HTTP POST-pyyntönä osoitteeseen <code>http://bad.herokuapp.com/app/auth</code>. Jos kirjautuminen onnistuu, palvelin palauttaa statuskoodin 200, muuten statuskoodi on jokin muu. Ilman kirjautumista palvelimelle ei voi lähettää viestejä.</p>

      <h4>Viestien listaaminen</h4>

      <p>Kirjautumisen onnistuessa käyttäjälle näytetään chat-näkymä, joka näyttää tyhjänä seuraavalta:</p>

      <p><img src="img/chat-1.png" border="1" /></p>

      <p>Kirjautumisen yhteydessä palvelimelta tulee myös hakea lista viimeisimmistä viesteistä, jotka näytetään näkymässä. Viestit saa haettua HTTP GET-pyynnöllä osoitteesta <code>http://bad.herokuapp.com/app/messages</code>. Jos viestien hakeminen onnistuu, palvelin palauttaa statuskoodin 200, muuten statuskoodi on jokin muu.</p>

      <p>Palvelin palauttaa viimeisimmät viestit JSON-taulukossa (array). Yksittäinen viesti sisältää seuraavat tiedot:</p>

<pre>
{
    "id": 4,
    "timestamp": 1352114153691,
    "nickname": "El Barto",
    "message": "Hello world!"
}
</pre>

      <p>Viestin aikaleima kuvaa millisekunteja epoch-ajankohdasta (1.1.1970). Esimerkiksi JavaScriptin <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a>-oliot osaavat tulkita tällaista lukua ja palauttaa normaalin päivämäärän ja kellonajan sen perusteella. Palvelin palauttaa viestit siten, että uusin viesti on ensimmäinen.</p>

      <p>Jos palvelimelle on jo lähetetty aiemmin viestejä, kirjautumisen jälkeen chat-näkymä näyttää esimerkiksi seuraavalta:</p>

      <p><img src="img/chat-2.png" border="1" /></p>

      <h4>Viestin lähetys</h4>

      <p>Toteuta viestin lähettäminen chat-näkymään. Send-nappia painettaessa sovelluksen tulee lähettää tekstikentässä oleva viesti palvelimelle. Uusi viesti tulee lähettää HTTP POST-pyynnöllä osoitteeseen <code>http://bad.herokuapp.com/app/messages</code>. Pyynnössä lähetettävä viesti näyttää esimerkiksei seuraavalta:</p>

<pre>
{
    "nickname": "El Barto",
    "message": "Huh-huh!"
}
</pre>

      <p>Hae viestin lähettämisen jälkeen palvelimelta uusimmat viestit ja päivitä chat-näkymä saaduilla viesteillä, jotta juuri lähetetty viesti näkyy sivulla.</p>

      <h4>Viestien päivittäminen ja uloskirjautuminen</h4>

      <p>Toteuta chat-näkymän Refresh-napin toiminnallisuus. Napin painalluksen tulee hakea palvelimelta uusimmat viestit ja näyttää ne chat-näkymässä.</p>

      <p>Toteuta chat-näkymän Logout-napin toiminnallisuus. Napin painalluksen tulee piilottaa chat-näkymä ja palauttaa login-näkymä sivulle, jotta chattiin voi kirjautua uudella nimimerkillä. Nimimerkille varatun tekstikentän tulee olla tyhjä. Samoin uudelleen kirjauduttaessa sisään chat-näkymän viestille varatun tekstikentän tulee olla tyhjä.</p>

      <p>Kun olet valmis, lähetä toteutuksesi TMC:lle.</p>
    </div>


    <h2>Oliot ja Moduulit</h2>

    <p>Syvennytään lisää olioihin ja moduuleihin.</p>

    <h3>Oliot</h3>

    <p>Oliot ovat funktioiden ilmentymiä, jotka luodaan <code>new</code>-avainsanalla. Oliolla on oma oliokohtainen tila, mihin pääsee käsiksi <code>this</code>-operaattorilla. Esimerkiksi alla on luotu funktio <code>Kirja</code>, josta voi luoda olioita. Kirjalle on määritelty attribuutit nimi ja julkaisuvuosi.</p>

<pre class="sh_javascript_dom">
function Kirja(nimi, julkaisuvuosi) {
    this.nimi = nimi;
    this.julkaisuvuosi = julkaisuvuosi;
}

// funktiosta luodaan olio new-operaattorilla
kalevala = new Kirja("Kalevala", 1835);
</pre>

    <p>Olioille määritellään metodeja prototyyppiperinnän avulla. Prototyypin muokkauksen jälkeen olioilla on käytössä juuri määritellyt funktiot.</p>

<pre class="sh_javascript_dom">
function Kirja(nimi, julkaisuvuosi) {
    this.nimi = nimi;
    this.julkaisuvuosi = julkaisuvuosi;
}

Kirja.prototype.tulostaNimi = function() {
    console.log(this.nimi);
}

// funktiosta luodaan olio new-operaattorilla
kalevala = new Kirja("Kalevala", 1835);
kalevala.tulostaNimi(); // Kalevala

elefantinMatka = new Kirja("Elefantin matka", 2008);
elefantinMatka.tulostaNimi(); // Elefantin matka
</pre>


    <p>Metodit määritellään käytännössä aina heti olion luovan funktion määrittelyn jälkeen. Käytännössä <code>new Kirja("Kalevala", 1835)</code>-kutsun suorituksessa uusi kalevala-olio peritään <code>Kirja.prototype</code> -prototyypistä. Tämän jälkeen sen konstruktori suoritetaan, ja sille allokoidaan olion attribuuttien tarvitsema tila. Lopulta konstruktori palauttaa viitteen uuteen olioon.</p>

    <p>JavaScript ei mahdollista <code>this</code>-operaattorilla esiteltyjen attribuuttien kapselointia, vaan ne ovat julkisia.</p>

<pre class="sh_javascript_dom">
function Kirja(nimi, julkaisuvuosi) {
    this.nimi = nimi;
    this.julkaisuvuosi = julkaisuvuosi;
}

Kirja.prototype.tulostaNimi = function() {
    console.log(this.nimi);
}

// funktiosta luodaan olio new-operaattorilla
kalevala = new Kirja("Kalevala", 1835);

// olion attribuutteihin pääsee käsiksi suoraan
kalevala.nimi = "Valekala";

kalevala.tulostaNimi(); // Valekala
</pre>


    <p>Konstruktorifunktiot nimetään isolla alkukirjaimella, olioiden nimet pienellä alkukirjaimella.</p>


<div class="tehtavat">

    <h3>Puhelinmuistio</h3>

    <p>Toteuta funktio Puhelinmuistio, joka luo puhelinmuistio-olion. Puhelinmuistioon voi lisätä nimiä ja numeroita. Jokaiseen nimeen voi liittyä useampi numero. Numeroiden lisäämisen tulee tapahtua <code>lisaaNumero</code>-funktiolla, ja puhelinmuistion tulee tarjota metodi <code>annaNumerot</code>, jolle annetaan parametrina nimi.</p>

    <p>Jos samalle henkilölle yritetään asettaa sama numero useampaan kertaan, numero tallennetaan henkilölle vain kerran. Useammalla henkilöllä voi olla sama numero.</p>

    <p>Tehtäväpohjan mukana olevalle HTML-sivulle ei tarvitse tehdä mitään. Voit hyödyntää tehtäväpohjassa tulevaa Array-funktion laajennusta <code>contains</code> omassa toteutuksessasi. Kun tehtävä toimii seuraavilla esimerkeillä, palauta se TMC:lle.</p>

<pre class="sh_javascript_dom">
muistio = new Puhelinmuistio();
muistio.lisaaNumero("mikke", "044-33669933");
muistio.lisaaNumero("mikke", "044-33669933");
console.log(muistio.annaNumerot("mikke")); // numero 044-33669933 vain kerran

muistio.lisaaNumero("mikke", "231");
console.log(muistio.annaNumerot("mikke")); // numerot 044-33669933 ja 231

console.log(muistio.annaNumerot("matti")); // tyhjä lista
muistio.lisaaNumero("matti", "1111");
console.log(muistio.annaNumerot("matti")); // numero 1111

console.log(muistio.annaNumerot("mikke")); // numerot 044-33669933 ja 231
</pre>


</div>
</section>



<section class="week">
  <header>
    <a name="viikko3"></a>
    <h1 data-week-id="3">Viikko 3</h1>
  </header>


    <h3>Moduulit</h3>

    <p>Moduulit toteutetaan anonyymien funktioiden avulla. Muuttujien funktionäkyvyyden takia muuttujat voidaan kapseloida anonyymin funktion sisään, jolloin niihin ei pääse käsiksi funktion ulkopuolelta. Anonyymin funktion sisälle määritellyt funktiot pääsevät käsiksi muuttujiin, jolloin sisäfunktioissa voidaan muokata muuttujien arvoja.  Moduuli palauttaa moduulissa määritellyn rajapinnan, jossa on viittaukset sisäfunktioihin.</p>

    <p>Hahmotellaan kaupan hallinnointiin tarvittavaa järjestelmää. Luodaan ostoskorimoduuli, joka tarjoaa julkisen rajapinnan tuotteiden lisäämiseen ja tuotteiden lukumäärän laskemiseen.</p>

<pre class="sh_javascript_dom">
var kauppa = {};

kauppa.ostoskori = (function() {
    var ostokset = [];

    function lisaaOstos(tuotteenNimi) {
        if(!ostokset[tuotteenNimi]) {
            // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
            ostokset[tuotteenNimi] = 0;
        }

        // kasvatetaan tuotteen lukumäärää yhdellä
        ostokset[tuotteenNimi]++;
    }

    function tuotteitaYhteensa() {
        var lukumaara = 0;
        for(var tuotteenNimi in ostokset) {
            lukumaara += ostokset[tuotteenNimi];
        }

        return lukumaara;
    }

    // rajapinta
    return {
        lisaa: lisaaOstos,
        tuotteidenLukumaara: tuotteitaYhteensa
    };
})();
</pre>

    <p>Ostoskoria voi käyttää nyt seuraavasti:</p>

<pre class="sh_javascript_dom">
kauppa.ostoskori.lisaa("keksi");
kauppa.ostoskori.lisaa("keksi");
kauppa.ostoskori.lisaa("omena");
console.log(kauppa.ostoskori.tuotteidenLukumaara()); // 3
</pre>

    <p>Anonyymille funktiolle voi antaa parametreja. Luodaan hinnastomoduuli, joka palauttaa tuotteen nimen perusteella sen hinnan. Vaikka hinnastomoduulimme palauttaa kaikkien tuotteiden hinnaksi 3, voisi sen toteutus myös hakea hinnat esimerkiksi erilliseltä palvelimelta.</p>

<pre class="sh_javascript_dom">
kauppa.hinnasto = (function() {
    function annaHinta(tuote) {
        return 3;
    }

    return {
        hinta: annaHinta
    };
})();
</pre>

    <p>Laajennetaan ostoskorimoduulia siten, että se saa hinnaston parametrina. Lisätään ostoskorille myös funktio ostoskorissa olevien tuotteiden hinnan laskemiseen.</p>

<pre class="sh_javascript_dom">
kauppa.ostoskori = (function(hinnasto) {
    var ostokset = [];

    function lisaaOstos(tuotteenNimi) {
        if(!ostokset[tuotteenNimi]) {
            // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
            ostokset[tuotteenNimi] = 0;
        }

        // kasvatetaan tuotteen lukumäärää yhdellä
        ostokset[tuotteenNimi]++;
    }

    function tuotteitaYhteensa() {
        var lukumaara = 0;
        for(var tuotteenNimi in ostokset) {
            lukumaara += ostokset[tuotteenNimi];
        }

        return lukumaara;
    }

    function yhteishinta() {
        var summa = 0;
        for(var tuotteenNimi in ostokset) {
            summa += ostokset[tuotteenNimi] * hinnasto.hinta(tuotteenNimi);
        }

        return summa;
    }

    // rajapinta
    return {
        lisaa: lisaaOstos,
        tuotteidenLukumaara: tuotteitaYhteensa,
        yhteishinta: yhteishinta
    };
})(kauppa.hinnasto);
</pre>

    <p>Huomaa miten riippuvuus hinnastoon nimetään moduulin sisällä uudestaan anonyymin funktion parametrien kautta. Moduulin sisällä hinnastoon viitataan muuttujalla <code>hinnasto</code>.</p>


<div class="tehtavat">
  <NEXTWEEK></NEXTWEEK>

  <h3>Ostoskorin tilaaminen ja varasto</h3>


  <p>Jatkokehitetään yllä olevaa esimerkkiä. Tehtävänäsi on luoda varastokirjanpitoa varten moduuli <code>kauppa.varasto</code>, joka tarjoaa seuraavat funktiot:</p>

  <ol>
    <li><code>lisaa(tuote, lukumaara)</code> lisää annetun lukumärään tuotteita varastoon.</li>
    <li><code>ota(tuote, lukumaara)</code> ottaa varastosta tuotteita halutun lukumäärän.</li>
    <li><code>saldo(tuote)</code> palauttaa tuotteen varastosaldon.</li>
  </ol>

  <p>Varastosaldo voi olla myös negatiivinen.</p>

  <p>Lisää lisäksi ostoskorille funktio <code>tilaa</code>, jonka avulla käyttäjä voi tilata ostoskorissa olevat tuotteet. Kun ostoskori tilataan, varastosta otetaan tuotteita ostoskorissa oleva määrä. Tyhjennä tilauksen lopuksi myös ostoskori.</p>

  <p>Kytke varasto ostoskoriin siten, että ostoskori tietää varastosta. Kun sovelluksesi toimii seuraavalla koodilla, palauta se TMC:lle.</p>

<pre class="sh_javascript_dom">
kauppa.ostoskori.lisaa("kivi");
kauppa.ostoskori.lisaa("kivi");
kauppa.ostoskori.lisaa("kivi");
console.log(kauppa.ostoskori.tuotteidenLukumaara()); // 3
console.log(kauppa.varasto.saldo("kivi")); // 0

kauppa.ostoskori.tilaa();
console.log(kauppa.ostoskori.tuotteidenLukumaara()); // 0
console.log(kauppa.varasto.saldo("kivi")); // -3

console.log(kauppa.varasto.saldo("paperi")); // 0

kauppa.ostoskori.lisaa("kivi");
kauppa.ostoskori.lisaa("kivi");
kauppa.ostoskori.lisaa("paperi");

kauppa.ostoskori.tilaa();
console.log(kauppa.varasto.saldo("kivi")); // -5
console.log(kauppa.varasto.saldo("paperi")); // -1

kauppa.varasto.lisaa("kivi", 7);
console.log(kauppa.varasto.saldo("kivi")); // 2
</pre>

  <p>Tilaamisen tulee vain vähentää tavarat varastosta ja tyhjentää ostoskori, muuta toiminnallisuutta ei vielä tarvitse.</p>

</div>

    <p><em>Edellä esitellystä moduulista ei voi tehdä olioita, joten ostoskoreja voi olla vain yksi. Tämä ei kuitenkaan aina ole toivottavaa.</em></p>


  <h3>Olioiden tila ja new</h3>


    <p>Operaatiota <code>new</code> kutsuttaessa funktiosta luodaan kopio, jolloin käytännössä varataan tilaa oliolle ja sen <code>this</code>-operaattorilla merkatuille muuttujille. Uusi, juuri luotava olio, on käytännössä joukko avain-arvo -pareja, jossa arvo voi olla funktio, muuttuja, tai olio. Koska muuttujat voivat olla funktioita, voi <code>this</code>-operaattorilla viitata funktioon.</p>

    <p>Luodaan funktio <code>Laskuri</code>, jonka sisällä on muuttuja <code>luku</code>. Muuttujaa <code>luku</code> ei määritellä <code>this</code>-operaatiolla, vaan se on funktion sisälle kapseloitu.</p>

<pre class="sh_javascript_dom">
function Laskuri() {
    var luku = 0;
}
</pre>

    <p>Ylläolevaa funktiota voi kutsua sekä <code>new</code>-operaation avulla että ilman. Jos funktiota kutsutaan ilman <code>new</code>- kutsua, kutsu on normaali funktiokutsu. Toisaalta, jos funktiota kutsutaan <code>new</code>-operaation kanssa, luodaan uusi olio.</p>

<pre class="sh_javascript_dom">
Laskuri(); // suorittaa funktion sisällä olevan koodin

var olio = new Laskuri(); // suorittaa funktion sisällä olevan koodin, luo olion, ja palauttaa sen erilliseen muuttujaan
</pre>

    <p>Yllä luotu olio on <em>kopio</em> Laskuri-funktion sisäisestä tilasta. Tilaan ei kuitenkaan pääse mitenkään käsiksi.</p>

    <p>Lisätään funktioon <code>Laskuri</code> kaksi <code>this</code>-operaatiolla määriteltyä funktiota. Koska operaatiolla <code>this</code> määritellyt muuttujat ovat oliokohtaisia, ovat myös funktiot oliokohtaisia.</p>

<pre class="sh_javascript_dom">
function Laskuri() {
    var luku = 0;

    this.kasvata = function() {
        luku++;
    }

    this.tulosta = function() {
        console.log(luku);
    }
}
</pre>

    <p>Tutkitaan nyt mitä tapahtuu kun kutsumme <code>Laskuri</code>-funktiota sekä ilman <code>new</code>-operaatiota, että <code>new</code>-operaation kanssa. Kutsutaan funktiota ensin ilman <code>new</code>-operaatiota.</p>

<pre class="sh_javascript_dom">
Laskuri(); // yrittää suorittaa funktion sisällä olevan koodin, ei toimi
</pre>

    <p>Kun funktiota <code>Laskuri</code> kutsutaan ilman <code>new</code>-operaatiota, näemme virheen "Cannot set property 'kasvata' of undefined". Tämä johtuu siitä, että <code>this</code> liittyy aina olioon. Käytännössä yritämme lisätä oliolle uutta muuttujaa <code>kasvata</code>. Yllä tämä epäonnistuu, sillä oliota, mille muuttujaa yritetään asettaa ei ole olemassa.</p>

    <p>Kutsutaan seuraavaksi funktiota <code>Laskuri</code> <code>new</code>-operaation kanssa, eli luodaan siitä olio.</p>

<pre class="sh_javascript_dom">
var laskin = new Laskuri();
</pre>

    <p>Yllä olevassa kutsussa luodaan klooni funktion <code>Laskuri</code> sisällöstä, ja palautetaan viite klooniin. Klooni kapseloi muuttujan <code>luku</code>, mutta siihen pääsee käsiksi oliomuuttujien <code>kasvata</code> ja <code>tulosta</code> kautta. Voimme luoda yllä olevasta funktiosta useamman kopion.</p>

<pre class="sh_javascript_dom">
var laskin = new Laskuri();
laskin.kasvata();
laskin.tulosta(); // 1

var toinen = new Laskuri();
toinen.tulosta(); // 0
laskin.tulosta(); // 1

laskin.kasvata();
laskin.tulosta(); // 2
toinen.tulosta(); // 0
</pre>

    <p>Javascriptiin tutustuessa huomasimme, että uusia JavaScript-olioita voi luoda aaltosulkujen avulla. Oikeastaan, operaatio <code>this</code>-lisää oliolle uusia muuttujia aivan kuten aaltosulkunotaatiolla luotavalle oliolle lisätään uusia muuttujia. Yllä olevan laskurin voi toteuttaa myös seuraavasti:</p>

<pre class="sh_javascript_dom">
function Laskuri() {
    var luku = 0;

    return {
        kasvata: function() {
            luku++;
        },
        tulosta: function() {
            console.log(luku);
        }
    };
}
</pre>

    <p>Ja seuraavasti:</p>

<pre class="sh_javascript_dom">
function Laskuri() {
    var luku = 0;

    function kasvata() {
        luku++;
    }

    function tulosta() {
        console.log(luku);
    }

    return {
        kasvata: kasvata,
        tulosta: tulosta
    };
}
</pre>


    <p>Oleellista on se, että Kutsu <code>new Laskuri()</code> palauttaa uuden olion. Uudella oliolla on funktion Laskuri kapseloima muuttuja <code>luku</code>, sekä luodun olion tarjoamat julkiset funktiot <code>kasvata</code> ja <code>tulosta</code>. Huomaa että kutsu <code>{}</code> luo uuden <em>Object</em>-tyyppisen olion -- yllä olevan olion tyyppi ei siis ole Laskin!</p>

<aside class="extra">
  <p><strong>Monta tapaa sanoa sama asia</strong></p>

  <p>JavaScriptiä on monimuotoisuutensa takia helposti hyvin vaikea ymmärtää. Yhden asian voi helposti sanoa viidelläkin eri tavalla, joka voi johtaa väärinkäsityksiin tai väärinymmärryksiin. Oleellista on kuitenkin ymmärtää että oliot ovat avain-arvo -pareja, joilla jokaisella voi olla <em>erilaiset</em> sisällöt. Arvot voivat olla funktioita, jotka muokkaavat toisia arvoja.</p>

  <p>Funktionäkyvyys mahdollistaa tiedon kapseloinnin. Sulkeumien takia sisäfunktioilla on pääsy niiden kapseloivan funktion sisältämiin muuttujiin, myös silloin kun kapseloivan funktion suoritus on ohi.</p>

</aside>

<div class="tehtavat">

    <h3>Tavara ja Matkalaukku</h3>

    <p>Muokataan viime viikolla ollutta tehtävää siten, että käytetään edellä esitettyä olioiden esitystapaa. Muokkaa tehtäväpohjassa olevia konstruktorifunktiota <code>Tavara</code> ja <code>Matkalaukku</code> siten, että konstruktorifunktiot sisältävät luotaviin olioihin liitettävät metodit. Muokkaa ohjelmaa siten, että se toimii alla olevalla esimerkillä.</p>

    <p>Kun ohjelmasi toimii kuten toivottu, lähetä se TMC:lle. Huom! Viimeiset 2 riviä saavat rikkoa ohjelman. Älä (vieläkään) aseta matkalaukkuun omaa paino-muuttujaa, vaan laske matkalaukun paino tavaroiden painosta.</p>

<pre class="sh_javascript_dom">
var kivi = new Tavara("kivi", 3);
var kirja = new Tavara("kirja", 7);
var pumpuli = new Tavara("pumpuli", 0.001);

var laukku = new Matkalaukku(10);
var vuitton = new Matkalaukku(3);

laukku.lisaa(kivi);
console.log("laukun paino, pitäisi olla 3: " + laukku.paino());
laukku.lisaa(kivi); // virhe: "Tavara lisätty jo, ei onnistu!"

laukku.lisaa(kirja);
console.log("laukun paino, pitäisi olla 10: " + laukku.paino());

laukku.lisaa(pumpuli); // virhe: "Liian painava, ei pysty!"

console.log("laukun paino, pitäisi olla 10: " + laukku.paino());

vuitton.lisaa(pumpuli);
console.log("vuittonin paino, pitäisi olla 0.001: " + vuitton.paino());

// seuraavien komentojen ei pitäisi ainakaan muuttaa vuittonin painoa
pumpuli.paino = 300; // jos tavaralla on metodi paino, hajottaa ohjelman seuraavassa, muuten ei
console.log("vuittonin paino, pitäisi olla vieläkin 0.001: " + vuitton.paino()); // paino ei ole muuttunut
</pre>

</div>



  <h3>Moduulien ja olioiden yhdistäminen</h3>

  <p>Suurimmat syyt moduulien käyttöön ovat käytettävien globaalien muuttujanimien vähentäminen sekä tiedon kapselointi. Aiemmin käyttämämme moduulit voidaan nähdä singleton-suunnittelumallia seuraavina olioina tai staattisina funktioina, jotka muokkaavat staattista tilaa. Moduuleista ei ole voinut luoda ilmentymiä.</p>

  <p>Pohditaan aiempaa kauppakassaesimerkkiä, jossa olimme varanneet kaupan toiminnallisuutta varten muuttujan <code>kauppa</code>. Aiempi toteutuksemme ostoskorista oli moduuli, joka tarkoitti sitä, että ostoskoreja voi olla vain yksi kerrallaan. Alustava toteutus näytti seuraavalta:</p>

<pre class="sh_javascript_dom">
var kauppa = {};

kauppa.ostoskori = (function() {
    var ostokset = [];

    function lisaaOstos(tuotteenNimi) {
        if(!ostokset[tuotteenNimi]) {
            // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
            ostokset[tuotteenNimi] = 0;
        }

        // kasvatetaan tuotteen lukumäärää yhdellä
        ostokset[tuotteenNimi]++;
    }

    function tuotteitaYhteensa() {
        var lukumaara = 0;
        for(var tuotteenNimi in ostokset) {
            lukumaara += ostokset[tuotteenNimi];
        }

        return lukumaara;
    }

    // rajapinta
    return {
        lisaa: lisaaOstos,
        tuotteidenLukumaara: tuotteitaYhteensa
    };
})();
</pre>

    <p>Muutetaan ylläoleva moduuli funktioksi siten, että ostoskorista voi tehdä uusia olioita. Muokataan funktioita <code>lisaaOstos</code> ja <code>tuotteitaYhteensa</code> myös siten, että niiden nimet vastaavat yllä määriteltyä rajapintaa.</p>

<pre class="sh_javascript_dom">
var kauppa = {};

kauppa.Ostoskori = function() {
    var ostokset = [];

    this.lisaa = function(tuotteenNimi) {
        if(!ostokset[tuotteenNimi]) {
            // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
            ostokset[tuotteenNimi] = 0;
        }

        // kasvatetaan tuotteen lukumäärää yhdellä
        ostokset[tuotteenNimi]++;
    }

    this.tuotteidenLukumaara = function() {
        var lukumaara = 0;
        for(var tuotteenNimi in ostokset) {
            lukumaara += ostokset[tuotteenNimi];
        }

        return lukumaara;
    }
}
</pre>


    <p>Voimme nyt luoda uusia ostoskoreja <code>new</code>-operaatiolla.</p>

<pre class="sh_javascript_dom">
var a = new kauppa.Ostoskori();
a.lisaa("kekseja");
a.lisaa("kekseja");
console.log(a.tuotteita()); // 2

var b = new kauppa.Ostoskori();
console.log(b.tuotteita()); // 0
console.log(a.tuotteita()); // 2
</pre>

    <p>Aiemmassa esimerkissämme ostoskorilla oli tiedossa hinnasto, jota ei ylläolevassa esimerkissä ole. Hinnaston lisääminen jokaisen ostoskorin konstruktorikutsun yhteydessä ei ole miellyttävää, joten muokataan edellisestä ostoskorista moduuli, joka kapseloi hinnaston. Haluamme myös säilyttää mahdollisuuden useamman ostoskorin luomiseen. Muokataan ensin ostoskoritoteutusta siten, että se on kapseloitu moduulin sisälle. Luodaan moduuli <code>Ostoskori</code>, joka funktiokutsun yhteydessä <em>palauttaa</em> moduulin kapseloiman konstruktorifunktion nimeltä <code>Kori</code>.</p>

<pre class="sh_javascript_dom">
var kauppa = {};

kauppa.Ostoskori = (function() {

    // konstruktori
    function Kori() {
        // oliokohtaiset muuttujat
        var ostokset = [];

        // oliokohtaiset metodit
        this.lisaa = function(tuotteenNimi) {
            if(!ostokset[tuotteenNimi]) {
                // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
                ostokset[tuotteenNimi] = 0;
            }

            // kasvatetaan tuotteen lukumäärää yhdellä
            ostokset[tuotteenNimi]++;
        }

        this.tuotteidenLukumaara = function() {
            var lukumaara = 0;
            for(var tuotteenNimi in ostokset) {
                lukumaara += ostokset[tuotteenNimi];
            }

            return lukumaara;
        }
    }

    return Kori;
})();
</pre>

    <p>Ylläolevassa koodissa määritellään anonyymin funktion sisällä konstruktorifunktio <code>Kori</code>, joka kapseloi ostoskorin toiminnallisuuden. Anonyymi funktio suoritetaan heti, sillä sen lopussa on sulut. Käytännössä funktio palauttaa konstruktorifunktion, joka asetetaan olion <ocde>kauppa</code> muuttujaan <code>Ostoskori</code>. Aiemmin tekemämme ohjelma toimii vieläkin.</p>

<pre class="sh_javascript_dom">
var kori = new kauppa.Ostoskori();
kori.lisaa("kekseja");
kori.lisaa("kekseja");
console.log(kori.tuotteidenLukumaara()); // 2

var laukku = new kauppa.Ostoskori();
console.log(laukku.tuotteidenLukumaara()); // 0
console.log(laukku.tuotteidenLukumaara()); // 2
</pre>

    <p>Lisätään ostoskorille hinnasto. Käytämme hinnaston toteutuksena aiemmin luomaamme seuraavanlaista hinnastoa.</p>

<pre class="sh_javascript_dom">
kauppa.hinnasto = (function() {
    function annaHinta(tuote) {
        return 3;
    }

    return {
        hinta: annaHinta
    };
})();
</pre>

    <p>Hinnaston lisääminen onnistuu antamalla se parametriksi anonyymille funktiolle.</p>

<pre class="sh_javascript_dom">
kauppa.Ostoskori = (function(hinnasto) {
    // moduulin sisäinen muuttuja, joka näkyy kaikille moduulin sisällä
    var hinnat = hinnasto;

    // konstruktori
    function Kori() {
        // oliokohtaiset muuttujat
        var ostokset = [];

        // oliokohtaiset metodit
        this.lisaa = function(tuotteenNimi) {
            if(!ostokset[tuotteenNimi]) {
                // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
                ostokset[tuotteenNimi] = 0;
            }

            // kasvatetaan tuotteen lukumäärää yhdellä
            ostokset[tuotteenNimi]++;
        }

        this.tuotteidenLukumaara = function() {
            var lukumaara = 0;
            for(var tuotteenNimi in ostokset) {
                lukumaara += ostokset[tuotteenNimi];
            }

            return lukumaara;
        }
    }

    return Kori;
})(kauppa.hinnasto);
</pre>

    <p>Nyt ostoskorilla on käytössä hinnasto. Lisätään ostoskorille vielä metodi ostoskorissa olevien tuotteiden hinnan laskemiseen.</p>

<pre class="sh_javascript_dom">
kauppa.Ostoskori = (function(hinnasto) {
    // moduulin sisäinen muuttuja, joka näkyy kaikille moduulin sisällä
    var hinnat = hinnasto;

    // konstruktori
    function Kori() {
        // oliokohtaiset muuttujat
        var ostokset = [];

        // oliokohtaiset metodit
        this.lisaa = function(tuotteenNimi) {
            if(!ostokset[tuotteenNimi]) {
                // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
                ostokset[tuotteenNimi] = 0;
            }

            // kasvatetaan tuotteen lukumäärää yhdellä
            ostokset[tuotteenNimi]++;
        }

        this.tuotteidenLukumaara = function() {
            var lukumaara = 0;
            for(var tuotteenNimi in ostokset) {
                lukumaara += ostokset[tuotteenNimi];
            }

            return lukumaara;
        }

        this.yhteishinta = function() {
            var summa = 0;
            for(var tuotteenNimi in ostokset) {
                summa += ostokset[tuotteenNimi] * hinnat.hinta(tuotteenNimi);
            }

            return summa;
        }
    }

    return Kori;
})(kauppa.hinnasto);
</pre>

<pre class="sh_javascript_dom">
var kori = new kauppa.Ostoskori();
kori.lisaa("kekseja");
kori.lisaa("kekseja");
console.log(kori.tuotteidenLukumaara()); // 2
console.log(kori.yhteishinta()); // 6

var laukku = new kauppa.Ostoskori();
console.log(laukku.tuotteidenLukumaara()); // 0
console.log(laukku.yhteishinta()); // 0

console.log(kori.tuotteidenLukumaara()); // 2
console.log(kori.yhteishinta()); // 6
</pre>

    <p>Ylläolevassa esimerkissä käytetään moduulille parametrina annettua hinnastoa hintojen laskemiseen. Itseasiassa, koska hinnasto on moduulin parametrina, on se käytössä myös moduulin sisällä. Moduuli ei siis tarvitse erillistä <code>hinnat</code>-muuttujaa.</p>

<pre class="sh_javascript_dom">
kauppa.Ostoskori = (function(hinnasto) {

    // konstruktori
    function Kori() {
        // oliokohtaiset muuttujat
        var ostokset = [];

        // oliokohtaiset metodit
        this.lisaa = function(tuotteenNimi) {
            if(!ostokset[tuotteenNimi]) {
                // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
                ostokset[tuotteenNimi] = 0;
            }

            // kasvatetaan tuotteen lukumäärää yhdellä
            ostokset[tuotteenNimi]++;
        }

        this.tuotteidenLukumaara = function() {
            var lukumaara = 0;
            for(var tuotteenNimi in ostokset) {
                lukumaara += ostokset[tuotteenNimi];
            }

            return lukumaara;
        }

        this.yhteishinta = function() {
            var summa = 0;
            for(var tuotteenNimi in ostokset) {
                summa += ostokset[tuotteenNimi] * hinnasto.hinta(tuotteenNimi);
            }

            return summa;
        }
    }

    return Kori;
})(kauppa.hinnasto);
</pre>

<pre class="sh_javascript_dom">
var kori = new kauppa.Ostoskori();
kori.lisaa("kekseja");
kori.lisaa("kekseja");
console.log(kori.tuotteidenLukumaara()); // 2
console.log(kori.yhteishinta()); // 6

var laukku = new kauppa.Ostoskori();
console.log(laukku.tuotteidenLukumaara()); // 0
console.log(laukku.yhteishinta()); // 0

console.log(kori.tuotteidenLukumaara()); // 2
console.log(kori.yhteishinta()); // 6
</pre>


<!--
<div class="tehtavat">
    <h3>Kirjat ja niiden hinnat</h3>

  <p>kirjalla nimi ja sivujen määrä, hinnat haetaan erillisestä palvelusta.</p>

</div>
-->


<div class="tehtavat">
  <NEXTWEEK></NEXTWEEK>

  <h3>Ostoskorin tilaaminen ja varasto, osa 2</h3>

  <p>Yhdistä tehtävän 18 ratkaisusi edellä olevaan esimerkkiin siten, että ostoskoreja voi luoda useampia, ja että jokaisen voi tilata erikseen. Kun sovelluksesi toimii oikein, palauta se TMC:lle -- voit käyttää allaolevaa koodia avuksi ohjelman testaamiseen.</p>

<pre class="sh_javascript_dom">
var kori = new kauppa.Ostoskori();
kori.lisaa("kivi");
kori.lisaa("kivi");
kori.lisaa("kivi");
console.log(kori.tuotteidenLukumaara()); // 3
console.log(kauppa.varasto.saldo("kivi")); // 0

kori.tilaa();
console.log(kori.tuotteidenLukumaara()); // 0
console.log(kauppa.varasto.saldo("kivi")); // -3

console.log(kauppa.varasto.saldo("paperi")); // 0

kori.lisaa("kivi");

var uusikori = new kauppa.Ostoskori();

uusikori.lisaa("kivi");
uusikori.lisaa("paperi");

console.log(kori.tuotteidenLukumaara()); // 1
console.log(uusikori.tuotteidenLukumaara()); // 2

kori.tilaa();
uusikori.tilaa();

console.log(kauppa.varasto.saldo("kivi")); // -5
console.log(kauppa.varasto.saldo("paperi")); // -1

kauppa.varasto.lisaa("kivi", 7);
console.log(kauppa.varasto.saldo("kivi")); // 2
</pre>

</div>


    <h2>MV* ja Web-sovelluksen rakenne</h2>


    <p>Termi MVC (<em>Model, View, Controller</em>) esiintyy lähes kaikkialla ohjelmistotekniikassa. MVC on suunnittelumalli, joka pilkkoo sovelluksen kolmeen osaan: dataan (model), näkymään (view), ja käyttäjän interaktioita hallinnoivaan sovelluslogiikkaan eli kontrolleriin (controller). MVC-mallia on käytetty <a href="http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html" target="_blank">alunperin</a> työpöytäsovelluksissa, mutta se on otettu käyttöön myös palvelin- ja selainpuolen ohjelmistoihin niiden kehittyessä. </p>

    <p>Perusideat ovat säilyneet samoina. Käyttäjän tehdessä jotain, esimerkiksi painaessa sivulla olevaa nappia, toimintoon liittyvä tieto välittyy kontrollerille, joka päättää mitä seuraavaksi tehdään. Yleisin toiminto on mallin muokkaaminen tai korvaaminen palvelimelta haetulla datalla, ja uuden näkymän näyttäminen muokattuun malliin perustuen. Palvelinohjelmistoja rakennettaessa tämä tapahtuu esimerkiksi lähettämällä web-sivulla olevan lomakkeen data tiettyyn osoitteeseen, jossa kontrolleri odottaa pyyntöä. Kontrollerin vastaanottaessa pyynnön, pyyntöön liittyvä mahdollinen data tallennetaan. Tämän jälkeen luodaan uusi model, johon haetaan tietoa esimerkiksi tietokantapalvelusta. Model ohjataan näkymän luovalle komponentille, joka lopulta palauttaa uuden näkymän käyttäjälle.</p>

    <p>Dynaamista toiminnallisuutta sisältävissä selainohjelmistoissa erityisesti vastaukset voivat sisältää paljon vähemmän dataa. Koko näkymää ei tarvitse hakea uudestaan jokaisen kyselyn yhteydessä.</p>

    <h3>Esimerkki: Muistuttaja</h3>

    <p>Luodaan sovellus, johon käyttäjä voi lisätä päiväkohtaisia tapahtumia. Jokaiseen tapahtumaan liittyy nimi ja aika. Luodaan aluksi sovellukselle nimiavaruus <code>muistutus</code>, johon sovelluksen toiminnallisuus lisätään.</p>

    <p>Vaikka sovelluksessa käydään läpi sovelluksen osat termeillä Model, View, Controller, ei sovelluksen arkkitehtuuri seuraa MVC-mallia sen perinteisessä mielessä.</p>

<pre class="sh_javascript_dom">
var muistutus = {};
</pre>

    <h4>View</h4>

    <p>MVC-mallissa näkymä vastaanottaa dataa, ja päättää miten se näytetään. Näkymä voi käyttää olemassaolevaa HTML-dokumenttia, ja asettaa siihen dataa, tai se voi luoda uusia elementtejä DOMin avulla. Huomaa että näkymä ja data on erotettu toisistaan, eli näkymä ei tiedä -- eikä välitä -- mallista. Se käsittelee vain dataa, jota sille annetaan. Luodaan HTML-dokumentti, jossa on paikka tapahtumille ja kentät uuden tapahtuman lisäämiselle.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;What's Happening?!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body onload="muistutus.init();" &gt;

        &lt;section id="tapahtumat"&gt;
        &lt;/section&gt;

        &lt;section id="uusitapahtuma"&gt;
            &lt;label&gt;Nimi: &lt;input type="text" id="nimi" /&gt;&lt;/label&gt;
            &lt;label&gt;Aika (vvvv-kk-pp): &lt;input type="text" id="aika" /&gt;&lt;/label&gt;
            &lt;input type="button" id="lisaa" /&gt;
        &lt;/section&gt;


        &lt;script src="muistutus.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Luodaan näkymää varten oma nimiavaruus <code>muistutus.view</code>, ja lähdetään rakentamaan näkymän generointiin tarvittavaa toiminnallisuutta.</p>

<pre class="sh_javascript_dom">
muistutus.view = {};
</pre>

    <p>Luodaan tapahtumien listaamiseen tarvittava näkymä. Huomaa, että näkymä voi tarkoittaa myös sivun sisällä olevaa elementtiä. Luodaan listaus siten, että sille annetaan parametrina elementti, johon tapahtumia lisätään. Tapahtumien listaaminen tapahtuu metodissa <code>listaaTapahtumat</code>. Metodin <code>listaaTapahtumat</code> lisäksi näkymällä on metodi <code>paivita</code>, jota kutsutaan kun näkymä halutaan päivittää. Päivitä-metodille annetaan parametrina data, joka halutaan näyttää näkymässä.</p>

<pre class="sh_javascript_dom">
muistutus.view.Listaus = function(elementti) {

    // julkiset metodit
    this.listaaTapahtumat = function(tapahtumat) {
        tyhjenna();

        for (var i = 0; i < tapahtumat.length; i++) {
            lisaaTapahtuma(tapahtumat[i]);
        }
    }

    this.paivita = function(tapahtumat) {
        // päivitysoperaatio kutsuu listausoperaatiota
        this.listaaTapahtumat(tapahtumat);
    }

    // kapseloidut apufunktiot
    function lisaaTapahtuma(tapahtuma) {
        var tapahtumaElementti = document.createElement("h2");
        var teksti = tapahtuma.nimi + ' (' + tapahtuma.aika + ')';

        tapahtumaElementti.appendChild(document.createTextNode(teksti));
        elementti.appendChild(tapahtumaElementti);
    }

    function tyhjenna() {
        while(elementti.firstChild) {
            elementti.removeChild(elementti.firstChild);
        }
    }
}
</pre>

    <p>Huomaa, että näkymässä aiheutuviin tapahtumiin liittyvää koodia ei sisällytetä näkymän koodiin, vaan ne jätetään kontrollerille. Koska elementti, johon tapahtumat lisätään, annetaan konstruktorifunktiolle parametrina, on se käytössä myös olion metodeissa.</p>

    <h4>Model</h4>

    <p>Tapahtumakalenteriin liittyvän mallin luominen on helpohkoa. Luodaan ensin oma nimiavaruus <code>muistutus.domain</code>.</p>

<pre class="sh_javascript_dom">
muistutus.domain = {};
</pre>

    <p>Luodaan nimiavaruuteen <code>muistutus.domain</code> konstruktori <code>Tapahtumalista</code>, joka tarjoaa toiminnallisuuden tapahtumien lisäämiseen ja kapselointiin. Tapahtumalista tietää <em>jostain</em>-näkymästä, jonka päivitysoperaatiota se kutsuu kun tapahtumia lisätään.</p>

<pre class="sh_javascript_dom">
muistutus.domain.Tapahtumalista = function(view) {
    var tapahtumat = [];

    this.lisaaTapahtuma = function(tapahtuma) {
        tapahtumat.push(tapahtuma);

        view.paivita(tapahtumat);
    }

    this.annaTapahtumat = function() {
        return tapahtumat;
    }
}
</pre>

    <p>Vaikka haluaisimme myös tehdä erillisen konstruktorin tapahtumalle, käytetään tapahtumia varten JavaScriptin omia olioita. Näin olioiden tallentamistoiminnallisuuden mahdollinen toteutus on helpompaa, sillä funktiota <code>JSON.parse</code> voi käyttää suoraan <code>tapahtumat</code>-muuttujaan.</p>

    <h4>Controller</h4>

    <p>Luodaan seuraavaksi kontrolleri. Kontrollerin tehtävänä on reagoida käyttöliittymässä tapahtuviin tapahtumiin, sekä toimia niiden pohjalta jotenkin. Luomme kontrollereille ensin oman nimiavaruuden <code>muistutus.controller</code>.</p>

<pre class="sh_javascript_dom">
muistutus.controller = {};
</pre>

    <p>Kontrolleri <code>LomakeKontrolli</code> tarjoaa rajapinnan lomake-elementtien käsittelyyn. Kontrollerille voi lisätä elementtejä, joita se kuuntelee. Se tarjoaa myös metodin <code>lisaaTapahtuma</code>, jota voi kutsua tapahtumankäsittelyn yhteydessä. Metodi <code>lisaaTapahtuma</code> käy läpi rekisteröidyt elementit, ja luo niiden pohjalta olion. Olio lähetetään lopulta mallille.</p>

<pre class="sh_javascript_dom">
muistutus.controller.LomakeKontrolli = function(model) {
    var elementit = {};

    this.lisaaDataelementti = function(nimi, elementti) {
        elementit[nimi] = elementti;
    }

    this.lisaaTapahtuma = function(eventInformation) {
        var data = haeData();

        model.lisaaTapahtuma(data);

        tyhjennaElementit();
    }

    function haeData() {
        var data = {};
        for (var nimi in elementit) {
            data[nimi] = elementit[nimi].value;
        }

        return data;
    }

    function tyhjennaElementit() {
        for (var nimi in elementit) {
            elementit[nimi].value = "";
        }
    }
}
</pre>

    <p>Kontrolleri sisältää toiminnallisuuden kontrolloitavien elementtien lisäämiseen, sekä elementtien sisältämän datan lähettämiseen tapahtumalistalle. Huomaa, että kontrolleri ei oikeastaan tiedä tapahtumien muodosta. Se vain kontrolloi lomakkeen elementtejä.</p>

    <h4>Sovelluksen alustaminen</h4>

    <p>Luodaan lopuksi alustusfunktio, joka luo sovelluksessa käytetyt oliot, sekä kytkee HTML-dokumentin elementit kontrolleriin.</p>

<pre class="sh_javascript_dom">
muistutus.init = function() {
    // luodaan palaset
    var listausnakyma = new muistutus.view.Listaus(document.getElementById("tapahtumat"));

    var lista = new muistutus.domain.Tapahtumalista(listausnakyma);
    listausnakyma.listaaTapahtumat(lista.annaTapahtumat());

    var kontrolli = new muistutus.controller.LomakeKontrolli(lista);

    // kytketään kontrolli elementteihin
    kontrolli.lisaaDataelementti("nimi", document.getElementById("nimi"));
    kontrolli.lisaaDataelementti("aika", document.getElementById("aika"));

    document.getElementById("lisaa").addEventListener("click", kontrolli.lisaaTapahtuma, false);
}
</pre>

    <p>Toimii! Sovellusta voisi esimerkiksi jatkokehittää siten, että se sisältäisi datan lähettämisen erilliselle palvelinkomponentille. Tämän lisäksi tapahtumia tulisi pystyä poistamaan.</p>


<div class="tehtavat">

  <h3>Validointi</h3>

  <p>Tehtäväpohjan mukana tulee edellä käsitelty muistutussovellus. Jatkokehitä sovellusta siten, että sovelluksessa on validointitoiminnallisuus. Kun käyttäjä yrittää lisätä tapahtumaa, tulee tapahtuman tiedot validoida.</p>

  <p>Toteuta validointitoiminnallisuus siten, että kontrolleriin voi lisätä validoijia. Kun käyttäjä lisää tapahtumaa, kaikki validoijat käydään läpi yksitellen siten, että data annetaan kullekin validoijalle vuorollaan. Jos validoijan palauttama viesti ei ole tyhjä, eli validoijalla on jotain valitettavaa, viesti näytetään käyttäjälle ja validointi sekä tapahtuman lisääminen lopetetaan. Toteuta validoijat tehtäväpohjassa annetun Validoija-konstruktorin pohjalta siten, että kukin validoija on olio, jolla on validoitavan kentän nimen lisäksi validointifunktio, jota kontrollerin tulee kutsua dataa validoitaessa. Validoijan sisältämälle funktiolle annetaan parametrina kentän arvo, ja se palauttaa merkkijonon.</p>

  <p>Esimerkki validoijaoliosta:</p>

<pre class="sh_javascript_dom">
var validoija = new Validoija("nimi", function(data) {
    if(!data) {
        return "Nimi ei saa olla tyhjä!";
    }

    return "";
});
</pre>

  <p>Jos ylläoleva validoija on lisätty kontrollerille, datan lisäyksen ei tule toimia jos nimikenttä on tyhjä.</p>

  <p>Kun kontrolleri tukee validoijien lisäämistä, lisää sinne yllä oleva validoija. Luo myös validoija , joka tarkastaa että aika on muotoa <code>yyyy-MM-dd</code>, esimerkiksi 2012-12-24. Kukin numero saa olla mitä tahansa numeroiden 0 ja 9 välillä. Kannattaa tutustua säännöllisiin lausekkeisiin (google esim.  "javascript regular expressions date").</p>

  <p>Kun sovelluksesi toimii kuten haluttu, palauta se TMC:lle.</p>
</div>


    <h3>Kontrollerin rooli selainohjelmistoissa</h3>

    <p>Yllä olevaa sovellusta luodessa huomaamme, että kontrollerin rooli ei ole kovin selkeä. Muistutus-esimerkissä sovelluksessa kontrolleri toimi elementtien rekisterinä siihen asti, kunnes käyttäjä painoi käyttöliittymän nappia. Napin painalluksenkin rekisteröinti tapahtui kontrollerin ulkopuolella. Sovelluksen voi toteuttaa myös ilman kontrolleria siten, että kontrollerin toiminnallisuus sisällytettäisiin alustukseen.</p>

<pre class="sh_javascript_dom">
muistutus.init = function() {
    // luodaan palaset
    var listausnakyma = new muistutus.view.Listaus(document.getElementById("tapahtumat"));

    var lista = new muistutus.domain.Tapahtumalista(listausnakyma);
    listausnakyma.listaaTapahtumat(lista.annaTapahtumat());

    document.getElementById("lisaa").addEventListener('click', function() {
        var tapahtuma = {
            nimi: document.getElementById("nimi").value,
            aika: document.getElementById("aika").value
        };

        lista.lisaaTapahtuma(tapahtuma);

        document.getElementById("nimi").value = "";
        document.getElementById("aika").value = "";
    }, false);
}
</pre>

    <p>Onko kontrolleri tarpeellinen?</p>

    <p>Jos sovelluksessa on useampia näkymiä, joiden välillä haluaisimme siirtyä, kontrollerista on hyötyä. Pienessä sovelluksessa erillisen kontrollerin käyttö saattaa kuitenkin monimutkaistaa sovelluksen rakennetta -- esimerkiksi yllä kontrollerin toiminnallisuuden pystyi lisäämään osaksi init-funktiota. Kontrollereita käytetään myös erityisesti käyttäjän ohjaamiseen useamman näkymän välillä.</p>

    <h3>Esimerkki: Spoilaaja</h3>

    <p>Toteutetaan seuraavaksi sovellus, jossa ei ole eksplisiittistä kontrolleria. Sovelluksessa näkymässä tapahtuvat päivitykset siirtyvät mallille näkymään liitettyjen tapahtumankäsittelijöiden kautta. Tapahtumankäsittelijät luodaan sovelluksen alustusvaiheessa, jolloin tapahtumankäsittelijät toimivat siltana mallin ja näkymän välillä. Käytännössä näkymä ei tiedä mallista, eikä malli näkymästä.</p>

<pre>

   VIEW    &lt;--- näytä ---    MODEL LISTENER
     |                             |
   muutos                        muutos
     |                             |
VIEW LISTENER --- päivitä --&gt;    MODEL

</pre>

    <p>Sovelluksen aihepiiri on spoilaaja, eli sillä näytetään kirjoihin liittyviä spoilauksia. Hahmotellaan ensin sovelluksen käyttöliittymä. HTML-dokumentin rakenne näyttää seuraavalta:</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"/&gt;
        &lt;title&gt;Spoilerit!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body onload="spoilaaja.init();"&gt;
        &lt;header&gt;
            &lt;h1&gt;Spoilerit&lt;/h1&gt;
        &lt;/header&gt;

        &lt;section id="spoilaukset"&gt;
        &lt;/section&gt;

        &lt;section id="input"&gt;
            &lt;h2&gt;Syötä uusi&lt;/h2&gt;
            &lt;label&gt;kirja &lt;input type="text" id="kirja"/&gt;&lt;/label&gt;
            &lt;label&gt;spoilaus &lt;input type="text" id="spoilaus"/&gt;&lt;/label&gt;
            &lt;input type="button" id="button" value="Lisää!"/&gt;
        &lt;/section&gt;

        &lt;script src="spoilaus.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>Ohjelmakoodi lisätään nimiavaruuteen <code>spoilaaja</code>.</p>

<pre class="sh_javascript_dom">
var spoilaaja = {};
</pre>

     <h4>View</h4>

      <p>Luodaan sovelluksen näkymään liittyvä koodi. Ainoa alue, josta olemme kiinnostuneet, on tunnuksella <code>spoilaukset</code> merkitty alue. Näkymälle asetetaan <code>init</code>-funktiolla alueen tunnus, jonka sisälle se lisää dataa. Kun näkymään lisätään dataa, se luo jokaista kirjaa varten oman tekstikentän, joka sisältää kyseisen kirjan spoilauksen. Kun spoilauksen sisältö muuttuu, kutsutaan erillistä näkymälle asetettavaa tapahtumankuuntelijafunktiota muutokseen liittyvällä datalla.</p>

      <p>Tapahtumankuuntelija lisätään sovellukseen sovellusta käynnistettäessä funktiolla <code>setListener</code>. Aina kun näkymään lisätään uutta spoilausta, lisätään tekstikenttään myös tapahtumankuuntelija. Tapahtumankuuntelija lähettää viestin mallille, jos data muuttuu.</p>

<pre class="sh_javascript_dom">
spoilaaja.View = function(containerId) {
    var container = document.getElementById(containerId);
    var listener;

    // julkiset metodit
    this.render = function(data, key, value) {
        if(data !== false) {
            renderAll(data);
        } else {
            renderSingle(key, value);
        }
    }

    this.setListener = function(actionListener) {
        listener = actionListener;
    }

    // apufunktiot
    function renderAll(data) {
        clear();

        for (var key in data) {
            renderSingle(key, data[key]);
        }
    }

    function clear() {
        while(container.firstChild) {
            container.removeChild(container.firstChild);
        }
    }

    function renderSingle(key, value) {
       var element = document.getElementById(key);

       if(!element) {
           // jos elementtiä ei ole vielä olemassa, luodaan sellainen
           createElement(key, value);
       }

       document.getElementById(key).value = value;
    }

    function createElement(key, value) {
        var article = document.createElement("article");
        var label = document.createElement("label");
        var textField = document.createElement("input");
        textField.type="text";

        label.appendChild(document.createTextNode(key));
        textField.id = key;
        textField.value = value;

        article.appendChild(label);
        article.appendChild(textField);

        container.appendChild(article);

        // jokaiseen elementtiin lisätään tapahtumankuuntelija
        if(listener) {
            textField.addEventListener("change", function(eventInformation) {
                var textField = eventInformation.target;
                listener(textField.id, textField.value);
            }, false);
        }
    }
}
</pre>

    <p>Seuraavaksi datan säilytys ja esitys.</p>

    <h4>Model</h4>

    <p>Model kapseloi sovelluksessa käytettävän datan sisäänsä. Tämän lisäksi se tarjoaa aksessorit dataan, sekä tapahtumankäsittelijäfunktion, jota kutsutaan, jos mallin sisältämään dataan tehdään muutoksia. Sovelluksen sisältämä data on käytännössä olio, eli joukko avain-arvo -pareja. Avain on aina kirjan nimi, ja arvo kirjaan liittyvä spoilaus.</p>

<pre class="sh_java">
spoilaaja.Model = function(initialData) {
    var data = initialData;
    var listener;

    this.update = function(key, value) {
        data[key] = value;

        if(!listener) {
            console.log("Model update called, but listener has not been set :(");
            return;
        }

        listener(key, value);
    }

    this.get = function(key) {
        return data[key];
    }

    this.getAll = function() {
        return data;
    }

    this.setListener = function(action) {
        listener = action;
    }
}
</pre>

      <p>Tässä vaiheessa saatat huomata, että ylläolevassa Model-toteutuksessa ei ole minkäänlaista viittausta sovelluksen käyttötarkoitukseen. Tämä on tarkoituskin. Itseasiassa, ylläolevaa toteutusta voisi käyttää monissa muissakin yhteyksissä...</p>

      <h4>Sovelluksen alustaja</h4>

      <p>Luodaan seuraavaksi sovelluksen alustaja. Alustajan tehtävänä on alustaa sovellus, ja kytkeä näkymä ja malli toisiinsa tapahtumankäsitelijöiden kautta. Luodaan ensin sovelluksessa käytettävä data, jonka jälkeen lisätään näkymälle tapahtumankuuntelija. Näkymään liitettävä tapahtumankuuntelija kutsuu mallin update-funktiota jos käsitelty data on muuttunut. Huomaa, että tapahtumalogiikka ei ole osa näkymää, vaan osa sovelluksen alustusta.</p>


<pre class="sh_javascript_dom">
spoilaaja.init = function() {
    var data = {};
    data["Running Blind"] = "Murhaaja on nainen!";
    data["Cat's cradle"] = "se jäätävä homma...";

    var model = new spoilaaja.Model(data);
    var view = new spoilaaja.View("spoilaukset");

    // tapahtuman kuuntelijat viewlle (näin alustava tulostus ei muuta modelia
    view.setListener(function(key, value) {
        console.log("Listener in view called");
        if(model.get(key) !== value) {
            model.update(key, value);
        }
    });
</pre>

      <p>Kun näkymässä on toiminnallisuus mallin päivittämiseen, kutsutaan näkymän <code>render</code>-metodia. Metodi <code>render</code> luo näkymän annetun datan pohjalta.</p>

<pre class="sh_javascript_dom">
view.render(model.getAll(), false, false);
</pre>

      <p>Lisätään vielä tapahtumankuuntelija modelille. Nyt jos modelissa tapahtuu muutos, se päivitetään myös näkymälle. Tällöin näkymä saa tietoonsa muutokset, jotka tapahtuvat muualla. Luotava tapahtumankuuntelija ja kuuntelijan käsittelyn toteutus mallissa aiheuttaa käytännössä sen, että näkymä saa tietoonsa mallin muutokset.</p>

<pre class="sh_javascript_dom">
model.setListener(function(key, value) {
    view.render(false, key, value);
});
</pre>

      <p>Kytketään lopuksi käyttöliittymässä olevaan nappiin spoilauksen lisäystoiminnallisuus.</p>

<pre class="sh_javascript_dom">
// kytketään nappi toimimaan
var nappi = document.querySelector("#input #button");

nappi.addEventListener("click", function(eventInformation) {
    var kirja = document.querySelector("#input #kirja").value;
    if(!kirja) {
        return;
    }

    var spoilaus = document.querySelector("#input #spoilaus").value;
    model.update(kirja, spoilaus);

}, false);
</pre>


<div class="extra">
  <p><strong>Observer Pattern</strong></p>

  <p>Suunnittelumallia, jossa komponenttiin voi lisätä muiden komponenttien kutsufunktioita siten, että niitä kutsutaan komponentin päivittyessä kutsutaan <a href="http://en.wikipedia.org/wiki/Observer_pattern" target="_blank">Observer Patterniksi</a>. Käytännössä komponentti ei tiedä muista komponenteista mitään, sillä on vain pääsy niiden tarjoamassa rajapinnassa olevaan yksittäiseen kutsufunktioon.</p>

</div>

<div class="tehtavat">
    <h3>Spoilaajan Backend (2p)</h3>

    <p>Muistellaan taas JSON-kyselyjen tekemistä palvelimelle. Käy kertaamassa kappale 7 ennen tätä tehtävää. Tehtävänäsi on tässä lisätä edellä esitettyyn ohjelmaan backend-kytkös. Backend-kytköksen tehtävänä on sovelluksen käynnistyessä hakea olemassaolevat spoilaukset palvelimelta, sekä lähettää palvelimelle mahdolliset muutokset.</p>

    <p>Spoilausten tallentamiseen käytetty palvelinsovellus toimii osoitteessa <a href="http://bad.herokuapp.com/app/" target="_blank">http://bad.herokuapp.com/app/</a>. Kannattaa tehdä kysely palvelimelle selaimella ennen tehtävän tekemistä, jotta palvelin on varmasti käynnissä. Palvelin tarjoaa osoitteessa <code>http://bad.herokuapp.com/app/spoilers/</code> toimivan rajapinnan. Kun rajapintaan tehdään GET-kysely, palvelin palauttaa kaikki tallennetut spoilaukset.</p>

    <p>Uusien spoilausten lisääminen tai olemassaolevien muokkaaminen tapahtuu POST-pyynnöllä rajapintaan. POST-pyyntö tehdään siten, että sen mukana lähetetään JSON-muotoista dataa merkkijonomuodossa. JSON-datan tulee näyttää seuraavalta oliomuodossa:</p>

<pre class="sh_javascript_dom">
var lahetettava = {
    name: "spoilattava",
    spoiler: "spoilaus"
};
</pre>

    <p>Toteuta sovellus aluksi niin, että toteutat vain komponentin, jonka tehtävänä on kommunikoida palvelimen kanssa -- mutta -- älä toteuta itse kommunikointia vielä. Kun saat sovelluksen kommunikoimaan backend-komponentin kanssa, lisää backendille viestien lähetys ja vastaanottaminen palvelimelle.</p>

</div>

    <h3>MVC, MVP, MVVM, ...</h3>

    <p>Käytännössä kaikissa MV* -suunnittelumalleissa ajatuksena on näkymän ja sovelluslogiikan erottaminen toisistaan. Näimme aiemmin MVC-mallin, jossa pyyntö käytännössä kulkee näkymältä kontrollerille, joka ohjaa pyynnön mallille. Malli taas päivittää näkymää tarpeen vaatiessa. Käytännössä pyynnön kulku MVC-mallissa näyttää seuraavalta:</p>

<pre>
                  <em>kliksu</em>
                    ||
                    \/
                   VIEW
               /         /\
              /           \
<em>ohjauspyyntö</em> /             \  <em>päivitys</em>
            /               \
           \/                \
  CONTROLLER  - muokkaus - >  MODEL

</pre>

   <p>Kaksi viime aikoina päätänsä nostanutta MVC-varianttia ovat MVP (<em>Model, View, Presenter</em>) ja MVVM (<em>Model, View, ViewModel</em>). Tutustutaan niihin pikaisesti.</p>


   <h4>MVP</h4>

   <p>Joissain tapauksissa sovelluksissa ei ole suoraa mahdollisuutta näkymän ja mallin toisiinsa kytkemiseen. Tällöin sovellus tarvitsee näkymän ja mallin välille erillisen komponentin, joka ohjaa pyyntöjä näkymältä malliin ja mallilta näkymään. ASCII-kaaviona sovelluksen MVP näyttää seuraavalta:</p>

<pre>
               <em>kliksu</em>
                 ||
                 \/
                VIEW
                / /\
               /  /
              /  /
<em>ohjauspyyntö</em> /  /  <em>päivitys</em>
            /  /
           \/ /
        PRESENTER
            \  /\
             \  \
              \  \
    <em>muokkaus</em>   \  \   <em>muutos/tapahtuma</em>
                \  \
                 \  \
                 \/  \
                  MODEL
</pre>

   <p>Voimme muokata aiemmin tekemäämme muistutussovellusta seuraamaan MVP-mallia poistamalla mallilta riippuvuuden näkymään, ja lisäämällä kontrolleriin päivityksen tekemisen näkymälle. Käytännössä Presenter-oliolle tulisi lisätä myös tapahtumankuuntelija, jota model voisi kutsua tarvittaessa.</p>



   <h4>MVVM</h4>


   <p>MVVM on muunnos MVP:hen, jossa ViewModel on mallista valittua näkymää varten muokattu esitys käytössä olevasta datasta. ViewModel on kytkeytynyt näkymään näkymän tarjoaman funktion kautta. Kun ViewModelissa oleva data muuttuu, se kutsuu näkymän tarjoamaa funktiota siten, että näkymä päivittää itsensä ViewModel-olion pohjalta.</p>


<pre>
               <em>kliksu</em>
                 ||
                 \/
                VIEW
                / /\
               /  /
              /  /
<em>ohjauspyyntö</em> /  /  <em>tapahtumakutsu</em>
            /  /
           \/ /
        VIEWMODEL
            \  /\
             \  \
              \  \
    <em>muokkaus</em>   \  \   <em>muutos/tapahtuma</em>
                \  \
                 \  \
                 \/  \
                  MODEL
</pre>


    <h2>Valmiit JavaScript-kirjastot</h2>

    <p>Osa aiemmin toteuttamistamme ohjelmista ei toimi kaikilla nykyaikaisilla selaimilla. Osassa taas toistetaan samoja asioita uudestaan ja uudestaan. Yhteensopivuusongelmat johtuvat suurelta osin selainvalmistajien heikosta standardien seuraamisesta, ja innottomuudesta vanhempien selainten päivittämiseen. Selainohjelmistoja kehitettäessä tulee huomioida myös vanhempien selainten käyttäjät -- sovelluksen tilaajan määrittelemään pisteeseen asti.</p>

    <p>Selainohjelmistojen tekemiseen on huomattava määrä valmiita kirjastoja, joiden yksi tarkoitus on poistaa joidenkin selainten tietynlaiset JavaScript-syntaksin vaatimukset. Kirjastot tarjoavat myös apufunktioita toistuvan koodin ja toiminnallisuuden vähentämiseen. Mielenkiintoista JavaScript-kirjastojen ilmentymisessä on se, että JS-yhteisössä on havaittavissa samanlaista käyttäytymistä kuin palvelinpuolen yhteisöissä muutamia vuosia sitten.</p>

    <p><em>Kyllähän se kirjasto <strong>xxx</strong> on parempi kun se tekee tän yhdellä rivillä, sun softalla siihen menee seitsemän!</em> -- <em>hyi kun toi <strong>xxx</strong> näyttää raskaalta ja vaikealta käyttää, miksi siinä on noita tommosia turhia komentoja!</em></p>

   <p>Aivan kuten ohjelmointikielten tapauksessa, tietyt ohjelmistokirjastot sopivat joihinkin asioihin paremmin, toiset toisiin. Tutustutaan seuraavaksi tällä hetkellä -- vieläkin --  ehkäpä eniten käytettyyn JavaScript-kirjastoon, <a href="http://jquery.com/" target="_blank">jQueryyn</a>.</p>

    <h3>jQuery</h3>

    <p><a href="http://jquery.com/" target="_blank">jQuery</a> on JavaScript-kirjasto, jonka tarkoitus on helpottaa selainohjelmistojen toteutusta. Se tarjoaa tuen mm. DOM-puun muokkaamiseen, tapahtumien käsittelyyn sekä palvelimelle tehtäviin kyselyihin, ja sen avulla toteutettu toiminnallisuus toimii useimmissa selaimissa.</p>

    <p>Uusimman jQuery-version saa ladattua <a href="http://jquery.com/download/" target="_blank">täältä</a>. Käytännössä jQuery on JavaScript-tiedosto, joka ladataan sivun latautuessa. Tiedoston voi asettaa esimerkiksi <code>head</code>-elementin sisään, tai ennen omia lähdekooditiedostoja.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Selaimen palkissa ja suosikeissa näkyvä otsikko&lt;/title&gt;
     &lt;/head&gt;
    &lt;body&gt;

        &lt;!-- sivun sisältö --&gt;

        &lt;script src="javascript/jquery-2.1.3.min.js"&gt;&lt;/script&gt;
        &lt;script src="javascript/koodi.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>


    <h4>Valitsimet</h4>

    <p>Olemme tähän mennessä käyttäneet valmiita JavaScriptin DOM-toiminnallisuuksia. Elementtien etsimiseen on käytetty mm. Selectors APIn <code>querySelector</code>-kutsua, esimerkiksi komennolla <code>var elementti = document.querySelector("#nimi");</code> haetaan elementti, jonka tunnus on "nimi". JQuery käyttää <a href="http://sizzlejs.com/" target="_blank">Sizzle</a>-kirjastoa elementtien valinnan helpottamiseen. Esimerkiksi sivun elementti, jonka tunnus on "nimi", löytyy seuraavalla komennolla.</p>

<pre class="sh_javascript_dom">
var elementti = $("#nimi");
</pre>

    <p>Kyselyiden formaatti on siis <code>$("<em>kysely</em>")</code>, missä kysely on hyvin samankaltainen kuin aiemmin käyttämämme Selector APIn kyselyrajapinta. Vastaavasti kaikki <code>header</code>-elementissä olevat <code>a</code>-elementteihin löytyy komennolla.</p>

<pre class="sh_javascript_dom">
var elementit = $("header a");
</pre>

    <p>Myös tietyn luokan toteuttavien elementtien haku on helppoa. Alla olevassa esimerkissä on kolme tekstikenttää, joista 2 on piilotettu. Piilotettujen tekstikenttien tyyliluokka on <code>jquery-dom-1-hidden</code>.</p>

<style>
.jquery-dom-1-hidden {
    display: none;
}
</style>

<div class="naytto">
  <article class="jquery-dom-1">
    <p class="jquery-dom-1-hidden">text 1</p>
    <p>text 2</p>
    <p class="jquery-dom-1-hidden">text 3</p>
  </article>
</div>

    <div class="test-js">
      <p><textarea id="jquery-dom-1-js" rows="6" cols="80">var elementit = $(".jquery-dom-1-hidden");
for(var i = 0; i < elementit.length; i++) {
    elementit[i].className = "";
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('jquery-dom-1-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Huomaa, että koodi toimii, sillä jQuery on ladattu osaksi tätä sivua. Huomaa myös, että ylläolevan koodin voi tehdä huomattavasti tehokkaammin.</p>

<aside class="extra">
  <p><strong>jQueryn valitsimet</strong></p>

  <p>Tarkempi kuvaus jQueryn valitsimista löytyy osoitteesta <a href="http://api.jquery.com/category/selectors/" target="_blank">http://api.jquery.com/category/selectors/</a>.</p>
  <p>&nbsp;</p>
</aside>


    <h4>DOM-puun muokkaus</h4>

    <p>JQuery lisää DOM-puun elementteihin toiminnallisuuksia, jotka helpottavat DOM-puun muokkausta. Esimerkiksi metodi <code>removeClass</code> poistaa elementiltä tai kokoelmalta elementtejä halutun luokan. Alla on sama esimerkki kuin yllä, mutta nyt piilotettujen elementtien tyyliluokka on <code>jquery-dom-2-hidden</code>.</p>

<style>
.jquery-dom-2-hidden {
    display: none;
}
</style>

<div class="naytto">
  <article class="jquery-dom-2">
    <p class="jquery-dom-2-hidden">text 1</p>
    <p>text 2</p>
    <p class="jquery-dom-2-hidden">text 3</p>
  </article>
</div>

    <div class="test-js">
      <p><textarea id="jquery-dom-2-js" rows="4" cols="80">var elementit = $(".jquery-dom-2-hidden");
elementit.removeClass("jquery-dom-2-hidden");</textarea></p>
      <p><input type="button" onclick="evalElementContent('jquery-dom-2-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Yllä olevassa esimerkissä haetaan kaikki elementit, joiden tyyliluokka on "jquery-dom-2-hidden", ja poistetaan niiltä haluttu tyyli. Koska uudet toiminnallisuudet on lisätty elementteihin, voidaan kyselyt myös ketjuttaa. Alla haetaan ensin kaikki elementit, joiden tyyliluokka on <code>jquery-dom-3-hidden</code>, jonka jälkeen haluttu tyyliluokka poistetaan.</p>

<style>
.jquery-dom-3-hidden {
    display: none;
}
</style>

<style>
.hidden {
    display: none;
}
</style>


<div class="naytto">
  <article class="jquery-dom-3">
    <p class="jquery-dom-3-hidden">text 1</p>
    <p>text 2</p>
    <p class="jquery-dom-3-hidden">text 3</p>
  </article>
</div>

    <div class="test-js">
      <p><textarea id="jquery-dom-3-js" rows="2" cols="80">$(".jquery-dom-3-hidden").removeClass("jquery-dom-3-hidden");</textarea></p>
      <p><input type="button" onclick="evalElementContent('jquery-dom-3-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Kyselyiden avulla voidaan luoda myös monimutkaisen näköisiä rakenteita. Alla haetaan kaikki <code>body</code>-elementin sisällä olevat solmut, joilla ei ole tunnusta "jquery-dom-4-js-esim", ja jotka eivät ole sen alla olevia <code>textare</code> tai <code>input</code>-elementtejä. Kun solmut on haettu, solmuille lisätään tyyliluokka "hidden".</p>

    <div class="test-js" id="jquery-dom-4-js-esim">
      <p><textarea id="jquery-dom-4-js" rows="2" cols="80">$("body > :not(#jquery-dom-4-js-esim,#jquery-dom-4-js-esim textarea,#jquery-dom-4-js-esim input)").addClass("hidden");</textarea></p>
      <p><input type="button" onclick="evalElementContent('jquery-dom-4-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Jos klikkaat ylläolevaa nappia, joutunet lataamaan sivun uudestaan tai muokkaamaan sivua konsolista, jotta saat sivun takaisin näkyville.</p>


<aside class="extra">
  <p><strong>DOM-puun muokkaus</strong></p>

  <p>Tarkempi kuvaus operaatioista DOM-puun muokkaamiseen löytyy osoitteesta <a href="http://api.jquery.com/category/Manipulation/" target="_blank">http://api.jquery.com/category/Manipulation/</a>.</p>
  <p>&nbsp;</p>

</aside>


    <h4>Tapahtumien käsittely</h4>

    <p>JQuery rakentaa JavaScriptin valmiiden komponenttien päälle, joten sillä on toiminnallisuus myös tapahtumankäsittelijöiden rekisteröimiseen sivun komponenteille. Tutkitaan seuraavaa jo tutuhkoa HTML-dokumenttia. </p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;title&gt;Kindler&lt;/title&gt;
        &lt;link rel="stylesheet" href="style.css" type="text/css" &gt;
    &lt;/head&gt;
    &lt;body onload="init();"&gt;
        &lt;header&gt;
            &lt;h1&gt;Kindler&lt;/h1&gt;

            &lt;nav&gt;
                &lt;a href="#"&gt;Eka artikkeli&lt;/a&gt;
                &lt;a href="#"&gt;Toka artikkeli&lt;/a&gt;
                &lt;a href="#"&gt;Kolmas artikkeli&lt;/a&gt;
            &lt;/nav&gt;
        &lt;/header&gt;

        &lt;section&gt;
          &lt;article&gt;
            &lt;h1&gt;Eka artikkeli&lt;/h1&gt;

            &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit...&lt;/p&gt;
          &lt;/article&gt;

          &lt;article&gt;
            &lt;h1&gt;Toka artikkeli&lt;/h1&gt;

            &lt;p&gt;Morbi a elit enim, sit amet iaculis massa. Vivamus blandit...&lt;/p&gt;
          &lt;/article&gt;

          &lt;article&gt;
            &lt;h1&gt;Kolmas artikkeli&lt;/h1&gt;

            &lt;p&gt;Now that we know who you are, I know who I am. I'm...&lt;/p&gt;
          &lt;/article&gt;
        &lt;/section&gt;

        &lt;!-- lähdekooditiedostojen lataus --&gt;
        &lt;script type="text/javascript" src="javascripts/jquery-2.1.3.min.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="javascripts/koodit.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Olemme aiemmin määritelleet tapahtumankäsittelyn osana HTML-dokumenttia siten, että JavaScript-kutsut on lisätty erillisessä init-metodissa (unohdamme MVC-mallin hetkeksi esimerkin yksinkertaistamiseksi). Alla oleva lähdekoodi käyttää aiemmin oppimaamme <code>querySelector</code>-toteutusta siihen, että tapahtumankäsittelijät lisätään vain menuvalikon linkkeihin. Kutsu <code>preventDefault()</code> estää linkin seuraamisen.</p>

<pre class="sh_javascript_dom">
function init() {
    var navLinks = document.querySelectorAll("header nav a");
    for(var i = 0; i < navLinks.length; i++) {
        var link = navLinks[i];

        // lisätään elementille id, josta päätellään näytettävä artikkeli
        link.id = i;

        // lisätään tapahtumankuuntelija tapahtumalle click. huom! ero onclick-attribuuttiin
        link.addEventListener('click', function(eventInformation) {
            var origin = eventInformation.target;

            // kutsutaan erillistä displayArticle-funkiota, joka
            // näyttää halutun artikkelin
            displayArticle(origin.id);

            // kielletään selainta tekemästä oletustoiminto (siirtyminen)
            eventInformation.preventDefault();
        }, false);
    }

    // ...
}

function displayArticle(index) {
    var articles = document.getElementsByTagName("article");

    for(var i = 0; i < articles.length; i++) {
        if (index == i) {
            articles[i].className='';
        } else {
            articles[i].className='hidden';
        }
    }
}
</pre>


    <p>Muokataan ylläolevaa esimerkkiä siten, että käytämme JQueryä.</p>

    <p>Muokataan ensin funktio <code>displayArticle</code> toiminnallisuutta. Toteutetaan se siten, että funktiokutsussa piilotamme aina ensin kaikki artikkelit, jonka jälkeen näytämme indeksin määräämän artikkelin. Valitsimella ":eq(<em>indeksi</em>)" voimme valita elementin tietystä indeksistä.</p>

<pre class="sh_javascript_dom">
function displayArticle(index) {
    $("article").addClass("hidden");
    $("article:eq(" + index + ")").removeClass("hidden");
}
</pre>

    <p>Lähdetään seuraavaksi pilkkomaan function <code>init</code>-toiminnallisuutta. Asetetaan funktion <code>init</code> toiminnallisuus ensin <code>$(document).ready(function(){    });</code>-lohkon sisään. Lohkon sisältö suoritetaan kun sivun lataaminen on valmis -- emme enää tarvitse <code>body</code>-elementin <code>onload</code>-attribuuttia. Koodi näyttää nyt seuraavalta:</p>

<pre class="sh_javascript_dom">
$(document).ready(function(){
    var navLinks = document.querySelectorAll("header nav a");
    for(var i = 0; i < navLinks.length; i++) {
        var link = navLinks[i];

        // lisätään elementille id, josta päätellään näytettävä artikkeli
        link.id = i;

        // lisätään tapahtumankuuntelija tapahtumalle click. huom! ero onclick-attribuuttiin
        link.addEventListener('click', function(eventInformation) {
            var origin = eventInformation.target;

            // kutsutaan erillistä displayArticle-funkiota, joka
            // näyttää halutun artikkelin
            displayArticle(origin.id);

            // kielletään selainta tekemästä oletustoiminto (siirtyminen)
            eventInformation.preventDefault();
        }, false);
    }

    // ...
});

function displayArticle(index) {
    $("article").addClass("hidden");
    $("article:eq(" + index + ")").removeClass("hidden");
}
</pre>

    <p>Luodaan ensin toiminnallisuus, jolla linkkeihin asetetaan tunnus-attribuutit. JQueryssä on kätevä kokoelman iterointiin tarkoitettu <code><a href="http://api.jquery.com/each/" target="_blank">each</a></code>-komento, joka saa JQueryltä parametrinaan iteroitavan elementin indeksin. Muuttuja <code>$(this)</code> viittaa kyseisellä hetkellä läpikäytävään muuttujaan. Allaoleva komento käy läpi jokaisen linkki-elementin, ja kutsuu kullekin <code>each</code>-komennolle parametrina antamaamme funktiota. Komento <code>attr</code> asettaa (tai hakee jos toista parametria ei määritellä) elementin komennossa määritellyn attribuutin.</p>

<pre class="sh_javascript_dom">
$("header nav a").each(function(index) {
    $(this).attr("id", index);
});
</pre>


    <p>Lisätään seuraavaksi jokaiselle linkille tapahtumankäsittelijä. Komento <code><a href="http://api.jquery.com/click/" target="_blank">click</a></code> auttaa tässä huomattavasti. Voimme hyödyntää myös aiemmin huomaamaamme <code>each</code>-komentoa. Alla lisäämme jokaiseen linkkiin funktion, joka kuuntelee klikkausta. Funktion sisältö lienee tuttu.</p>

<pre class="sh_javascript_dom">
$("header nav a").each(function(index) {
    $(this).click(function(eventInformation) {
        displayArticle(eventInformation.target.id);
        eventInformation.preventDefault();
    });
});
</pre>


    <p>Each-komento tarjoaa meille indeksin, joten muokataan edellistä vielä hieman. Käytetään suoraan each-komennon tarjoamaa indeksiä artikkelin näyttämiseen.</p>

<pre class="sh_javascript_dom">
$("header nav a").each(function(index) {
    $(this).click(function(eventInformation) {
        displayArticle(index);
        eventInformation.preventDefault();
    });
});
</pre>

    <p>Huomaamme vielä, että voimme yhdistää linkin tunnuksen lisäämisen ja tapahtumankäsittelyn lisäämisen saman <code>each</code>-komennon sisään.</p>

<pre class="sh_javascript_dom">
$("header nav a").each(function(index) {
    $(this).attr("id", index);
    $(this).click(function(eventInformation) {
        displayArticle(index);
        eventInformation.preventDefault();
    });
});
</pre>


    <p>Koodimme näyttää nyt kokonaisuudessaan seuraavalta:</p>

<pre class="sh_javascript_dom">
$(document).ready(function(){

    // sattumalta saa parametrina indeksin
    $("header nav a").each(function(index) {
        $(this).attr("id", index);
        $(this).click(function(eventInformation) {
            displayArticle(index);
            eventInformation.preventDefault();
        });
    });
});

function displayArticle(index) {
    $("article").addClass("hidden");
    $("article:eq(" + index + ")").removeClass("hidden");
}
</pre>

    <p>HTML-dokumentista on myös poistettu <code>body</code>-elementin <code>onload</code>-attribuutti.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;title&gt;Kindler&lt;/title&gt;
        &lt;link rel="stylesheet" href="style.css" type="text/css" &gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;!-- sama sisältö kuin aiemminkin --&gt;

        &lt;script type="text/javascript" src="javascripts/jquery-2.1.3.min.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="javascripts/koodit.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>


<div class="tehtavat">
  <h3>JQueryMOOC</h3>

  <p>Muokkaa tehtäväpohjan mukana tulevaa MOOC-sivua siten, että elementtien näyttäminen ja piilottaminen toteutetaan JQueryn tarjoamien apuvälineiden avulla.</p>

  <p>Poista lopulta myös turhaksi tullut myös turha body-elementin onload-attribuutti.</p>

  <p>Kun olet vaihtanut toteutuksen JQueryksi, ja toteutuksen toiminnallisuus on ennallaan, palauta tehtävä TMC:lle.</p>

  <p>Joudut myös hakemaan jQueryn -- joko käsin jQueryn sivuilta, tai ottamalla selvää siitä, miten NetBeansin avulla lisätään kirjastoja projektiin.</p>

</div>


    <h4>Kyselyt palvelimelle</h4>

    <p>JQuery tarjoaa myös tuen kyselyjen tekemiseen erilliselle palvelinkomponentille.</p>

    <p>Kyselyt hoituvat kätevästi JQueryn <code><a href="http://api.jquery.com/jQuery.getJSON/" target="_blank">$.getJSON</a></code>-funktiolla. Alla olevassa esimerkissä haemme <a href="http://www.icndb.com/" target="_blank">ICNDb.com</a>ista oleellista dataa.</p>

    <p>Kyselyn palauttama data ohjataan <code>$.getJSON</code>-funktion toisena parametrina määriteltävään funktioon. Alla olevassa esimerkissä kutsumme vain <code>console.log</code>-komentoa kaikelle palautettavalle datalle.</p>

<pre class="sh_javascript_dom">
$.getJSON("http://api.icndb.com/jokes/random/5",
    function(data) {
        console.log(data);
    }
);
</pre>

    <p>Ylläoleva esimerkki tulostaa vastaukset konsoliin -- huomaa, että jQuery muuntaa merkkijonomuotoiset vastaukset automaattisest JSON-olioksi. Käytetään JQueryn <code>each</code>-komentoa listassa olevien elementtien iterointiin. Komennolle <code>each</code> voi antaa parametrina iteroitavan listan, sekä funktion, jota kutsutaan jokaisella listassa olevalla oliolla.</p>

<pre class="sh_javascript_dom">
$.getJSON("http://api.icndb.com/jokes/random/5",
    function(data) {
        $.each(data.value, function(i, item) {
            console.log(i);
            console.log(item);
            console.log("-----");
        });
    }
);
</pre>

    <p>Nyt ylläoleva komento tulostaa vastauksen value-kentässä olevat oliot yksitellen. Oletetaan, että käytössämme on elementti, jonka tunnus on "vitsit". JQuery tarjoaa myös mahdollisuuden nopeaan tekstielementtien luontiin komennolla <code>$("&lt;p/&gt")</code>. Elementteihin voi asettaa tekstin <code>text</code>-komennolla, ja elementin voi lisätä tietyllä tunnuksella määriteltyyn elementtiin komennolla <code>appendTo("#<em>tunnus</em>")</code>.</p>

<pre class="sh_javascript_dom">
$.getJSON("http://api.icndb.com/jokes/random/5",
    function(data) {
        $.each(data.value, function(i, item) {
            $("&lt;p/&gt;").text(item.joke).appendTo("#vitsit");
        });
    }
);
</pre>

    <p><strong>XMLHttpRequest</strong></p>

    <p>Jos tiedämme, että palvelu palauttaa JSON-dataa, voimme käyttää yllä käsiteltyä lähestymistapaa. Esimerkiksi viestien noutaminen Chat-chat -tehtävän viestipalvelimelta onnistuu seuraavalla komennolla. Tässä tapauksessa lisäämme jokaiseen viestiin liittyvän <code>message</code>-attribuutin "vitsit"-tunnuksella määriteltyyn elementtiin.</p>

<pre class="sh_javascript_dom">
$.getJSON("http://bad.herokuapp.com/app/messages", function(data) {
    $.each(data, function(i, item) {
        $("&lt;p/&gt;").text(item.message).appendTo("#vitsit");
    });
});
</pre>

    <p>Yllä oleva komento on lyhenne alla määritellystä komennosta.</p>

<pre class="sh_javascript_dom">
$.ajax({
    url: "http://bad.herokuapp.com/app/messages",
    dataType: 'json',
    success: parseMessages
});

function parseMessages(messages) {
    $.each(messages, function(i, item) {
        $("&lt;p/&gt;").text(item.message).appendTo("#vitsit");
    });
}
</pre>

    <p>Komennolle <code><a href="http://api.jquery.com/jQuery.ajax/" target="_blank">$.ajax</a></code> voi lisätä myös dataa, mitä lähetetään palvelimelle. Esimerkiksi seuraavalla komennolla lähetetään osoitteeseen <code>http://bad.herokuapp.com/app/in</code> olio, jonka sisällä on attribuutit <code>name</code> ja <code>details</code>. Lähetettävän datan tyyppi asetetaan attribuutilla <code>contentType</code>, alla ilmoitamme että data on json-muotoista, ja että se käyttää utf-8 -merkistöä. </p>

<pre class="sh_javascript_dom">
var dataToSend = JSON.stringify({
        name: "bob",
        details: "i'm ted"
    });

$.ajax({
    url: "http://bad.herokuapp.com/app/in",
    dataType: 'json',
    contentType:'application/json; charset=utf-8',
    type: 'post',
    data: dataToSend
});
</pre>

    <p>Pyynnössä voi sekä lähettää että vastaanottaa dataa. Attribuutin <code>success</code> asettaminen ylläolevaan pyyntöön aiheuttaa success-attribuutin arvona olevan funktion kutsun kun pyyntö on onnistunut.</p>

<div class="tehtavat">
  <h3>JQuerySpoilaajanBackend</h3>

  <p>Toteuta Spoilaajan Backend-tehtävä tässä JQueryn avulla. Jos hyödynsit aiemmin synkronisia kutsuja, kannattaa hyödyntää niitä myös tässä. Vinkki: <code>$.ajax</code>-komennolle voi asettaa attribuutin <code>async: false</code>, jolloin tulee määritellä <code>success</code>-attribuutille funktio, jota kutsutaan kun data on noudettu.</p>

  <p>Joudut myös hakemaan jQueryn -- kannattanee viimeistään tässä vaiheessa ottaa selvää siitä, miten NetBeansin avulla lisätään kirjastoja projektiin.</p>

</div>


    <h3>Näkymätemplatet ja Mustache.js</h3>

    <p>Selainohjelmistojen rakennetta suunniteltaessa yksi huolenaihe on sivun näkymien järkevä hallinta. Aiemmin näkemässämme esimerkissä sivun osia piilotetaan ja näytetään dynaamisesti, toisaalta, olemme myös generoineet HTML-koodia Javascriptin sisältä. Tässä olemme huomanneet että generointi on auttamatta työlästä.</p>

    <p>Näkymätemplatet ovat HTML-koodipätkiä, jotka sisältävät halutun HTML-rakenteen sekä paikat datalle. Eräs projekti näkymätemplatejen generointiin on <a href="https://github.com/janl/mustache.js" target="_blank">Mustache.js</a>, joka on <a href="http://mustache.github.com/" target="_blank">mustache</a>-projektin osa.</p>

    <p>Käytännössä näkymätemplatejen käyttö toimii siten, että HTML-dokumenttiin piilotetaan osa, joka sisältää kaikki HTML-templatet. Kun käyttäjä esimerkiksi klikkaa linkkiä, renderöidään näkyvälle alueelle templaten ja datan pohjalta uusi sisältö. Tutkitaan alla olevaa esimerkkiä, jossa on osio tunnuksella "view", ja toinen <em>script</em>-tägillä merkitty osio, joka sisältää templatet. Script-tägillä merkityt osiot eivät renderöidy selaimelle.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;section id="view"&gt;&lt;/section&gt;

        &lt;script id="template" type="text/html"&gt;
            &lt;article&gt;
                &lt;h2&gt;{{nimi}} {{ika}}&lt;/h2&gt;
            &lt;/article&gt;
        &lt;/script&gt;

        &lt;!-- lähdekooditiedostojen lataus --&gt;
        &lt;script type="text/javascript" src="javascripts/jquery-2.1.3.min.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="javascripts/mustache.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="javascripts/koodi.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Lähdekooditiedosto <code>koodi.js</code> sisältää seuraavanlaisen lähdekoodin.</p>

<pre class="sh_javascript_dom">
$(document).ready(function() {
    var data = {
        nimi: "Bob",
        ika: function() {
            return 14+7;
        }
    };

    var html = Mustache.render($("#template").html(), data);
    $("#view").html(html);
});
</pre>

    <p>Tutkitaan koodia hieman tarkemmin. Komennolla <code>$(document).ready(function() { ... });</code> määritellään toiminnallisuus, joka suoritetaan kun sivu on latautunut. Toiminnallisuus sisältää <code>data</code>-olion luomisen, jolla on attribuutit nimi (arvo "Bob") ja ika (funktion palauttama arvo).</p>

    <p>Tämän jälkeen oleva koodi ei olekaan vielä tuttua. JQuery tarjoaa pääsyn elementin html-koodiin komennolla <code><a href="http://api.jquery.com/html/" target="_blank">html</a></code>, eli komento <code>$("#template").html()</code> palauttaa tunnuksella "template" merkityn elementin sisältämän HTML-koodin. Tämä koodi annetaan Mustachen <code>render</code>-komennolle yhdessä data-olion kanssa. Mustachen <code>render</code>-komento asettaa olion datan sisällön HTML-koodissa <code>{{avain}}</code>-notaatiolla merkityille paikoille, ja palauttaa uuden merkkijonon. Merkkijono sisältää HTML-koodin, jossa merkittyihin kohtiin on asetettu datasta saadut arvot.</p>

      <p>Lopuksi html-koodi asetetaan tunnuksella "view" määritellyn elementin sisään.</p>

      <h4>Listojen läpikäynti</h4>

      <p>Listojen läpikäynti onnistuu {{#<em>muuttuja</em>}}-operaattorilla, joka aloittaa läpikäynnin. Läpikäynnin lopetus tapahtuu {{/<em>muuttuja</em>}}-operaattorilla. Esimerkiksi alla on määritelty <code>messages</code>-attribuutissa olevien olioiden läpikäynti siten, että jokaiselta oliolta kutsutaan attribuuttia <code>nickname</code> ja <code>message</code>.</p>

<pre class="sh_html">
&lt;script id="template"&gt;
     &lt;article&gt;
         {{#messages}}
             &lt;p&gt;&lt;strong&gt;{{nickname}}:&lt;/strong&gt; {{message}}&lt;/p&gt;
         {{/messages}}
    &lt;/article&gt;
&lt;/script&gt;
</pre>

    <p>Voimme kytkeä ylläolevan templaten helposti Chat-chat -tehtävän viestit hakevaan palveluun.</p>

<pre class="sh_javascript_dom">
function parseMessages(messages) {
    var data = {
        messages: messages
    };

    var html = Mustache.render($("#template").html(), data);
    $("#view").html(html);
}

$(document).ready(function() {
    $.ajax({
        url: "http://bad.herokuapp.com/app/messages",
        dataType: 'json',
        success: parseMessages
    });
});
</pre>

    <p>Ehkäpä tärkein muistettava ylläolevassa esimerkissä on se, että data tulee antaa Mustachelle olion sisällä. Jos render-komentoa kutsutaan suoraan messages-oliolla, joka sisältää listan chat-viestejä, ei Mustache tiedä miten toimia.</p>

<div class="tehtavat">

  <h3>Movemberia odoteltaessa (2p)</h3>

  <p>Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että näkymä generoidaan tarvittaessa HTML-templateista. Tiedostossa <code>code.js</code> olevaan muuttujaan <code>data</code> on asetettu valmiiksi HTML-dokumentin oleelliset.</p>

  <p>Tehtävänäsi on muokata tiedostoa <code>index.html</code> siten, että se sisältää template-elementin, jonka pohjalta sivun näkymiä (perusmooc, materiaali, ...) voidaan luoda. </p>

  <p>Muokkaa myös tiedostoa <code>code.js</code> siten, että kukin näkymä generoidaan aina linkkiä klikattaessa. Generoitu näkymä tulee asettaa osaksi näkymäaluetta, jonka joudut myös luomaan. Kannattaa hyödyntää aiemmin tekemääsi JQueryMOOC-pohjaa.</p>

  <p>Etsi myös JQuery ja Mustache.js projektiisi.</p>

</div>

    <h4>Case: Henkilötiedot</h4>

    <p>Rakennetaan sovellus, jossa käyttäjä voi etsiä henkilöitä ja katsoa yksittäisen henkilön tietoja. Henkilöiden etsiminen tapahtuu kirjoittamalla tekstikenttään osa henkilön nimestä, tai henkilön nimi kokonaan. Henkilön nimeä kirjoitettaessa sovellus ehdottaa vaihtoehtoja. Kun oikea vaihtoehto löydetään, käyttäjä voi klikata nimeä ja katsoa henkilöön liittyviä tietoja.</p>

    <p>Käytössämme on seuraavanlainen datajoukko.</p>

<pre class="sh_javascript_dom">
var data = [{ "id": 1, "name": "homer", "age": 44 },
  { "id": 2, "name": "bart", "age": 12 },
  { "id": 3, "name": "maggie", "age": 4 },
  { "id": 4, "name": "lisa", "age": 10 },
  { "id": 5, "name": "marge", "age": 43 },
  { "id": 6, "name": "abraham", "age": 85 },
  { "id": 7, "name": "mona", "age": 81 },
  { "id": 8, "name": "amber", "age": 51 }]
</pre>

    <p><strong>Henkilöiden listaaminen</strong></p>

    <p>Jotta henkilöä voi etsiä, tulee sovelluksessa olla tekstikenttä nimen täyttämiseen, sekä alue henkilöiden näyttämiseen. Luodaan sovellukselle elementit etsimiseen ja tulosten listaamiseen.</p>

<pre class="sh_html">
&lt;section&gt;
    &lt;input type="text" id="searchbox"/&gt;
&lt;/section&gt;

&lt;section id="resultview"&gt;&lt;/section&gt;
</pre>

    <p>Tunnuksella <code>searchbox</code> merkittyä elementtiä käytetään tekstin syöttämiseen, ja tunnuksella <code>resultview</code> merkittyä elementtiä tulosten näyttämiseen. Luodaan aivan ensin toiminnallisuus datajoukon näyttämiseen osana tuloslistaa. Käytetään tähän templatea.</p>

<pre class="sh_html">
&lt;script id="searchresulttemplate" type="text/html"&gt;
    {{#list}}
    &lt;p&gt;{{name}}&lt;/p&gt;
    {{/list}}
&lt;/script&gt;
</pre>

    <p>Yllä oleva template käy listan nimeltä <code>list</code> läpi siten, että se tulostaa jokaisen listalla olevan elementin attribuutin <code>name</code> <code>p</code>-elementin sisään. Käytännössä sille tulee siis antaa olio, jolla on attribuutti <code>list</code>, jotta se voi tulostaa alkiot.</p>

<pre class="sh_javascript_dom">
var data = [{ "id": 1, "name": "homer", "age": 44 },
  { "id": 2, "name": "bart", "age": 12 },
  { "id": 3, "name": "maggie", "age": 4 },
  { "id": 4, "name": "lisa", "age": 10 },
  { "id": 5, "name": "marge", "age": 43 },
  { "id": 6, "name": "abraham", "age": 85 },
  { "id": 7, "name": "mona", "age": 81 },
  { "id": 8, "name": "amber", "age": 51 }]

// huom! attribuutti list sisältää datan
var dataForTemplate = {
  list: data
}
</pre>

    <p>Luodaan toiminnallisuus, jonka avulla lista näytetään kun käyttäjä on kirjoittanut jotain tekstialueeseen. Käytetään tähän <code>keyup</code>-komentoa.</p>

<pre class="sh_javascript_dom">
$(document).ready(function() {
    $("#searchbox").keyup(function() {
      showdata();
    });
});
</pre>

    <p>Funktio <code>showdata</code> näyttää datan sivulla. Luodaan aivan ensiksi funktio, joka näyttää aina koko datan. Jotta datan renderöinti onnistuu aiemmin määrittelemämme templaten avulla, tulee data asettaa erillisen olion attribuutin list arvoksi.</p>

<pre class="sh_javascript_dom">
function showdata() {
  var dataForTemplate = {
    list: data
  }

  // renderöidään tulokset mustachen avulla
  var html = Mustache.render($("#searchresulttemplate").html(), dataForTemplate);
  // näytetään tulokset
  $("#resultview").html(html);
}
</pre>

    <p>Nyt sivumme näyttää tulokset.</p>

    <p><strong>Henkilöiden filtteröinti</strong></p>

    <p>Toteutetaan seuraavaksi henkilöiden filtteröinti. Filtteröinnin toteutus onnistuu helpohkosti käyttämällä edellä olevaa lähestymistapaa, ja muokkaamalla muuttujaa <code>dataForTemplate</code> JQueryn valmiin <code><a href="http://api.jquery.com/jQuery.grep/" target="_blank">grep</a></code>-komennon avulla. Komennolle grep annetaan parametrina funktio, joka saa grep-komennolta sille parametrina annetusta listasta aina yksittäisen alkion ja sen indeksin. Funktion tulee palauttaa arvo true tai false riippuen siitä halutaanko alkio säilyttää. Alla olevassa esimerkissä tarkistetaan onko parametrina saadun alkion attribuutti nimi "Mikke".</p>

<pre class="sh_javascript_dom">
data = $.grep(data, function(element, index) {
  return element.name === "Mikke";
});
</pre>

    <p>Omassa toteutuksessamme haluamme etsiä henkilöä, jonka nimessä on <code>searchbox</code>-elementissä oleva arvo. Koska käsittelemämme lista on muuttujan <code>dataForTemplate</code> attribuutti, annetaan grep-komennolla parametrina kyseinen attribuutti.</p>

<pre class="sh_javascript_dom">
function showdata() {
  var dataForTemplate = {
    list: data
  }

  // filtteröinti
  var mustContain = $("#searchbox").val();
  dataForTemplate.list = $.grep(dataForTemplate.list, function(person, index) {
    return person.name.indexOf(mustContain) != -1;
  });

  // renderöidään tulokset mustachen avulla
  var html = Mustache.render($("#searchresulttemplate").html(), dataForTemplate);
  // näytetään tulokset
  $("#resultview").html(html);
}
</pre>


<aside class="extra">
  <p><strong>Cannot call method 'search' of undefined</strong></p>

  <p>Jos Mustache näyttää virheen "Uncaught TypeError: Cannot call method 'search' of undefined", tarkista aivan ensin että olet asettanut templatejen tunnukset oikein. Virhe "TypeError: this.tail.search is not a function" viittaa taas usein käytettävän templaten sisällön ja datan sisällön epäjohdonmukaisuuteen -- tarkista tässä myös että annat <em>oikeasti</em> html:ää Mustachelle..</p>

  <p>&nbsp;</p>
</aside>


<div class="tehtavat">

  <h3>Kirjahaku (2p)</h3>

  <p>Toteuta aiempaa esimerkkiä seuraten toiminnallisuus kirjojen hakemiseen. Kirjojen haun tulee tapahtua tehtäväpohjassa tulevan JSON-datan sisältämien olioiden <em>title</em>-kentän perusteella.</p>

  <p>Toimivassa sovelluksessa on hakukenttä sekä lista kirjoja. Kun hakukenttään kirjoitetaan kirjan nimi tai sen osa, tulee listauksessa olevien kirjojen päivittyä siten, että listalla näytetään vain kirjat, jotka osuvat hakusanaan. Toteuta hakutoiminnallisuudesta sellainen, että kirjainten suuruudella (tai pienuudella) ei ole väliä.</p>

  <p>Kannattanee noutaa myös oleelliset javascript-kirjastot projektiin.</p>

</div>


</section>



<section class="week">
  <header>
    <a name="viikko4"></a>
    <h1 data-week-id="4">Viikko 4</h1>
  </header>

  <h2>Debuggerin käyttö Chromessa</h2>
  <p>JavaScript-koodia voi debugata monella eri tavalla, esim. tulostamalla muuttujien arvoja console.log() komennolla selaimen konsoliin. Tämä tapa on hyvä ja toimiva, mutta voi monesti olla hieman raskasta kirjoitella usealle eri muuttujalle eri puolille sovellusta omia logituksia.</p>
  <p>Eräs toinen tapa on käyttää debuggeria. Sen käyttö on hyvin yksinkertaista. JavaScript-koodiin kirjoitetaan haluttuun kohtaan <code>debugger;</code>. Kun selain suorittaa kyseisen rivin koodista, koodin suorittaminen keskeytyy.</p>
  <p>Kun suoritus on keskeytynyt, voidaan konsolissa tutkailla sillä hetkellä näkyvissä olevien muuttujien arvoja. Oletuksena Chrome avaa debuggeriin törmätessään dev-työkaluissa <code>Sources</code>-välilehden ja korostaa rivin, jolla <code>debugger;</code> pysäytti koodin suorittamisen:</p>
  <img src="img/chrome-source.png" style="width: 800px; height: auto" />
  <p>Avaamalla <code>Console</code>-välilehden, voi kyseisen for-loopin muuttujien arvoja tutkia kirjoittamalla muuttujien nimiä aktiivisena olevalle tekstikentälle konsolin alaosassa:</p>
  <img src="img/chrome-console.png" style="width: 600px; height: auto" />
  <p>Mikäli edellä mainitussa for-loopissa ensimmäisen kierroksen arvot eivät ole debuggauksen kannalta oleellisia, voi koodia suorittaa askel askeleelta eteenpäin kunnes ollaan sellaisessa tilassa, josta arvoja halutaan tarkastella:</p>
  <img src="img/chrome-debugger.png" style="width: 200px; height: auto" />
  <p>Kuvan vasemman puoleinen nappi jatkaa koodin suorittamista normaaliin tapaan ja oikean puolinen nappi mahdollistaa koodin suorituksen askel kerrallaan eteenpäin.</p>
  <p>Aiheesta voi lukea lisää osoitteesta <a href="https://developer.chrome.com/devtools/docs/javascript-debugging">https://developer.chrome.com/devtools/docs/javascript-debugging</a></p>

  <h2>Sovelluksen rakenteen hallinta: AngularJS</h2>
  <p>Olemme tähän mennessä onnistuneesti pystyneet esittämään sovelluksemme dataa käyttöliittymässä ja jopa välittämään käyttöliittymästä tehtyjä muutoksia sovelluslogiikkaan. Mustache tekee datan esittämisestä näkymässä melko helppoa, mutta kuten olet ehkä huomannut, datan muokkaaminen näkymän kautta ei ole aivan niin helppoa. Ongelmat ilmenevät etenkin sovelluksen kasvaessa, jolloin sen rakenteesta tulee aina vain sekavampi. Rakennetta selkeyttää huomattavasti käyttöliittymän erottaminen sovelluksen datasta, johon jo mainittu MVC-arkkitehtuuri pyrkiikin. Selkeän MVC-arkkitehtuurin aikaansaaminen on kuitenkin yllättävän vaikeaa, jos työkalut eivät ole oikeat.</p>
  <p>
    Apuun tulee suuren suosion saavuttanut <a href="https://angularjs.org/" target="_blank">AngularJS</a> MVW-sovelluskehys. Edellisessä lauseessa ei ole kirjoitusvirhettä, Angularia ei voi rajata pelkäksi MVC-sovelluskehykseksi (vaikkakin niin usein tehdään), vaan tarkempi termi onkin "Model View Whatever". Se siis esittää mallia näkymässä ja välittää näkymässä tehtyjä muutoksia takaisin malliin. Mitä mallin ja näkymän rajapinnassa tapahtuu, on ohjelmoijan itsensä päätettävissä.
  </p>
  <p>
    Mikä Angularissa on hienoa, on se, että se tekee luonteeltaan staattisesta HTML:stä dynaamista, jolloin malli on sekä helppo esittää näkymässä, että helppo muokata näkymän kautta. Otetaan pieni esimerkki, joka havainnollistaa, kuinka paljon voimme saada aikaan kirjoittamatta riviäkään JavaScriptiä:
  </p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div ng-app&gt;
      &lt;h1&gt;Hello {{name}}!&lt;/h1&gt;
      &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Huomaat ensimmäiseksi, että Angularissa ja Mustachessa on sama syntaksi muuttujan upottamiseksi näkymään, eli <code>{{muuttuja}}</code>. Esimerkissä olemme upottaneet näkymäämme muuttujan <code>name</code>. Muuttuja ei ole vielä määritelty, joten näkymässä on pelkästään otsikko "Hello !". Otsikon alapuolella on tekstikenttä, jolle on määritelty attribuutti <code><a href="https://docs.angularjs.org/api/ng/directive/ngModel" target="_blank">ng-model</a></code>, jonka arvo on <code>name</code>. Tämä tarkoittaa sitä, että olemme sitoneet tekstikentän arvon muuttujaan <code>name</code>. Siis, jos muutamme tekstikentän arvoa, myös otsikon sisältö muuttuu. Tulemme myös myöhemmin huomaamaan, että jos muutamme muuttujan <code>name</code> arvoa sovelluslogiikassa, muuttuu myös tekstikentän arvo. Tämän yksinkertaiselta kuulostavan toiminnon toteuttaminen käyttämällä jQuerya ja Mustachea olisi helposti vienyt näin monta riviä koodia:
</p>
<pre class="sh_javascript_dom">
var name = "";

function renderHeading(){
  var html = Mustache.render('Hello {{name}}!', { name: name });
  $('h1').html(html);
}

$(document).ready(function(){
  renderHeading();

  $('input[type="text"]').on('keyup', function(){
    name = $(this).val();
    renderHeading();
  });
});
</pre>
<p>
  Kokeile Angularilla toteutetua esimerkkiä vielä itse:
  <iframe width="100%" height="300" src="http://jsfiddle.net/HB7LU/10885/embedded/result,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</p>
<h3>Kontrollerit</h3>
<p>
  Kuten on jo mainittu, kontrolleri on MVC-arkkitehtuurissa mallin ja näkymän yhdistävä tekijä. Se siis välittää esitettävän datan mallilta näkymälle ja muokkaa mallia näkymän pyynnöstä. Katsotaan, miten voimme liittää edelliseen esimerkkiimme kontrollerin käyttämällä Angularia:
</p>
<pre class="sh_javascript_dom">
function HelloController($scope){
  $scope.name = 'Kalle';
}
</pre>
<p>
  Se on siinä! Määrittelemme siis vain funktion nimeltä <code>HelloController</code>, jolla on yksi parametri. Parametrina saadun muuttujan <code>$scope</code> ("scope", suomeksi "näkyvyysalue") avulla toteuttamamme kontrolleri keskustelee näkymän kanssa. Se on objekti, johon voimme liittää kenttiä, joita voimme näyttää ja muokata näkymässä. Näkymään voi välittää sen kautta oikeastaan mitä vain, merkkijonoja, kokonaislukuja, objekteja tai jopa funktioita. Tässä esimerkissä välitämme näkymäämme vain muuttujan name, joka onnistuu lisäämälle <code>$scope</code>-objektiin kentän <code>name</code>.
</p>
<p>
  Jotta näkymä tietäisi, minkä kontrollerin kanssa se on vuorovaikutuksessa, täytyy näkymään määrittää kontrollerin näkyvyysalue lisäämällä johonkin HTML-tagiin attribuutti <code><a href="https://docs.angularjs.org/api/ng/directive/ngController" target="_blank">ng-controller</a>="HelloController"</code> ja se elementti lapsineen muodostaa kontrollerin näkyvyysalueen. Liitetään toteuttamamme <code>HelloController</code> näkymäämme:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app&gt;
    &lt;div ng-controller="HelloController"&gt;
      &lt;h1&gt;Hello {{name}}!&lt;/h1&gt;
      &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Nyt kontrollerimme näkyvyysalue on <code>div</code>-elementti, ja kaikki sen lapset. Näkymän otsikon sisältö ei ole enää pelkästään "Hello!", vaan muuttujalla <code>name</code> on asetettu kontrollerissa alkuarvo, "Kalle". Otsikon sisältö on siis "Hello Kalle!" ja lisäksi tekstikentän, jonka arvo on sidottu muuttujaan <code>name</code>, sisältö on "Kalle". On myös tärkeää lisätä <code><a href="https://docs.angularjs.org/api/ng/directive/ngApp" target="_blank">ng-app</a></code>-attribuutti johonkin DOM-elementtiin, joka sisältää kaikki elementit, jotka ovat kytköksissä Angulariin. Lisäsin sen tässä esimerkissä <code>body</code>-tagiin, mutta olisin voinyt lisätä sen yhtä hyvin <code>html</code>-tagiin.
</p>
<div class="tehtavat">
  <h3>My name is Bond, James Bond</h3>
  Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että näkymän otsikon sisältö määräytyy "etunimi" ja "sukunimi" tekstikenttien perusteella. Jos siis "etunimi"-kentän arvo on "Kalle" ja "sukunimi"-kentän arvo on "Ilves", on otsikon sisältö "My names is Ilves, Kalle Ilves". Otsikon alkuarvon tulee olla "My name is Bond, James Bond". Joudut tekemään muutoksia näkymän lisäksi <code>BondController</code>-kontrolleriin, joka sijaitsee tiedostossa <code>app/app.js</code>.
</div>
<h3>Näkymät</h3>
<p>
  Angularissa jo pelkästään mallin esittäminen näkymässä on huomattavasti monipuolisempaa, kuin esimerkiksi Mustachen kanssa. Havainnollistetaan sitä tämän esimerkkikontrollerin avulla:
</p>
<pre class="sh_javascript_dom">
function ExampleController($scope){
  $scope.person = {
    name: 'Kalle',
    age: 22,
    happy: true,
    friends: ['Henri', 'Arto', 'Elina', 'Jorma']
  };
}
</pre>
<p>
  Määritin siis <code>ExampleController</code>-funktiossa <code>person</code>-objektin, jonka haluan välittää näkymälle.
</p>
<h4>Muuttujien upottaminen</h4>
<p>
  Toteutetaan seuraavaksi näkymä, joka esittää <code>person</code>-objektin kentät. Aloitetaan <code>name</code>- ja <code>age</code>-kenttien esittämisellä:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app&gt;
    &lt;div ng-controller="ExampleController"&gt;
      &lt;h1&gt;{{person.name}}, {{person.age}} vuotta vanha&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Näkymässä ei tapahdu mitään kovin kummallista, siihen upotetaan arvot <code>person.age</code> ja <code>person.name</code> syntaksilla <code>{{muuttuja}}</code>, joka on jo ennestään tuttu Mustachen kanssa. Näkymään ilmestyy siis otsikko, jonka sisältö on "Kalle, 22 vuotta vanha".
</p>
<h4>Ehtolauseet ja DOM-elementtien muokkaus ehtojen perusteella</h4>
<p>
  Lisätään seuraavaksi näkymään tieto henkilön mielentilasta:
</p>
<pre class="sh_html">
&lt;h1&gt;{{person.name}}, {{person.age}} vuotta vanha&lt;/h1&gt;
&lt;p&gt;
  Fiilis on
  &lt;span ng-if="person.happy">:)&lt;/span&gt;
  &lt;span ng-if="!person.happy">:(&lt;/span&gt;
&lt;/p&gt;
</pre>
<p>
  Lisäämällä <code><a href="https://docs.angularjs.org/api/ng/directive/ngIf" target="_blank">ng-if</a></code>-attribuutin elementtiin, pystymme määrittämään ehdon sen esittämiselle. Ehto määräytyy <code>ng-if</code>-attribuutin arvon perusteella, jonka tulee olla jokin totuusarvo. Koska kontrollerissa on määritelty <code>person.happy = true</code>, toteutuu attribuutissa määritelty ehto, joten <code>span</code>-elementti sisältöineen on näkymässä.
</p>
<p>
  On lisäksi monia muita tapoja manipuloida DOM-elementtejä ehtojen perusteella. Voimme esimerkiksi lisätä <code>span</code>-elementtiin luokan <code>green</code>, jos ehto <code>person.happy</code> toteutuu. Vastaavasti, jos se ei toteudu, voimme lisätä siihen luokan <code>red</code>:
</p>
<pre class="sh_html">
&lt;h1&gt;{{person.name}}, {{person.age}} vuotta vanha&lt;/h1&gt;
&lt;p&gt;
  Fiilis on
  &lt;span ng-if="person.happy" ng-class="{ 'green': person.happy }">:)&lt;/span&gt;
  &lt;span ng-if="!person.happy" ng-class="{ 'red': person.happy }">:(&lt;/span&gt;
&lt;/p&gt;
</pre>
<p>
  <code><a href="https://docs.angularjs.org/api/ng/directive/ngClass" target="_blank">ng-class</a></code>-attribuutin sisältö on JSON-muodossa oleva merkkijono, jonka kenttinä on lisättävä luokka ja arvona ehto, joka kyseisen luokan lisäämiseen kuuluu. Samalla tavalla toimii mm. <code>ng-attr</code>, joka lisää DOM-elementtiin tietyn attribuutin, jos annettu ehto toteutuu.
</p>
<h4>Listojen läpikäynti</h4>
<p>Lopuksi täytyy vielä esittää lista henkilön ystävistä. Kuten Mustachessa, myös Angularissa on oma toistorakenteensa:
</p>
<pre class="sh_html">
&lt;h1&gt;{{person.name}}, {{person.age}} vuotta vanha&lt;/h1&gt;
&lt;p&gt;
  Fiilis on
  &lt;span ng-if="person.happy">:)&lt;/span&gt;
  &lt;span ng-if="!person.happy">:(&lt;/span&gt;
&lt;/p&gt;
&lt;ul&gt;
  &lt;li ng-repeat="friend in person.friends"&gt;{{friend}}&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>
  Toisto siis onnistuu lisäämällä attribuutti <code><a href="https://docs.angularjs.org/api/ng/directive/ngRepeat" target="_blank">ng-repeat</a></code> elementtiin, jonka sisältöä halutaan toistaa. Attribuutin arvo on muotoa <code>iteroitavaAlkio in lista</code>. Toistojen määrää voi rajoittaa lisäämällä <code>ng-repeat</code>-attribuuttiin <code><a href="https://docs.angularjs.org/api/ng/filter/limitTo" target="_blank">limitTo</a></code> filtteri seuraavasti:
</p>
<pre class="sh_html">
&lt;ul&gt;
  &lt;li ng-repeat="friend in person.friends | limitTo: 5"&gt;{{friend}}&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>
  Yllä olevassa esimerkissä tulostetaan vain viisi ensimmäistä kaveria, koska limitTo filtterille on annettu parametriksi kokonaisluku 5, joka kertoo rajan toistettaville alkioille. Toinen hyödillinen filtteri on <code><a href="https://docs.angularjs.org/api/ng/filter/orderBy" target="_blank">orderBy</a></code>, joka toistaa taulukon alkiot tietyssä järjestyksessä, esimerkiksi nimen perusteella:
</p>
<pre class="sh_html">
&lt;ul&gt;
  &lt;li ng-repeat="friend in person.friends | orderBy"&gt;{{friend}}&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>
  Koska taulukko sisältää merkkijonoja, ei <code>orderBy</code>-filtterille tarvitse antaa parametreja. Jos <code>friend</code>-muuttuja olisi ollut objekti, jolla on kenttä <code>name</code> olisi filtterin pitänyt olla <code>orderBy: 'name'</code>. Jos haluaa järjestää ystävät nimen mukaan käänteisessä järjestyksessä filtteri olisi taas <code>orderBy: '-name'</code>.
</p>
<p>
  Tustustutaan vielä lopuksi filtteriin <code><a href="https://docs.angularjs.org/api/ng/filter/filter" target="_blank">filter</a></code>, joka toistaa vain alkiot, jotka toteuttavat annetun ehdon, esimerkiksi sisältävät kirjaimen "a":
</p>
<pre class="sh_html">
&lt;ul&gt;
  &lt;li ng-repeat="friend in person.friends | filter: 'a'"&gt;{{friend}}&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>
  <code>filter</code>-filtterin parametri olisi yhtä hyvin voinut olla esimerkiksi muuttuja tai funktio.
</p>
<div class="tehtavat">
  <h3>Nättiä dataa</h3>
  Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että se listaa (vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngRepeat" target="_blank">ng-repeat</a></code>) <code>index.html</code>-näkymässä <code>MovieController</code>-kontrollerissa (löytyy tiedostosta <code>app/app.js</code>) määritellyn taulukon <code>movies</code> elokuvat siten, että lista näyttää kutakuinkin tältä:
  <div>
    <p>
      <h3 class="ignore">
        <a href="http://www.imdb.com/title/tt0120737">The Lord of the Rings: The Fellowship of the Ring</a> (2001)
      </h3>
      <p>
        A meek hobbit of the Shire and eight companions set out on a journey to Mount Doom to destroy the One Ring and the dark lord Sauron.
      </p>
      <h4 class="ignore">Director</h4>
      <p>
        Peter Jackson
      </p>
      <h4 class="ignore">Oscar awards (4)</h4>
      <p>
        <ul>
          <li>Best Cinematography</li>
          <li>Best Makeup</li>
          <li>Best Music, Original Score</li>
          <li>Best Effects, Visual Effects</li>
        </ul>
      </p>
      <h4 class="ignore">Roles</h4>
      <ul>
        <li>Elijah Wood (Frodo)</li>
        <li>Sean Astin (Sam)</li>
        <li>Billy Boyd (Pippin)</li>
        <li>Dominic Monaghan (Merry)</li>
        <li>Viggo Mortensen (Aragorn)</li>
        <li>Orlando Bloom (Legolas)</li>
      </ul>
    </p>
    <p>
      <h3 class="ignore">
        <a href="http://www.imdb.com/title/tt0097523">Honey, I Shrunk the Kids</a> (1989)
      </h3>
      <p>
        The scientist father of a teenage girl and boy accidentally shrinks his and two other neighborhood teens to the size of insects. Now the teens must fight diminutive dangers as the father searches for them.
      </p>
      <h4 class="ignore">Director</h4>
      <p>
        Joe Johnston
      </p>
      <h4 class="ignore">Roles</h4>
      <ul>
        <li>Rick Moranis (Wayne Szalinski)</li>
        <li>Marcia Strassman (Diane Szalinski)</li>
        <li>Kristine Sutherland (Mae Thompson)</li>
      </ul>
    </p>
    <p>
      <h3 class="ignore"><a href="http://www.imdb.com/title/tt0096283">My Neighbor Totoro</a> (1988)</h3>
      <p>
        When two girls move to the country to be near their ailing mother, they have adventures with the wonderous forest spirits who live nearby.
      </p>
      <h4 class="ignore">Director</h4>
      <p>
        Hayao Miyazaki
      </p>
      <h4 class="ignore">Roles</h4>
      <ul>
        <li>Toshiyuki Amagasa (Kanta)</li>
        <li>Brianne Brozey (Michiko)</li>
        <li>Cheryl Chase (Mei)</li>
        <li>Dakota Fanning (Satsuki)</li>
      </ul>
    </p>
  </div>
  <p>
    Elokuvan otsikko sisältää sen nimen ja julkaisuvuoden. Elokuvan nimen tulee olla linkki sen sivulle <a href="http://www.imdb.com" target="_blank">IMDb</a>:ssä (vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngHref" target="_blank">ng-href</a></code>). Oscar-palkinnot tulee näyttää vain, jos elokuvalla niitä on (vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngIf" target="_blank">ng-if</a></code>). "Oscar awards" otsikon vieressä suluissa on Oscar-palkintojen lukumäärä. Elokuvan näyttelijät tulee listata (vinkki: </code>ng-repeat</code>) niin, että näyttelijän nimi on ensin ja sen jälkeen suluissa näyttelijän roolinimi elokuvassa. Järjestä elokuvien lista julkaisuvuoden perusteella (vinkki: <code><a href="https://docs.angularjs.org/api/ng/filter/orderBy" target="_blank">orderBy</a></code>), niin että uusin elokuva on listan kärjessä.
  </p>
  <ul>
</div>
<h3>Mallin muokkaaminen näkymässä</h3>
<p>
  Pelkkä mallin esittäminen näkymässä ei riitä, jos sitä ei pysty myös muokkaamaan. Angularissa mallin pystyy helposti sitomaan lomakkeen elementteihin, kuten tekstikenttiin, radio-painikkeisiin ja checkboxeihin. Palataan takaisin <code>ExampleController</code>-kontrollerin pariin, jossa välitimme näkymään objektin <code>person</code>. Katsotaan, miten voimme muokata <code>person</code>-objektia näkymästämme käsin. Aloitetaan <code>name</code>-kentän muokkaamisella, jota haluan pystyä muokkaamaan tekstikentän avulla:
</p>
<pre class="sh_html">
&lt;label&gt;Nimi&lt;/label&gt;
&lt;input type="text" ng-model="person.name"&gt;
</pre>
<p>
  Riittää siis vain määrittää tekstikentän <code>ng-model</code> attribuuttiin muuttuja, jonka arvo halutaan sitoa sen arvoon. Nyt kun tekstikentän arvo muuttuu, muuttuu myös <code>person</code>-objektin <code>name</code> kentän arvo.
</p>
<p>
  Totuusarvoa on kätevä muuttaa näkymissä sitomalla sen arvo checkboxin arvoon. Voimme siis helposti muuttaa <code>person</code>-objektin <code>happy</code>-kentän arvoa seuraavasti:
</p>
<pre class="sh_html">
&lt;label&gt;Iloinen?&lt;/label&gt;
&lt;input type="checkbox" ng-model="person.happy"&gt;
</pre>
<p>
  Angularissa pystyt sitomaan muuttujan arvon lähes jokaiseen eri lomakkeen elementtiin lisäämällä sille <code>ng-model</code>-attribuutin, jonka arvona on sidotun muuttujan nimi.
</p>
<p>
  <code>ng-model</code>-attribuutissa määritellyissä muuttujissa on käytössä nk. "two way data binding", jolloin mallin muuttaminen kontrollerissa aiheuttaa näkymän päivityksen ja samoin mallin muuttaminen näkymässä aiheuttaa siihen muutoksen kontrollerissa.
</p>
<div class="tehtavat">
  <h3>Elokuvafiltteri</h3>
  <p>
    Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että <code>index.html</code>-näkymässä muodostettua elokuvien listaa pystyy filtteröimään nimen, julkaisuvuoden ja ohjaajan perusteella käyttämällä näkymässä olevia kenttiä. Jos siis käyttäjä syöttää esimerkiksi "nimi"-kenttään arvon "The Lord" ja "ohjaaja"-kenttään arvon "Peter", tulee näkymässä listata vain elokuvat, joiden nimestä löytyy sana "The Lord" ja ohjaajan nimestä löytyy sana "Peter". <a href="https://docs.angularjs.org/api/ng/filter/filter" target="_blank">Filtteröintiin</a> tutustumisesta on tehtävässä paljon apua. Taulukko <code>movies</code> löytyy kontrollerista <code>MovieController</code> (joka löytyy tiedostosta <code>app/app.js</code>). Älä tee muutoksia <code>movies</code>-taulukkoon, mutta muuten voit tehdä kontrolleriin haluamiasi muutoksia.
  </p>
</div>
<h4>Lomakkeiden validointi</h4>
<p>
  Katsotaan seuraavaksi hieman, kuina pystymme validoimaan käyttäjän syötteitä Angularin avulla. Otetaan esimerkiksi tämä lomake, joka sisältää kentät henkilötiedoille:
</p>
<pre class="sh_html">
&lt;form name="infoForm"&gt;
  &lt;p&gt;
    &lt;label&gt;Etunimi&lt;/label&gt;
    &lt;input name="firstName" type="text" ng-model="firstName"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label&gt;Sukunimi&lt;/label&gt;
    &lt;input name="lastName" type="text" ng-model="lastName"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label&gt;Puhelinnumero&lt;/label&gt;
    &lt;input name="phoneNumber" type="text" ng-model="phoneNumber"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label&gt;Sähköpostiosoite&lt;/label&gt;
    &lt;input name="emailAddress" type="text" ng-model="emailAddress"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;input type="submit" value="Lähetä"&gt;
  &lt;/p&gt;
&lt;/form&gt;
</pre>
<p>
  Haluaisin, että yllä oleva lomake validoitaisiin seuraavasti:
  <ul>
    <li>Etunimi, eikä sukunimi saa olla tyhjä ja molempien pituuden tulee olla vähintään kaksi merkkiä</li>
    <li>Puhelinnumeron pitää koostua numeroista ja olla vähintään yhdeksän merkkiä pitkä</li>
    <li>Sähköpostiosoitteen pitää olla muotoa jotain@jotain.jotain</li>
  </ul>
</p>
<p>
  Huh, kuulostaa aikamoiselta urakalta! Onneksi se ei Angularin kanssa ole. Aloitetaan etunimen ja sukunimen validoinnista. Jos kentät eivät ole valideja, lisätään niiden alapuolelle virheilmoitukset:
</p>
<pre class="sh_html">
&lt;p&gt;
  &lt;label&gt;Etunimi&lt;/label&gt;
  &lt;input name="firstName" type="text" ng-model="firstName" required ng-minlength="2"&gt;
&lt;/p&gt;
&lt;p&gt;
  &lt;label&gt;Sukunimi&lt;/label&gt;
  &lt;input name="lastName" type="text" ng-model="lastName" required ng-minlength="2"&gt;
&lt;/p&gt;
</pre>
<p>
  Kenttien validointi tapahtuu lisäämälle niihin validointiin liittyviä attribuutteja. Molempiin tekstikenttiin on lisätty attribuutti <code>required</code>, joka kertoo, että kentässä tulee olla sisältöä. Lisäksi molemmissa on attribuutti <code>ng-minlength</code>, jonka arvo on <code>2</code>. Se kertoo, että kentän pituuden tulee olla vähintään kaksi merkkiä.
</p>
<p>
  Puhelinnumeron ja sähköpostiosoitteen kentät ovat hieman hankalampia, niissä pitää käyttää säännöllistälauseketta. Ei hätää, voimme määrittää niille attribuutin <code>ng-pattern</code>, jonka arvoksi määritämme haluamamme säännöllisenlausekkeen:
</p>
<pre class="sh_html">
&lt;p&gt;
  &lt;label&gt;Puhelinnumero&lt;/label&gt;
  &lt;input name="phoneNumber" type="text" ng-model="phoneNumber" ng-pattern="/^[0-9]{9,}$/"&gt;
&lt;/p&gt;
&lt;p&gt;
  &lt;label&gt;Sähköpostiosoite&lt;/label&gt;
  &lt;input name="emailAddress" type="text" ng-model="emailAddress" ng-pattern="/^.+@.+\..+$/"&gt;
&lt;/p&gt;
</pre>
<p>
  Nyt puhelinnumerossa täytyy olla vähintään yhdeksän numeroa ja sähköpostiosoite on muotoa jotain@jotain.jotain. Huomaa, että säännöllinen lauseke tulee sijoittaa merkkien <code>/^</code> ja <code>$/</code> väliin.
</p>
<p>
  Seuraavaksi käyttäjälle pitäisi näyttää virheilmoitukset, jos hän on täyttänyt lomakkeet väärin. Lisätään jokaisen kentän alle virheilmoitus, jos se ei ole validi:
</p>
<pre class="sh_html">
&lt;div ng-app&gt;
  &lt;form name="infoForm"&gt;
    &lt;p&gt;
      &lt;label&gt;Etunimi&lt;/label&gt;
      &lt;input name="firstName" type="text" ng-model="firstName" required ng-minlength="2"&gt;
      &lt;div ng-show="infoForm.firstName.$invalid && infoForm.firstName.$dirty"&gt;
        Etunimi ei ole validi!
      &lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;label&gt;Sukunimi&lt;/label&gt;
      &lt;input name="lastName" type="text" ng-model="lastName" required ng-minlength="2"&gt;
      &lt;div ng-show="infoForm.lastName.$invalid && infoForm.lastName.$dirty"&gt;
        Sukunimi ei ole validi!
      &lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;label&gt;Puhelinnumero&lt;/label&gt;
      &lt;input name="phoneNumber" type="text" ng-model="phoneNumber" required ng-pattern="/^[0-9]{9,}$/"&gt;
      &lt;div ng-show="infoForm.phoneNumber.$invalid && infoForm.phoneNumber.$dirty"&gt;
        Puhelinnumero ei ole validi!
      &lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;label&gt;Sähköpostiosoite&lt;/label&gt;
      &lt;input name="emailAddress" type="text" ng-model="emailAddress" required ng-pattern="/^.+@.+\..+$/"&gt;
      &lt;div ng-show="infoForm.emailAddress.$invalid && infoForm.emailAddress.$dirty"&gt;
        Sähköpostiosoite ei ole validi!
      &lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;input type="submit" value="Lähetä" ng-disabled="infoForm.$invalid"&gt;
    &lt;/p&gt;
  &lt;/form&gt;
&lt;/div&gt;
</pre>
<p>
  Jokaiseen kenttään on lisätty virheilmoitus, joka näytetään, jos kenttä ei ole validi ja sitä on muokattu. Kentän oikeellisuuden pystyy tarkastamaan arvosta lomakkeenName.kentanName.$invalid, jossa <code>lomakkeenName</code> on <code>form</code>-elementin <code>name</code>-attribuutin arvo, jonka sisällä kenttä sijaitsee ja <code>kentanName</code> kyseisen kentän <code>name</code>-attribuutin arvo. Esimerkiksi <code>infoForm.firstName.$invalid</code> on <code>false</code>, jos etunimen kenttä on validi ja <code>true</code>, jos se ei ole validi. Voimme tarkistaa onko koko lomake validi arvosta <code>lomakkeenName.$invalid</code>. Lisäksi voimme tarkistaa onko kenttä validi yksittäinen validaattorin perusteella, esimerkiksi <code>required</code>-validaattorin perusteella, syntaksilla <code>lomakkeenName.kentanName.$error.required</code> (<code>true</code>, jos kenttä ei ole validi <code>require</code>-validaattorin perusteella). Esimerkissä otin "Lähetä"-painikkeen pois käytöstä, jos lomake ei ole validi. Arvo <code>lomakkeenName.kentanName.$dirty</code> taas kertoo, onko kentän arvoa muutettu. Se on lisätty ehtoon, koska emme halua näyttää virheilmoituksia ennen kuin käyttäjä on ehtinyt syöttää mitään kenttään.
</p>
<p>
  Lisää lomakkeista ja niiden validoinnista voit lukea <a href="https://docs.angularjs.org/guide/forms" target="_blank">täältä</a>.
</p>
<p>
  Tässä vielä lopputulos:
  <iframe width="100%" height="300" src="http://jsfiddle.net/HB7LU/10936/embedded/result,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</p>
<div class="tehtavat">
  <h3>Validi sen olla pitää!</h3>
  <p>Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että siinä oleva lomake validoidaan. Lomake on validi, jos seuraavat ehdot ovat voimassa:
  <ul>
    <li>
      Käyttäjätunnus on vähintään kolme merkkiä pitkä.
    </li>
    <li>
      Käyttäjän salasanan pituus on vähintään kahdeksan merkkiä ja sisältää vähintään yhden numeron ja ison kirjaimen.
    </li>
    <li>
      Käyttäjän antama salasana ja sen vahvistus vastaavat toisiaan. Käytetään tähän Angulariin toteutettua direktiiviä, jonka käyttöön löydät ohjeet <a href="https://github.com/TheSharpieOne/angular-input-match#usage" target="_blank">täältä</a>. Asennus on jo tehty, tutustu vain lyhyesti käyttöohjeisiin.
    </li>
    <li>
      Sekä etu-, että sukunimi on pituudeltaan vähintään kaksi merkkiä ja koostuvat pelkistä kirjaimista.
    </li>
    <li>Henkilötunnus on <a href="http://fi.wikipedia.org/wiki/Henkil%C3%B6tunnus#Tunnuksen_muoto" target="_blank">täällä</a> määriteltyä muotoa.</li>
    <li>
      Käyttäjä on hyväksynyt käyttöehdot (checkboxi on valittu).
    </li>
  </ul>
</p>
  Poista lomakkeen lähetyspainike käytöstä, kunnes lomake on validi (vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngDisabled" target="_blank">ng-disabled</a></code>). Näytä lisäksi kenttiin kohdistuvat virheilmoitukset, jos niille on tarvetta, kunhan käyttäjä on ehtinyt syöttää kenttään arvon. Yksittäisen validaattorin virheitä ei tarvitse näyttää, riittää ilmoittaa, jos kenttä ei ole validi jonkin validaattorin perusteella. Muista sitoa jokainen kenttä jonkin muuttujan arvoon <code>ng-model</code>-attribuutin avulla, muuten validointi ei toimi.
</p>
</div>
<h3>Tapahtumat</h3>
</p>
  Puhutaan seuraavaksi hieman siitä, kuinka voimme sitoa tapahtumia näkymäämme. Puhuimme jo siitä, että näkymään voi välittää <code>$scope</code>-parametrin kautta myös funktioita. Kuulostaa siltä, että voisimme siis kutsua kontrollerissa määriteltyä funktiota näkymästä käsin.
</p>
<p>
  Olemme tottuneet jQueryssa siihen, että tapahtumat sidotaan johonkin valitsimeen, esimerkiksi id:llä <code>nappula</code> varustettuun painikkeeseen sidottaisiin <code>click</code>, eli hiirenpainallus elementin päällä seuraavasti:
</p>
<pre class="sh_javascript_dom">
$('#nappula').on('click', function(){
  alert('Painoit nappulaa!');
});
</pre>
<p>
  Tapahtumat sidotaan siis jQueryssa käyttöliittymälogiikan puolella. Tässä tavassa ei periaatteessa ole mitään vikaa, mutta kun tapahtumien määrä kasvaa, täyttyy käyttöliittymälogiikka oudoista valitsimista ja kukaan ei enää muista, mihin näkymän elementtiin kukin valitsin liittyi.
</p>
<p>
  Angular lähestyy tapahtumien sitomista elementteihin toisesta näkökulmasta sitomalla tapahtumat näkymässä suoraan DOM-elementtiin valitsimen sijaan. Tapa muistuttaa hieman kurssin alkupuolella esitettyä tapaa sitoa tapahtumia DOM-elementteihin. Äskeinen jQuery esimerkki voidaan toteuttaa Angularilla seuraavasti:
</p>
<pre class="sh_html">
&lt;div ng-controller="NotificationController"&gt;
  &lt;button ng-click="notify('Painoit nappulaa!')" id="nappula"&gt;Paina nappulaa!&lt;/button&gt;
&lt;/div&gt;
</pre>
<p>
  Sidoimme siis <code>button</code>-elementtiin <code>click</code>-tapahtuman asettamalla sille <code>ng-click</code>-attribuutin, jonka arvona on funktionkutsu. Eri tapahtumia on lukuisia ja yleensä ne muistuttavat nimissään jQueryn tapahtumia, esimerkiksi <code>ng-mousemove</code>, <code>ng-keyup</code> ja <code>ng-focus</code>.
  Nyt koodin ulkopuolinen katselijakin näkee helposti, mitä tapahtumia mihinkin DOM-elementtiin on sidottu ilman, että hänen täytyy tulkita valitsimia. Yllä oleva koodi ei tosin itsessään tee vielä mitään, koska funktiota <code>notify</code> ei ole määritelty. Toteutetaan siis kontrolleri, josta kyseinen funktio löytyy:
</p>
<pre class="sh_javascript_dom">
function NotificationController($scope){
  $scope.notify = function(notification){
    alert(notification);
  }
}
</pre>
<p>
  Kuten jo puhuimme, näkymään voi välittää myös funktion, jonka nyt teimme lisäämällä <code>$scope</code>-objektiin kentän <code>notify</code>, jonka arvona on funktio.
</p>
<p>
  Palataan hetkeksi <code>ExampleController</code>-funktion pariin, jonka kanssa työskentelimme vähän aikaa sitten. Toteutetaan siihen toiminto, jonka avulla henkilön ystäviä voi lisätä ja poistaa:
</p>
<pre class="sh_javascript_dom">
function ExampleController($scope){
  $scope.person = {
    name: 'Kalle',
    age: 22,
    happy: true,
    friends: ['Henri', 'Arto', 'Elina', 'Jorma']
  };

  $scope.addFriend = function(){
    $scope.person.friends.push($scope.newFriend);
  }

  $scope.removeFriend = function(index){
    $scope.person.friends.splice(index, 1);
  }
}
</pre>
<p>
  Ennen kuin etenemme pidemmälle, katsotaan, mitä muutoksia teimme. Lisäsimme siis funktiot <code>addFriend</code> ja <code>removeFriend</code> parametrin <code>$scope</code> kentiksi, jolloin ne ovat käytettävissä näkymässä. Funktio <code>addFriend</code> lisää ystävät sisältävään taulukkoon uuden ystävän. Emme ole vielä määritelleet muuttujaa <code>newFriend</code>, mutta tulemme tekemään sen pian näkymässämme. Toteutimme myös funktion <code>removeFriend</code>, joka poistaa ystävän taulukon tietystä indeksistä käyttäen <code>splice</code>-funktiota, joka poistaa taulukosta tietyn määrän alkioita alkaen tietystä indeksistä (järjestys on <code>splice(indeksi, lukumäärä)</code>).
</p>
<p>
  Nyt kaikki kontrollerissa tehdyt muutokset on käyty läpi, joten siirrytäänpä näkymän pariin. Aloitetaan lisäystoiminnosta. Tarvitsemme tekstikentän, johon käyttäjä voi lisätä uuden ystävän nimen ja painikkeen, jota painamalla ystävä lisätään:
</p>
<pre class="sh_html">
&lt;div ng-app&gt;
  &lt;div ng-controller="ExampleController"&gt;
    &lt;input type="text" ng-model="newFriend"&gt;
    &lt;button ng-click="addFriend()"&gt;Lisää ystävä&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>
  Sidoimme muuttujan <code>newFriend</code> arvon tekstikenttään, jolloin sen arvo välittyy muuttujaamme. Lisäksi sidoimme painikkeeseen hiirenpainallustapahtuman, jonka seurauksena kutsutaan funktiota <code>addFriend</code>.
</p>
<p>
  Seuraavaksi haluamme toteuttaa toiminnon ystävän poistamiselle. Olemme jo toteuttaneet näkymään ystävien listaamisen, lisätään vain jokaisen ystävän kohdalle painike sen poistamiseksi:
</p>
<pre class="sh_html">
&lt;div ng-app&gt;
  &lt;div ng-controller="ExampleController"&gt;
    &lt;ul ng-repeat="friend in person.friends"&gt;
      &lt;li&gt;{{friend}} &lt;button ng-click="removeFriend($index)"&gt;Poista&lt;/button&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;input type="text" ng-model="newFriend"&gt;
    &lt;button ng-click="addFriend()"&gt;Lisää ystävä&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>
  Toteutimme <code>removeFriend</code>-funktion niin, että se poistaa ystävän taulukon tietystä indeksistä. Se tehtiin siksi, että <code>ng-repeat</code>-toistorakenteessa iteroitavan alkion indeksi on helppo saada muuttujasta <code>$index</code>. Funktion olisi voinut myös toteuttaa niin, että se poistaa ystävän tietyllä nimellä käyttäen jQueryn <code>$.grep</code>-funktiota siten, että se valitsee vain ystävät, joilla ei ole parametrina annettua nimeä. Tällöin taulukossa ei tosin olisi voinut olla saman nimisiä ystäviä.
</p>
<p>
  Tämä pieni sovellus alkaa olla paketissa, katsotaan vielä, mitä olemme saaneet aikaan:
  <iframe width="100%" height="300" src="http://jsfiddle.net/HB7LU/10905/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</p>
<div class="tehtavat">
  <h3>Laskin</h3>
  <p>
    Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että käyttäjä voi laskea kerto-, plus-, erotus- ja jakolaskuja syöttämällä haluamansa luvut kahteen kenttään ja painamalla jotain neljästä painikkeesta, jolloin valittu laskuoperaatio suoritetaan luvuille ja tulos näytetään käyttäjälle kenttien yläpuolella. Jos käyttäjä yrittää jakaa lukua nollalla, ota jakolaskupainike pois käytöstä (vinkki: <code>ng-disabled</code>). Toteuta laskin tekemällä tarvittavat muutokset <code>CalculatorController</code>-kontrolleriin (löytyy tiedostosta <code>app/app.js</code>) ja <code>index.html</code>-näkymään.
  </p>
</div>
<h4>Mallin tarkkailu</h4>
<p>
  Tulee usein tilanne, jossa haluamme tarkkailla muutosta mallissa. Esimerkiksi, jos henkilön nimeä muuttaa, hänen ystävän poistetaan, koska henkilö ei ole enää sama kuin ennen, joten hänellä ei ole myöskään samoja ystäviä.
</p>
<p>
  Toteutetaan kuitenkin hieman yksinkertaisempi esimerkki, jossa käyttäjä syöttää nimensä tekstikenttään ja jos sen arvo on "James Bond", näytetään alert-ikkuna "I've been expecting you, mr. Bond". Aloitetaan luomalla näkymä, joka sisältyy <code>BondController</code>-kontrollerin näkyvyysalueeseen:
</p>
<pre class="sh_html">
&lt;div ng-controller="BondController"&gt;
  &lt;h1&gt;My name is {{name}}&lt;/h1&gt;
  &lt;input type="text" ng-model="name"&gt;
&lt;/div&gt;
</pre>
<p>
  Se on siinä! Sidoimme vain <code>name</code>-muuttujan arvon tekstikentän arvoon ja lisäsimme otsikon, joka esittää <code>name</code>-muuttujan arvon. Seuraavaksi toteutetaan funktio <code>BondController</code>, jossa itse magia tapahtuu:
</p>
<pre class="sh_javascript_dom">
function BondController($scope){
  $scope.name = "Kalle";

  $scope.$watch('name', function(newValue, oldValue){
    if(newValue == 'James Bond'){
      alert('I\'ve been expecting you, mr. Bond');
    }
  });
}
</pre>
<p>
  Lisäämme objektiin <code>$scope</code> tarkkailijan, joka tarkkailee <code><a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$watch" target="_blank">$watch</a></code>-funktion ensimmäisenä saatua parametria. Parametri annetaan merkkijonona, joka vastaa tarkkailtavan muuttujan nimeä. Kun muuttujan arvo vaihtuu, kutsutaan toisena parametrina annettua anonyymiä-funktiota, joka saa parametreikseen muuttujan uuden ja vanhan arvon. Funktion sisällä voimme tarkkailla muuttujan uutta arvoa ja tehdä jotain sen perusteella. Tarkkailtavan muuttujan ei tarvitse olla merkkijono, se voi olla myös mm. objekti tai taulukko. Kannattaa kuitenkin olla tarkkana, sillä Angular ei välttämättä ole kanssasi samaa mieltä siitä, onko muuttujan arvo muuttunut. Angular tarkastaa oletusarvoisesti, onko muuttujan viite muuttunut, jolloin objektien kanssa tulee ongelmia. Ongelma ratkeaa lisäämällä <code>$watch</code>-funktioon kolmas parametri, jonka arvo on <code>true</code>. Tällöin Angular vertaa muuttujan sisältöä viitteen sijaan.
</p>
<p>
  Tässä vielä lopputulos:
  <iframe width="100%" height="300" src="https://jsfiddle.net/HB7LU/10890/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</p>
<h3>Riippuvuuksien injektointi</h3>
<p>
  Riippuvuuksien injektointi (<a href="http://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a>) on suosittu suunnittelumalli sovelluskehityksessä, johon myös Angular hyvin vahvasti nojautuu. Dependency Injection suunnittelumallin suosio perustuu siihen, että se vähentää sovelluksen sisäisiä riippuvuuksia (tekee "<a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a>"-periaatteen noudattamisesta helpompaa) ja tekee koodista uudelleenkäytettävämpää sekä helpommin testattavaa.
</p>
<p>
  Katsotaan, miten riippuvuuksien injektointi on toteutettu Angularissa. Tähän mennessä olemme määritelleet kontrollerimme tähän tapaan:
</p>
<pre class="sh_javascript_dom">
function MyController($scope){
  $scope.message = 'Hello World!';
}
</pre>
<p>
  Tavassa ei periaatteessa ole mitään vikaa, mutta tulevaisuudessa haluamme käyttää muita komponentteja kontrollereissamme, jolloin meidän täytyy injektoida ne kontrolleriimme. Jotta riippuvuuksien injektointi olisi helpompaa, määrittelemme kontrollerimme tulevaisuudessa seuraavanlaisesti:
</p>
<pre class="sh_javascript_dom">
var App = angular.module('MyApp', []);

App.controller('MyController', function($scope){
  $scope.message = 'Hello World!';
});
</pre>
<p>
  Toteutimme siis moduulin nimeltä <code>MyApp</code> ja sille kontrollerin <code>MyController</code>, johon injektoin muuttujan <code>$scope</code>. Huomaa, että tyhjä taulukko <code>angular.module</code>-kutsun toisena parametrina tarkoittaa sitä, etten injektoi moduuliini toisia moduuleja. Tulemme kuitenkin tekemään niin tulevaisuudessa. Moduuli on Angularissa pelkästään laatikko, joka sisältää sovelluksemme komponentit, kuten kontrollerit. Se on siis tapa organisoida sovelluksen eri osia. Moduulin käyttö lähtee liikkeelle näkymästä, jossa se otetaan käyttöön lisäämällä se <code>ng-app</code>-attribuutin arvoksi:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;div ng-controller="MyController"&gt;
      &lt;h1&gt;{{message}}&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Ei siis sen kummempaa. Tehdään hommasta hieman jännittävämpää ja injektoidaan <code>MyController</code>-kontrolleriin <code>$scope</code>-muuttujan lisäksi funktio <code>$interval</code>, joka kutsuu parametrina saatua funktiota tietyn aikajakson välein:
</p>
<pre class="sh_javascript_dom">
App.controller('MyController', function($scope, $interval){
  $scope.message = 60;

  $interval(function(){
    $scope.message--;
  }, 1000);
});
</pre>
<p>
  Käytän injektoitua <code>$interval</code>-funktiota vähentääkseni muuttujan <code>message</code> arvoa joka sekunti (sekunti on 1000 millisekuntia).
</p>
<div class="tehtavat">
  <h3>Pikakirjoitus</h3>
  <p>
    Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että käyttäjä voi testata pikakirjoitustaitojaan. Pikakirjoituspelin tulee toimia niin, että käyttäjä näkee sivulla pitkän "Lorem ipsum dolor sit amet..."-tekstin, jonka sisältö löytyy muuttujasta <code>text</code>. Kun käyttäjä painaa "Aloita!"-painiketta, hänen täytyy alkaa kirjoittamaan näkeemäänsä tekstiä tekstikenttään niin nopeasti kuin mahdollista. Käyttäjällä on aikaa kirjoittaa tekstiä 15 sekuntia. Varmista, ettei käyttäjä tee kirjoitusvirhettä niin, ettet hyväksy tekstikenttään virheellisiä merkkejä. Samaan aikaan, kun käyttäjä kirjoittaa, sivulla näkyvän laskurin arvo vähenee joka sekunti. Kun laskurin arvo on 0, tulee käyttäjälle ilmoittaa alert-ikkunan kautta, kuinka monta merkkiä hän onnistui kirjoittamaan. Pelin uudelleen aloittamiseksi riittää, että käyttäjä päivittää sivun, mutta voit halutessasi alustaa pelin uudelleen, kun laskurin arvo on 0.
  </p>
  <p>
    Toteuta pikakirjoituspeli käyttämällä <code>$watch</code>-funktiota tarkkailemaan esimerkiksi <code>timeLeft</code> (kuinka paljon laskurissa on aikaa) ja <code>userText</code> nimisten muuttujien (käyttäjän kirjoittama teksti) arvoja. Kun <code>timeLeft</code> muuttujan arvo on 0, ilmoita käyttäjälle, kuinka monta merkkiä hän onnistui kirjoittamaan oikein (esim. "Onnistuit kirjoittamaan 30 merkkiä!"). Tarkkaile <code>userText</code>-muuttujaa kirjoitusvirheiden varalta esimerkiksi seuraavasti:
<pre class="sh_javascript_dom">
var lastChar = newVal.charAt(newVal.length - 1);

if(lastChar != $scope.text.charAt(newVal.length - 1)){
  $scope.userText = $scope.userText.slice(0,-1);
}
</pre>
  </p>
  <p>
    Pelin aloittaa "Aloita!"-painikkeen klikkaaminen. Aloita siis laskurin vähentäminen siitä hetkestä käyttämällä <code><a href="https://docs.angularjs.org/api/ng/service/$interval" target="_blank">$interval</a></code>-funktiota. <code>TypeController</code>-kontrollerin pohja löytyy tiedostosta <code>app/app.js</code> ja näkymä tiedostosta <code>index.html</code>.
  </p>
  <h3>TodoApp (3p)</h3>
  Seuraavaksi pääset toteuttamaan hieman suurempaa sovellusta, muistilistaa. Muistilistan avulla käyttäjä voi lisätä itselleen tehtäviä, jotka hän itse priorisoi. Lisätyn tehtävän voi merkata tehdyiksi, poistaa ja sen prioriteettia voi muuttaa. Tehtävät tulee järjestää muistilistaan niiden prioriteetin mukaan. Lopullinen muistilista muistuttaa tätä (pelkkä käyttöliittymä, toiminallisuus puuttuu):
  <p>
  <style>
    #todo-container{
      border: 1px solid rgb(220,220,220);
      font: 13px arial;
    }
    #add-todo-container{
      padding: 10px;
    }
    #add-todo-container input[type="text"]{
      padding: 10px;
      width: 400px;
      border: 1px solid rgb(220,220,220);
    }
    #mark-todos-done{
      background-color: #00C000 !important;
      border: 1px solid #00C000 !important;
    }
    #remove-todos{
      background-color: #C63717 !important;
      border: 1px solid #C63717 !important;
    }
    #todo-footer{
      border-top: 1px solid rgb(220,220,220);
      padding: 10px;
    }
    #add-todo-container button{
      padding: 10px 14px;
      border: 1px solid black;
      background-color: black;
      color: white;
    }
    .todo{
      border-top: 1px solid rgb(220,220,220);
      padding: 10px;
      overflow: hidden;
    }
    .todo .todo-priority{
      padding: 10px 10px;
      display: inline-block;
      width: 40px;
      text-align: center;
      border: 1px solid white;
    }
    .todo .todo-priority:hover, .todo-priority:focus{
      border: 1px solid rgb(220,220,220);
    }
    .todo .todo-done{
      text-decoration: line-through;
    }
    .todo .remove-todo{
      background-color: #C63717;
      border: 1px solid #C63717;
      color: white;
      padding: 10px 14px;
      float: right;
    }
  </style>
      <h1 class="ignore">Muistilista</h1>
      <div id="todo-container">
        <div id="add-todo-container">
          <input type="text" placeholder="Uusi tehtävä">
          <button>Lisää tehtävä</button>
          <button id="mark-todos-done">Merkkaa kaikki tehdyiksi</button>
          <button id="remove-todos">Poista kaikki</button>
        </div>

        <div class="todo">
          <input type="text" value="1" class="todo-priority">
          <label>
            <input type="checkbox" checked> <span class="todo-done">Kirjoita Angular-materiaalia</span>
          </label>
          <button class="remove-todo">Poista</button>
        </div>

        <div class="todo">
          <input type="text" value="2" class="todo-priority">
          <label>
            <input type="checkbox"> <span>Ruoki koira</span>
          </label>
          <button class="remove-todo">Poista</button>
        </div>

        <div class="todo">
          <input type="text" value="3" class="todo-priority">
          <label>
            <input type="checkbox"> <span>Käy kaupassa</span>
          </label>
          <button class="remove-todo">Poista</button>
        </div>

        <div id="todo-footer">
          1 tehtävä tehty, 2 tehtävää jäljellä
        </div>
      </div>
  </p>
  <p>
    Toteuta valmiiseen käyttöliittymään seuraavat toiminnot:
    <ul>
      <li>Käyttäjä voi lisätä tehtävän listaan "Uusi tehtävä"-tekstikentän nimen perusteella. Älä anna käyttäjän lisätä tehtävää tyhjällä nimellä.</li>
      <li>Käyttäjä voi merkata merkata tehtävän tehdyksi klikkaamalla checkboxia. Tehdyn tehtävän nimi vedetään yli (voit lisätä tehtävän nimeen tällöin luokan <code>todo-done</code> (vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngClass" target="_blank">ng-class</a></code>).</li>
      <li>
        Käyttäjä voi merkata kaikki tehtävät tehdyksi klikkaamalla "Merkkaa kaikki tehdyiksi"-painiketta.
      </li>
      <li>
        Käyttäjä voi poistaa tehtävän listasta painamalla oikeasta laidasta "Poista"-painiketta.
      </li>
      <li>
        Käyttäjä voi poistaa kaikki tehtävät klikkaamalla "Poista kaikki"-painiketta. Varmista painikkeen klikkaamisen jälkeen, että käyttäjä haluaa varmasti poistaa kaikki tehtävät (vinkki: <code><a href="http://www.w3schools.com/jsref/met_win_confirm.asp" target="_blank">confirm</a></code>).
      </li>
      <li>
        Tehtävään liittyy prioriteetti. Jokaiselle tehtävälle lisätään sen lisäämisen yhteydessä prioriteetti <code>1</code>. Mitä pienempi prioriteetti on, sitä tärkeämpi tehtävä on. Käyttäjä voi muokata tehtävän prioriteettia vaihtamalla sen vieressä olevan tekstikentän arvoa. Järjestä tehtävät prioriteetin mukaan niin, että tärkeimmät tehtävät ovat listan yläpäässä (vinkki: liitä prioriteetin sisältävään tekstikenttään <code><a href="https://docs.angularjs.org/api/ng/directive/ngBlur" target="_blank">ng-blur</a></code>-kuuntelija ja järjestä tehtävien taulukko prioriteetin mukaan, kun kenttä menettää fokuksen käyttämällä <code><a href="http://www.w3schools.com/jsref/jsref_sort.asp" target="_blank">sort</a></code>-funktiota).
      </li>
      <li>
        Käyttäjä voi nähdä muistilistan alalaidasta, kuinka monta tehtävää hän on tehnyt ja kuinka monta on vielä tekemättä. Käytä selkeää suomen kieltä, jolloin "1 tehtävä tehty" on oikein ja "1 tehtävää tehty" on väärin (vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngPluralize" target="_blank">ng-pluralize</a></code>). Voit toteuttaa toiminnon käyttämällä <code><a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$watch" target="_blank">$watch</a></code>-funktiota niin, että seuraat tehtävät sisältävää taulukkoa ja päivittää esimerkiksi muuttujien <code>todosDone</code> ja <code>todosRemaining</code> arvot aina, kun taulukossa tapahtuu muutoksia. <strong>Muista lisätä <code>$watch</code>-funktiokutsun viimeiseksi parametriksi <code>true</code>, niin Angular tarkastaa onko taulukossa tapahtunut muutoksia sen sisällön, eikä pelkän viitteen perusteella</strong>.
      </li>
    </ul>
    <p>
      <code>TodoController</code>-kontrollerin valmis pohja löytyy tiedostosta <code>app/controllers/todo_controller.js</code> ja näkymä tiedostosta <code>index.html</code>.
    </p>
  </p>
</div>
<h3>Direktiivit</h3>
<p>
  Jos olemme tarkkoja, emme ole puhuneet asioista täysin niiden oikeilla nimillä. Olemme puhuneet mm. <code>ng-repeat</code>, <code>ng-if</code> ja <code>ng-controller</code> yhteydessä pelkistä attribuuteista, joita annetaan DOM-elementeille. Toisaalta ne ovat sitä, mutta Angularin yhteydessä niillä on toinen nimi, <a href="https://docs.angularjs.org/guide/directive" target="_blank">direktiivi</a> (directive). Direktiivit ovat yksinkertaisesti tunnuksia (yleensä juuri attribuutteja) DOM-elementeissä, jotka kertovat Angularin HTML-kääntäjälle, että niihin pitää liittää erityisiä ominaisuuksia tai muuttaa elementtiä ja sen lapsielementtejä esimerkiksi lisäämällä niiden sisään toisia DOM-elementtejä tai muokkaamalla olemassaolevien elementtien esitystä.
</p>
<p>
  Sovellusta toteuttaessa tulee usein vastaan tilanne, jossa valmista direktiiviä ei löydy, jolloin se pitää joko toteuttaa itse, tai etsiä muualta. Angulariin on toteuttu lukuisia ulkopuolisia direktiivejä, mutta toteutetaan harjoituksen vuoksi yksi itse. Oman direktiivin luonti tapahtuu seuraavasti:
</p>
<pre class="sh_javascript_dom">
var App = angular.module('MyApp', []);

App.directive('counter', function(){
  // ...
});
</pre>
<p>
  Huomaat, että direktiivin luonti muistuttaa erehdyttävästi kontrollerin luontia. Kutsumme vain moduulillemme <code>directive</code>-funktiota ja annamme ensimmäiseksi parametriksi direktiivin nimen ja toiseksi anonyymin funktion. Tässä esimerkissä loin direktiivin <counde>counter</code>, jonka voin liittää DOM-elementtiin seuraavasti:
</p>
<pre class="sh_html">
&lt;button counter&gt;Kasvata&lt;/button&gt;
</pre>
<p>
  <code>counter</code>-direktiivi on nyt liitetty <code>button</code>-elementtiin, se ei tosin vielä tee mitään. Muista nimeämisessä että, jos direktiivisi nimi on esimerkiksi <code>MinunOmaDirektiivini</code>, voi sen lisätä DOM-elementtiin attribuutilla <code>minun-oma-direktiivini</code> (CamelCase-tyyli muuttuu viivoilla erotetuiksi sanoiksi). Laitetaan seuraavaksi direktiivimme esittämään käyttäjälle alert-ikkuna, kun siihen liittyvää elementtiä klikataan:
</p>
<pre class="sh_javascript_dom">
App.directive('counter', function(){
  return {
    link: function(scope, elem, attrs){
      $(elem).on('click', function(){
        alert('Klikkasit!');
      });
    }
  }
});
</pre>
<p>
  Direktiivin ominaisuudet liitetään objektiin, jonka toisena parametrina annettu anonyymifunktio palauttaa. Voimme liittää palautettuun objektiin kentän <code>link</code>, joka sisältää funktion, joka ottaa parametreikseen näkyvyysalueen, jossa direktiivi sijaitsee (<code>scope</code>), elementin, johon direktiivi on liitetty (<code>elem</code>) ja attribuutit, mikä kyseiseen elementtiin liittyy (<code>attrs</code>). Funktion avulla voimme manipuloida DOM-elementtiä, johon direktiivimme on liitetty, kuten liittää siihen tapahtumankuuntelijan. Voimme lisäksi funktiossa päästä käsiksi koko kontrollerin näkyvyysalueeseen, jonka sisällä direktiivimme sijaitsee <code>scope</code>-parametrin avulla. Nyt kun käyttäjä klikkaa "Kasvata"-painiketta, johon <code>counter</code>-direktiivi on liitetty, ilmestyy alert-ikkuna "Klikkasit!".
</p>
<p>
  <code>link</code>-kentässä määritellyn funktion ensimmäisen parametrin, <code>scope</code> avulla pääsemme käsiksi koko direktiivin näkyvyysalueeseen, joka on koko direktiivin ulkoinen näkyvyysalue. Usein haluamme kuitenkin määrittää direktiivillemme nk. eristetyn näkyvyysalueen, jonka avulla voimme kuvata direktiivin ulkoisen näkyvyysalueen sen sisäiseksi näkyvyysalueeksi. Se on kätevää, koska silloin direktiivinen toteutuksen ei tarvitse riippua siitä, minkä kontrollerin sisällä se on käytössä. Eristetyn näkyvyysalueen toteuttaminen onnistuu määrittelemällä palautettavaan objektiin kenttä <code>scope</code>, johon määrittelemme direktiivin näkyvyysalueen. Käytännössä voimme esimerkiksi käyttää <code>ng-model</code>-direktiivissä määriteltyä muuttujaa direktiivissämme seuraavasti:
</p>
<pre class="sh_javascript_dom">
App.directive('counter', function(){
  return {
    scope: {
      number: '=ngModel'
    },
    link: function(scope, elem, attrs){
      $(elem).on('click', function(){
        alert(scope.number);
      });
    }
  }
});
</pre>
<p>
  Lisäsimme siis palautettavaan objektiin <code>scope</code> kentän, jossa määritimme, että lisäämme direktiivimme näkyvyysalueseen muuttujan <code>number</code>, jonka arvo vastaa <code>ng-model</code>-direktiivissä määriteltyä arvoa. Merkkijonossa <code>=ngModel</code>, <code>=</code>-merkki tarkoittaa, että sidomme ulkoisen näkyvyysalueen muuttujan direktiivimme näkyvyysalueeseen ja <code>ngModel</code> viittaa vain direktiiviin <code>ng-model</code> (huomaathan, että attribuutti on muotoa <code>attribuutin-nimi</code>, mutta siihen viitataan nimellä <code>attribuutinNimi</code>).  Muokkasimme myös <code>link</code>-kentessä määriteltyä funktiota niin, että alert-ikkunaan ilmestyy näkyvyysalueeseen lisätyn <code>number</code>-muuttujan arvo. Muokataan vielä näkymää niin, että <code>button</code>-elementtiin lisätään <code>ng-model</code>-direktiivi, jonka arvo on muuttuja <code>value</code>:
</p>
<pre class="sh_html">
Laskurin arvo on: {{value}}
&lt;button counter ng-model="value"&gt;Kasvata&lt;/button&gt;
</pre>
<p>
  Koska muuttujan <code>value</code> arvoa ei ole vielä asetettu, "Kasvata"-painikkeen klikkaamisesta ilmestyvän alert-ikkunan sisältö on "undefined". Muokataan direktiiviämme vielä niin, että painikkeen klikkaaminen kasvattaa <code>ng-model</code>-direktiivissä määriteltyä arvoa:
</p>
<pre class="sh_javascript_dom">
App.directive('counter', function(){
  return {
    scope: {
      number: '=ngModel'
    },
    link: function(scope, elem, attrs){
      if(typeof scope.number == 'undefined'){
        scope.number = 0;
      }

      $(elem).on('click', function(){
        scope.$apply(function(){
          scope.number++;
        });
      });
    }
  }
});
</pre>
<p>
  Ratkaisimme alustamattoman <code>ng-model</code>-direktiivissä annetun muuttujan ongelman, asettamalla siinä tilanteessa <code>number</code>-muuttujan arvon nollaksi. Lisäsimme myös klikkauksen tapahtumankuuntelijaan <code>number</code>-arvon kasvatuksen. Huomaa, jotta arvon muokkaaminen välittyisi direktiivin ulkopuolelle, täytyy kutsua funktiota <code>$apply</code>, jolloin kerromme Angularille, että olemme tehneet muutoksia malliin ja ne muutokset pitäisi välittää näkymään. Yleensä <code>$apply</code>-funktiota ei tarvitse erikseen kutsua, koska Angular hoitaa sen puolestasi. Olemme tapahtumankuuntelijassa kuitenkin Angularin kontekstin ulkopuolella, joten meidän täytyy kutsua <code>$apply</code>-funktiota itse, jotta saamme välitettyä mallissa tehdyt muutokset näkymään.
</p>
<p>
  Lisätään vielä direktiiviimme yksi toiminto, jonka avulla sen käyttäjä kertoo, kuinka paljon hän haluaa muuttaa <code>ng-model</code>-direktiivissä määriteltyä arvoa. Sen voisi määritellä elementissä näin:
</p>
<pre class="sh_html">
Laskurin arvo on: {{value}}
&lt;button counter ng-model="value" amount="-2"&gt;Kasvata&lt;/button&gt;
</pre>
<p>
  Määritimme siis elementtiin <code>amount</code>-attribuutin, joka kertoo, että haluamme vähentää <code>value</code>-muuttujan arvoa kahdella jokaisen klikkauksen jälkeen. Joudumme vielä määrittämään <code>amount</code>-attribuutin direktiivimme eristettyyn näkyvyysalueeseen:
</p>
<pre class="sh_javascript_dom">
App.directive('counter', function(){
  return {
    scope: {
      number: '=ngModel',
      amount: '=amount'
    },
    link: function(scope, elem, attrs){
      if(typeof scope.number == 'undefined'){
        scope.number = 0;
      }

      $(elem).on('click', function(){
        scope.$apply(function(){
          scope.number+=parseInt(scope.amount);
        });
      });
    }
  }
});
</pre>
<p>
  Liitimme <code>amount</code>-muuttujan eristettyyn näkyvyysalueeseemme. Muutimme myös <code>link</code>-kentässä määriteltyä funktiota niin, että se kasvattaa (tai vähentää) <code>number</code>-muuttujan arvoa <code>amount</code>-muuttujan arvon verran jokaisen klikkauksen jälkeen. Muuttujan <code>amount</code> arvoksi olisi voinut asettaa näkymässä myös muuttujan. Se johtuu siitä, että lisäsimme sen direktiivimme näkyvyysalueeseen <code>=</code>-operaattorilla. Toinen mahdollinen operaattori olisi ollut <code>@</code>, mutta silloin näkymän <code>amount</code>-attribuutissa määriteltyä arvoa olisi käsitelty puhtaana arvona, ei muuttujana. Lopputulos on testattavissa <a href="http://plnkr.co/edit/CtAROoWeBUWMNWRnistW?p=preview" target="_blank">Plunkerissa</a>.
</p>
<p>
  Tämä osio oli vasta pintaraapaisu direktiivien käyttöön. Lisää niistä voi lukea <a href="https://docs.angularjs.org/guide/directive" target="_blank">Angularin Developer Guidesta</a>.
</p>
<div class="tehtavat">
  <h3>Slider-direktiivi</h3>
  <p>
    <iframe width="100%" height="200" src="http://jsfiddle.net/5TTm4/2852/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
  </p>
  <p>
    Tehtävänäsi on toteuttaa jQueryn <a href="http://jqueryui.com/slider/" target="_blank">slider</a>-widgetti (katso yllä oleva jsFiddle) <code>slider</code>-nimisenä direktiivinä, joka käyttää hyväksi jQueryn tarjoamaa <code>slider</code>-funktiota, jonka avulla sliderin voi luoda esimerkiksi seuraavasti:
</p>
<pre class="sh_javascript_dom">
$("#slider").slider({
  value: 10,
  slide: function(event, ui){
    console.log('Liikutit slideria!')
  }
});
</pre>
<p>
  Lue lisää <code>slider</code>-funktion parametreista <a href="http://api.jqueryui.com/slider/" target="_blank">täältä</a>.
</p>
<p>
    Tarkoitus on, että kun käyttäjä muuttaa sliderin arvoa, myös siihen <code>ng-model</code>-direktiivin avulla sidotun muuttujan arvo muuttuu. Sliderin alkuarvon tulee olla sama, kuin siihen sidotun muuttujan arvo. Voit olettaa etta <code>ng-model</code>-direktiivissä sidottu muuttuja on kokonaisluku. Sliderin <a href="http://jqueryui.com/slider/#steps" target="_blank">stepin</a> (kuinka paljon sliderin arvo muuttuu liikutuksesta) voit päätää itse. Näkymässä esimerkiksi <code>div</code>-elementtiin sidottu <code>slider</code>-direktiivi näyttäisi tältä:
  </p>
<pre class="sh_html">
&lt;div slider ng-model="number"&gt;&lt;/div&gt;
</pre>
<p>
  Tehtäväpohjasta löytyy valmis pohja direktiiville tiedostosta <code>app/directives/slider.js</code>. Kun näkymässä <code>index.html</code>-upotetun <code>number</code>-muuttujan arvo muuttuu sliderin liikuttamisen perusteella ja sliderin alkuperäinen sijainti vastaa muuttujan alkuarvoa (joka on <code>10</code>), tehtävä on valmis.
</p>
</div>
</section>



<section class="week">
  <header>
    <a name="viikko5"></a>
    <h1 data-week-id="5">Viikko 5</h1>
  </header>
  <h2>Jatketaan keskustelua palvelimen kanssa: Firebase</h2>
    <p>
      Viime viikolla kehitimme upean muistilistasovelluksen (tehtävä TodoApp), johon pystyi lisäämään muistettavia asioita ja merkkaamaan niitä tehdyiksi. Tylsä puoli sovelluksessa oli se, ettei se tallettanut lisäämiämme muistutuksia mihinkään. Korjaamme sen puolen sovelluksestamme tällä viikolla ottamalla käyttöön <a href="https://www.firebase.com/">Firebasen</a>, jonka avulla voimme tallettaa ja muuttaa dataa reaaliajassa. Kuulostaa siistiltä!
    </p>
    <p>
      Aloita rekisteröitymällä Firebaseen <a href="https://www.firebase.com/signup/">täältä</a>. Kun olet rekisteröitynyt sinut ohjataan käyttäjäsi dashboardille, jossa ensimmäinen sovelluksesi on jo alustettu puolestasi nimellä "My first app". Olemme siis jo periaatteessa valmiita, katsotaan seuraavaksi hieman, miten saamme kytkettyä Firebasen Angular-sovellukseemme.
    </p>
    <h3>Firebase ja Angular</h3>
    <p>
      Firebasella on oma moduuli (jonka nimi on yllätys ja yllätys <code>firebase</code>), joka tarjoaa työkalut datamme muokkaamiseen ja hakemiseen. <code>firebase</code>-moduuli on sisällä jokaisessa tehtäväpohjassa, joten riittää vain, että injektoit sen omaan <code>MyApp</code>-moduuliisi seuraavasti:
    </p>
<pre class="sh_javascript_dom">
var MyApp = angular.module('MyApp', ['firebase']);
</pre>
<p>
  Kun <code>firebase</code> moduuli on injektoitu omaan moduuliimme, pääsemme käyttämään sen tarjoamia palveluita. Seuraavaksi meidän täytyy toteuttaa omalle kontrollerillemme palvelu, joka hoitaa Firebasen kanssa keskustelmisen.
</p>
<h3>Palvelut (services)</h3>
<p>
  Palvelut ovat Angularissa kontrollereihin ja toisiin palveluihin injektoitavia komponentteja, jotka, kuten jo nimestä voi päätellä, tarjoavat sen käyttäjälle jonkin palvelun. Palvelu voi olla esimerkiksi API tiedon hakuun palvelimelta tai joukko funktioita, jotka tekevät eri joukko-operaatioita:
</p>
<pre class="sh_javascript_dom">
var MyApp = angular.module('MyApp', []);

MyApp.service('Set', function(){
  return {
    intoSet: function(arr){
      var set = [];

      arr.forEach(function(item){
        if(set.indexOf(item) < 0){
          set.push(item);
        }
      });

      return set;
    },

    union: function(arrA, arrB){
      var setA = this.intoSet(arrA);
      var setB = this.intoSet(arrB);

      setB.forEach(function(item){
        if(setA.indexOf(item) < 0){
          setA.push(item);
        }
      });

      return setA;
    },

    intersection: function(arrA, arrB){
      var setA = this.intoSet(arrA);
      var setB = this.intoSet(arrB);

      var intersected = [];

      setA.forEach(function(item){
        if(setB.indexOf(item) >= 0){
          intersected.push(item);
        }
      });

      return intersected;
    }
  }
});
</pre>
<p>
  Palvelun saa liitettyä moduulin täysin samaan tapaan kuin kontrollerinkin, kutsumme vain moduulillemme <code>controller</code>-funktion sijasta funktiota <code>service</code>. Funktio ottaa parametrikseen palvelun nimen merkkijonona ja funktion, joka palauttaa objektina palvelun tarjoamat funktiot. Huomaat varmasti, että palvelun rakenne muistuttaa hyvin paljon <a href="http://en.wikipedia.org/wiki/Module_pattern" target="_blank">Module pattern</a>-suunnittelumallia. Palveluiden luominen onkin hyvä tapa jakaa ohjelmaa pieniin ja helposti hallittaviin komponentteihin. Otetaan toteuttamme palvelu käyttöön kontrollerissa:
</p>
<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, Set) {
    $scope.union = function(){
       var arrA = $scope.arrA.split(',');
       var arrB = $scope.arrB.split(',');

       $scope.result = Set.union(arrA, arrB).toString();
    }

    $scope.intersection = function(){
       var arrA = $scope.arrA.split(',');
       var arrB = $scope.arrB.split(',');

       $scope.result = Set.intersection(arrA, arrB).toString();
    }
});
</pre>
<p>
  Voimme käyttää siis toteuttamaamme palvelua injektoimalla sen kontrolleriimme lisäämällä sille parametrin <code>Set</code>. Palvelun tarjoamat funktiot ovat sen jälkeen käytettävissä kontrollerissa. Tässä vielä lopullinen versio:
  <iframe width="100%" height="300" src="http://jsfiddle.net/HB7LU/11001/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</p>
<h4>Firebase-palvelu</h4>
<p>
  Voisimme periaatteessa upottaa kaiken Firebasen käyttöön liittyvän logiikan suoraan kontrolleriimme, mutta siitä tulisi erittäin sekavaa. Tehdään sen sijaan moduuliimme palvelu (service), joka hoitaa Firebasen kanssa keskustelemisen kontrollerimme puolesta, niin kontrolleristamme tulee selkeämpi ja se noudattaa paremmin jo mainittua "Single Responsibility"-periaatetta. Liitetään moduuliimme aluksi <code>FirebaseService</code>-niminen palvelu:
</p>
<pre class="sh_javascript_dom">
var MyApp = angular.module('MyApp', ['firebase']);

MyApp.service('FirebaseService', function($firebase){
  // ...
});
</pre>
<p>
  Injektoin siis ensin <code>firebase</code>-moduulin omaan moduuliini ja sen jälkeen sen tarjoaman <code>$firebase</code>-palvelun omaan <code>FirebaseService</code>-palveluuni.
</p>
<img src="img/firebase_content.png" style="float: right; width: 300px; margin-left: 15px;">
<p>
  Ennen kuin etenemme pidemmälle, lisätään sovellukseemme hieman dataa Firebasen kautta. Siirry ensin käyttäjäsi dashboardille ja klikkaa "My first app" alapuolelta painiketta "Manage app". Sivulle aukee sovelluksesi datasisältö, joka on tällä hetkellä tyhjä. Lisätään sovellukseen dataa, viemällä hiiri sovelluksemme datan osoitteen päälle (se on hassu nimi, kuten scorching-torch-2360), jolloin sen viereen ilmestyy vihreä "+"-painike, paina sitä. Kun olet painanut "+"-painiketta ilmestyy datan osoitteen alapuolelle tekstikentät <code>name</code> ja <code>value</code>. Kirjoita <code>name</code>-kenttään "message" ja <code>value</code>-kenttään "Hello World!" ja paina kenttien vierestä vihreää "+"-painiketta. Sovelluksessamme on nyt dataa, joka on objekti <code>{ message: 'Hello World!' }</code>, jonka rakenteen määrittelimme <code>name</code>- ja <code>value</code>-kenttien kautta. Katsotaan seuraavaksi, miten voimme hakea tämän datan sovelluksestamme käsin.
</p>
<h4>Datan haku Firebasesta</h4>
<p>
  Olen jo saanut valmiiksi <code>FirebaseService</code>-palveluni rungon. Lisään siihen seuraavaksi funktion, joka hakee datani Firebasesta:
</p>
<pre class="sh_javascript_dom">
MyApp.service('FirebaseService', function($firebase){
  var firebaseRef = new Firebase('OMA_FIREBASE');
  var sync = $firebase(firebaseRef);
  var data = sync.$asObject();

  this.fetchData = function(){
    return data;
  }
});
</pre>

<img src="img/firebase_data_url.png" style="float: left; width: 300px; margin-right: 15px;">
<p>
  Käydään läpi, mitä <code>FirebaseService</code>-palvelussa oikein tapahtuu. Talletan aluksi <code>firebaseRef</code>-muuttujaan <code>Firebase</code>-olion, joka ottaa parametrikseen sovelluksemme datasäilön sijainnin (joudut vaihtamaan kohtaan <code>OMA_FIREBASE</code> oman datasi sijainnin, joka löytyy dashboardiltasi kuvan osoittamasta paikasta). Datasi sijainti on muotoa <code>https://FIREBASE_KAYTTAJANI.firebaseio.com</code>. Sen jälkeen lisään palveluuni funktion <code>fetchData</code> kontrollerin käyttöä varten. Funktiossa talletan referenssin dataani kutsumalla injektoimaani <code>$firebase</code>-funktiota omalla <code>Firebase</code>-oliollani. Sen jälkeen voin hakea sovellukseni datan kutsumalla referenssille funktiota <code>$asObject()</code>. Otetaan seuraavaksi palvelu käyttöön kontrollerissa:
</p>
<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, FirebaseService){
  $scope.data = FirebaseService.fetchData();
});
</pre>
<p>
  Riittää siis vain injektoida toteutettu <code>FirebaseService</code>-palvelu kontrolleriin ja olemme valmiita käyttämään sitä. Voimme näyttää Firebasesta hakemamme datan, joka oli objekti <code>{ message: 'Hello World!' }</code> näkymässämme, aivan kuten muutkin muuttujat:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;div ng-controller="MyController"&gt;
      &lt;h1&gt;{{data.message}}&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Näkymään ilmestyy otsikko "Hello World!", joten datan hakeminen Firebasesta on onnistunut.
</p>
<div class="tehtavat">
  <h3>Hello Firebase!</h3>
  <p>
    <a href="https://www.firebase.com/signup/" target="_blank">Rekisteröidy</a> Firebaseen ja lisää sinne dataa, jonka sisältö on <code>{ message: 'Hello World!' }</code> (<code>message</code>-kenttä, jonka arvo on "Hello World"). Muista, että voit lisätä sovellukseesi dataa suoraan Firebasesta siirtymällä dashboardilta sovelluksesi hallintaan klikkaamalla "Manage App".
  </p>
  <p>
    Muokkaa tehtäväpohjaa siten, että <code>app/services/firebase_service.js</code>-tiedostossa sijaitseva <code>FirebaseService</code>-palvelu hakee lisäämäsi datan Firebasesta (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebase-asobject" target="_blank">$asObject</a></code>). Muokkaa sen jälkeen <code>app/controllers/hello_controller.js</code>-tiedossa sijaitsevaa <code>HelloController</code>-kontrolleria niin, että se käyttää <code>FirebaseService</code>-palvelua hakemaan Firebasesta viestin "Hello World!" ja esittää sen näkymässä esimerkiksi muuttujan <code>message</code> arvona. Muista injektoida <code>FirebaseService</code> kontrolleriin, muuten sen käyttäminen ei onnistu!
  </p>
</div>
<h4>Datan lisääminen Firebaseen</h4>
<p>
  Olemme onnistuneet hakemaan dataa Firebasesta, joten seuraava looginen askel on katsoa, miten voimme lisätä sinne dataa. Paltaan takaisin <code>FirebaseService</code>-palvelumme pariin ja lisätään siihen funktio <code>addMessage</code>, joka lisää parametrina saadun objektin Firebaseen:
</p>
<pre class="sh_javascript_dom">
MyApp.service('FirebaseService', function($firebase){
  var firebaseRef = new Firebase('OMA_FIREBASE/messages');
  var sync = $firebase(firebaseRef);
  var messages = sync.$asArray();

  this.addMessage = function(message){
    messages.$add(message);
  }
});
</pre>
<p>
  Tämä eroaa melko datan lisäämisestä, joten on hyvä käydä läpi, mitä oikein tapahtuu. Aluksi alustin uuden <code>Firebase</code>-olion melkein samaan tapaan kuin datan hakemisen kanssa, pientä yksityiskohtaa lukuunottamatta. Huomasit ehkä, että lisäsin Firebase-polkuni perään <code>/messages</code>. Tein sen siitä syystä, että haluan hakea ja tehdä muutoksia vain resurssiin <code>messages</code>. Sen jälkeen kutsun <code>$firebase</code>-funktiota alustamallani <code>Firebase</code> oliolla aivan, kuten datan lisäämisen kanssa. Seuraavaksi en kuitenkaan kutsu referenssille funktiota <code>$asObject</code>, vaan <code>$asArray</code>, koska haluan käsitellä dataani taulukkona objektin sijaan. Se on melko loogista, koska haluan hakea ja muokata joukkoa viestejä.
</p>
<p>
  Alustus on tehty, pureudutaan seuraavaksi funktioon <code>addMessage</code>. Sen toteutus on erittäin yksinkertainen, kutsun vain <code>messages</code>-resurssilleni funktiota <code>$add</code>, joka lisää parametrina saadun objektin taulukkoon muiden viestien sekaan. Ei siis sen kummempaa. Käytetään toteuttamaamme palvelua vielä kontrollerissamme:
</p>
<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, FirebaseService){
  $scope.newText = '';

  $scope.addMessage = function(){
    if($scope.newText != ''){
      FirebaseService.addMessage({
        text: $scope.newText
      });

      $scope.newText = '';
    }
  }
});
</pre>
<p>
  Nyt voimme sitoa näkymässä tekstikentän arvon muuttujaan <code>newText</code> ja sitoa painikkeen painalluksen funktion <code>addMessage</code>-kutsuun:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;div ng-controller="MyController"&gt;
      &lt;textarea ng-model="newText"&gt;&lt;/textarea&gt;
      &lt;button ng-click="addMessage()"&gt;Lisää viesti&lt;/button&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Pystyn nyt lisäämään dataa Firebaseen, mutta en pääse tarkkailemaan sitä muualta, kuin Firebase käyttäjäni dashboardilta. Lisätään siis vielä <code>FirebaseService</code>-palveluun funktio <code>getMessages</code>, joka hakee kaikki viestit <code>messages</code>-resurssista, jotta voimme näyttää ne näkymässä:
</p>
<pre class="sh_javascript_dom">
MyApp.service('FirebaseService', function($firebase){
  var firebaseRef = new Firebase('OMA_FIREBASE/messages');
  var sync = $firebase(firebaseRef);
  var messages = sync.$asArray();

  this.addMessage = function(message){
    messages.$add(message);
  }

  this.getMessages = function(){
    return messages;
  }
});
</pre>
<p>
  Todella helppoa! Palautan siis vain <code>getMessages</code>-funktiossa <code>messages</code>-taulukon, joka sisältää kaikki sovellukseni viestit. Muokataan vielä hieman kontrolleriamme:
</p>

<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, FirebaseService){
  $scope.messages = FirebaseService.getMessages();
  $scope.newText = '';

  $scope.addMessage = function(){
    if($scope.newText != ''){
      FirebaseService.addMessage({
        text: $scope.newText
      });

      $scope.newText = '';
    }
  }
});
</pre>
<p>
  Huomaa, ettei <code>addMessage</code>-funktiossa uutta viestiä tarvitse lisätä erikseen <code>messages</code>-taulukkoon, sillä Firebase synkronoi taulukon sisällön lisäämisen yhteydessä puolestasi. Kätevää! Listataan <code>messages</code>-taulukon alkiot vielä näkymässä:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;div ng-controller="MyController"&gt;
      &lt;ul&gt;
        &lt;li ng-repeat="message in messages"&gt;{{message.text}}&lt;/li&gt;
      &lt;/ul&gt;
      &lt;textarea ng-model="newText"&gt;&lt;/textarea&gt;
      &lt;button ng-click="addMessage()"&gt;Lisää viesti&lt;/button&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Se on siinä! Olemme toteuttaneet pienen chatin, seuraavaksi saat hieman parannella sitä.
</p>
<div class="tehtavat">
  <h3>Chat (2p)</h3>
  <p>
    Parannellaan hieman yllä olevaa esimerkkiä lisäämällä chattiin käyttäjät. Vinkki: pidä käyttäjät ja viestit erillisinä resursseina Firebasessa, esimerkiksi näin:
  </p>
<pre class="sh_javascript_dom">
var messagesFirebaseRef = new Firebase('OMA_FIREBASE/messages');
var messagesSync = $firebase(messagesFirebaseRef);
var messages = messagesSync.$asArray();

var usersFirebaseRef = new Firebase('OMA_FIREBASE/users');
var usersSync = $firebase(usersFirebaseRef);
var users = usersSync.$asArray();
</pre>
  <p>
    Kun käyttäjä avaa sovelluksen, pyydä häntä valitsemaan itselleen käyttäjätunnus. Jos käyttäjätunnus löytyy ennestään, älä lisää sitä uudestaan Firebaseen (vinkki: hae kaikki käyttäjät Firebasesta ja katso, löytyykö sieltä käyttäjän antamaa käyttäjätunnusta), muuten lisää uusi käyttäjä (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-addnewdata" target="_blank">$add</a></code>). Kun käyttäjätunnus on valittu (vinkki: piilota chatti-näkymä kunnes käyttäjätunnuksella on arvo, esimerkiksi <code>ng-show</code>-direktiivin avulla), näytä näkymässä chatin viestit ja sen vieressä chatin käyttäjät. Kun käyttäjä lisää viestin chattiin, näytä viestin vieressä hänen käyttäjänimensä ja sen alapuolella, milloin viesti on lisätty (vinkki: <code><a href="http://www.w3schools.com/jsref/jsref_obj_date.asp" target="_blank">Date</a></code>). Lisää siis Firebaseen talletettavaan viestiin esimerkiksi kenttä <code>username</code> (käyttäjätunnukselle) ja <code>added</code> (viestin lisäämisen ajalle). Älä anna käyttäjän lisätä chattiin tyhjää viestiä.
  </p>
  <p>
    Tehtäväpohjasta löytyy <code>ChatController</code>-kontrollerin pohja tiedostosta <code>app/controllers/chat_controller.js</code> ja Firebasen kanssa keskustelevan <code>FirebaseService</code>-palvelun pohja tiedostosta <code>app/services/firebase_service.js</code>. Näkymä löytyy tutusta <code>index.html</code>-tiedostosta.
  </p>
</div>
<h4>Olemassaolevan datan muokkaaminen ja poistaminen Firebasessa</h4>
<p>
  Katsotaan vielä pari höydyllistä Firebasen toimintoa ennen kuin siirrymme muiden aiheiden pariin. Tarkastellaan ensin, miten voimme muokata olemassaolevaa dataa. Käytetään esimerkkinä edellisessä osiossa toteuttamaamme pientä chatti-sovellusta. Lisätään <code>FirebaseService</code>-palveluun funktio <code>editMessage</code>, joka tallettaa parametreina saatuun viestiin tehdyt muutokset:
</p>
<pre class="sh_javascript_dom">
MyApp.service('FirebaseService', function($firebase){
  var firebaseRef = new Firebase('OMA_FIREBASE/messages');
  var sync = $firebase(firebaseRef);
  var messages = sync.$asArray();

  this.addMessage = function(message){
    messages.$add(message);
  }

  this.getMessages = function(){
    return messages;
  }

  this.editMessage = function(message){
    messages.$save(message);
  }
});
</pre>
<p>
  Funktiossa <code>editMessage</code> kutsumme <code>messages</code>-resurssille funktiota <code>$save</code>, joka päivittää parametrina saadun alkion Firebasessa. Tehdään seuraavaksi kontrolleriin saman niminen funktio, joka käyttää toteuttamaamme funktiota:
</p>
<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, FirebaseService){
  $scope.messages = FirebaseService.getMessages();
  $scope.newText = '';
  $scope.editText = ''

  $scope.addMessage = function(){
    if($scope.newText != ''){
      FirebaseService.addMessage({
        text: $scope.newText
      });

      $scope.newText = '';
    }
  }

  $scope.showEditForm = function(message){
    $scope.editText = message.text;
    message.editing = true;
  }

  $scope.editMessage = function(message){
    if($scope.editText != ''){
      delete message.editing

      message.text = $scope.editText;
      FirebaseService.editMessage(message);

      $scope.editText = '';
    }
  }
});
</pre>
<p>
  Lisäsin <code>editMessage</code>-funktion lisäksi funktion, jonka avulla näytän viestin muokkauslomakkeen. Funktio <code>showEditForm</code> näyttää parametrina saadun viestin muokkauslomakkeen asettamalla sen <code>editing</code>-kentän arvoksi <code>true</code>. Kun muokkaan viestiä <code>editMessage</code>-funktiossa, poistan siitä kentän <code>editing</code> ennen kuin muokkaan sitä, jotta sitä ei talletettaisi Firabaseen. Katsotaan vielä, miten näitä funktioita käytetään näkymässä:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;div ng-controller="MyController"&gt;
      &lt;ul ng-repeat="message in messages"&gt;
        &lt;li&gt;
          {{message.text}}

          &lt;button ng-click="showEditForm(message)" ng-hide="message.editing"&gt;Muokkaa&lt;button&gt;

          &lt;p ng-show="message.editing"&gt;
            &lt;textarea ng-model="editText"&gt;&lt;/textarea&gt;
            &lt;button ng-click="editMessage(message)"&gt;Lisää viesti&lt;/button&gt;
          &lt;/p&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;textarea ng-model="newText"&gt;&lt;/textarea&gt;
      &lt;button ng-click="addMessage()"&gt;Lisää viesti&lt;/button&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Lisäsin jokaisen viestin alle sen muokkauslomakkeen, joka näytetään vain, jos sen <code>editing</code>-kentän arvo on <code>true</code>. Muokkauslomakkeen avaaminen onnistuu klikkaamalla "Muokkaa"-painiketta, jonka klikkaaminen kutsuu <code>showEditForm</code>-funktiota. Muokkauslomakkeesta "Lähetä"-painikkeen painallus taas kutsuu <code>editMessage</code>-funktiota, joka muokkaa viestin sisältöä painikkeen yllä olevan tekstikentän perusteella, joka on sidottu muuttujan <code>editText</code> arvoon.
</p>
<p>
  Kun olemme päässeet vauhtiin, toteutetaan vielä viestin poistotoiminto. Palataan takaisin <code>FirebaseService</code>-palvelun pariin ja lisätään sinne funktio <code>removeMessage</code>, joka poistaa parametrina annetun pelin Firebasesta:
</p>
<pre class="sh_javascript_dom">
MyApp.service('FirebaseService', function($firebase){
  var firebaseRef = new Firebase('OMA_FIREBASE/messages');
  var sync = $firebase(firebaseRef);
  var messages = sync.$asArray();

  this.addMessage = function(message){
    messages.$add(message);
  }

  this.getMessages = function(){
    return messages;
  }

  this.editMessage = function(message){
    messages.$save(message);
  }

  this.removeMessage = function(message){
    messages.$remove(message);
  }
});
</pre>
<p>
  Saatoit jo melkein arvata, miten <code>removeMessage</code>-funktio toteutetaan. Kuten ennenkin, selviämme yhdellä rivillä koodia, tällä kertaa kutsumme <code>messages</code>-resurssille funktiota <code>$remove</code>, joka poistaa parametrina annetun alkion Firebasesta. Toteutetaan vielä kontrolleriin <code>removeMessage</code>-metodi:
</p>
<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, FirebaseService){
  $scope.messages = FirebaseService.getMessages();
  $scope.newText = '';
  $scope.editText = ''

  $scope.addMessage = function(){
    if($scope.newText != ''){
      FirebaseService.addMessage({
        text: $scope.newText
      });

      $scope.newText = '';
    }
  }

  $scope.showEditForm = function(message){
    $scope.editText = message.text;
    message.editing = true;
  }

  $scope.editMessage = function(message){
    if($scope.editText != ''){
      delete message.editing

      message.text = $scope.editText;
      FirebaseService.editMessage(message);

      $scope.editText = '';
    }
  }

  $scope.removeMessage = function(message){
    FirebaseService.removeMessage(message);
  }
});
</pre>
<p>
  Kontrollerissa ei tapahdu mitään kovin kummallista, <code>removeMessage</code>-funktiossa kutsutaan vain <code>FirebaseService</code>-palvelun tarjoamaa <code>removeMessage</code>-funktiota. Lisätään vielä näkymään panike, jonka painallus kutsuu toteuttamaamme funktiota:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;div ng-controller="MyController"&gt;
      &lt;ul ng-repeat="message in messages"&gt;
        &lt;li&gt;
          {{message.text}}

          &lt;button ng-click="removeMessage(message)"&gt;Poista&lt;button&gt;
          &lt;button ng-click="showEditForm(message)" ng-hide="message.editing"&gt;Muokkaa&lt;button&gt;

          &lt;p ng-show="message.editing"&gt;
            &lt;textarea ng-model="editText"&gt;&lt;/textarea&gt;
            &lt;button ng-click="editMessage(message)"&gt;Lisää viesti&lt;/button&gt;
          &lt;/p&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;textarea ng-model="newText"&gt;&lt;/textarea&gt;
      &lt;button ng-click="addMessage()"&gt;Lisää viesti&lt;/button&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Näkymässä "Poista"-painikkeen painallus kutsuu funktiota <code>removeMessage</code>. Huomaa, ettei poistamisen yhteydessä tarvitse poistaa alkiota erikseen <code>messages</code>-taulukossa, koska Firebase synkronoi taulukon sisällön automaattisesti.
</p>
<div class="tehtavat">
  <h3>TodoApp ja Firebase (3p)</h3>
  <p>
    Toteutimme viime viikolla muistilistan, jonka mallivastaus löytyy tehtäväpohjasta. Voit halutessasi korvata mallivastauksen omalla toteutuksellasi. Toteuta sovellukseen palvelu, joka keskustelee Firebasen kanssa niin, että muistilistan tehtäviä pystyy lisäämään (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-addnewdata" target="_blank">$add</a></code>), merkkaamaan tehdyiksi (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-saverecordorindex" target="_blank">$save</a></code>) ja poistamaan (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-removerecordorindex" target="_blank">$remove</a></code>) Firebasesta. Kaikki viime viikolla toteutetut toiminnot tulee siis nyt toteuttaa käyttämällä Firebasea. Valmiissa tehtäväpohjassa Firebasen kanssa keskustelevan <code>FirebaseService</code>-palvelun pohja löytyy tiedostosta <code>app/directives/firebase_service.js</code>, kontrolleri <code>TodoController</code> tiedostosta <code>app/controllers/todo_controller.js</code> ja näkymä tiedostosta <code>index.html</code>. Tee siis tarvittavat muutokset palveluun, kontrolleriin ja näkymään.
  </p>
</div>
    <h2>Testaaminen</h2>
  <p>
    Yksi Angularin käytön hyvä puoli on se, että se on helposti testattava, kunhan käytettävät työkalut on oikeat. Ensimmäiseksi tarvitaan työkalu, joka käytännössä ajaa testit. Tähän tehtävään käytetään usein Angularin kanssa <a href="http://karma-runner.github.io/0.12/index.html" target="_blank">Karmaa</a>. Se on komentorivityökalu, jonka avulla voimme muodostaa tilapäisen web-palvelimen, joka lataa sovelluksesi lähdekoodit ja ajaa testisi ja kertoo, mitkä niistä läpäistiin ja mitkä ei. Karman lisäksi tarvitsemme testaamista varten kehitetyn sovelluskehyksen, jota käyttäen voimme toteuttaa sovelluksellemme testit. Sitä varten on kehitetty <a href="http://jasmine.github.io/1.3/introduction.html" target="_blank">Jasmine</a>, joka on "<a href="http://en.wikipedia.org/wiki/Behavior-driven_development" target="_blank">Behavior-driven</a>"-sovelluskehitykseen (BDD) toteutettu sovelluskehys JavaScript-koodin testaamiseen.
  </p>
<h3>Testaaminen Jasminella</h3>
<p>
  Jasminella toteutettu testi alkaa <code>describe</code>-funktion kutsulla, joka ottaa ensimmäiseksi parametrikseen merkkijonon, joka on testijoukon nimi, tai otsikko ja toiseksi parametrikseen anonyymin funktion, joka sisältää itse testit:
</p>
<pre class="sh_javascript_dom">
describe('An example', function(){
  // ...
});
</pre>
<p>
  Eli määrittelemme testijoukon nimeltä "An example" kutsumalla <code>describe</code>-funktiota. Itse testit sijoitetaan toisena parametrina annetun anonyymin funktion sisään. Jokainen testi on yksi <code>it</code>-funktion kutsu, jonka ensimmäinen parametri on <code>describe</code>-funktiossa määritellyn testijoukon yhden testattavan toiminnon nimi ja toinen parametri on anonyymifunktio, joka sisältää itse testin.
</p>
<pre class="sh_javascript_dom">
describe('An example', function(){
  it('should work when trying to match true with true', function(){
    var isTrue = true;
    expect(isTrue).toBe(true)
  })
});
</pre>
<p>
  Testin sisällä määritämme, että haluamme tarkkailla <code>isTrue</code>-muuttujan arvoa kutsumalla <code>expect</code>-funktiota se parametrinaan. Sen jälkeen ketjutamme sen perään funktiokutsun, jonka avulla kohdistamme <code>isTrue</code>-muuttujan arvoon jonkin oletuksen. Tässä esimerkissä oletimme sen arvon olevan <code>true</code> kutsumalla <code>toBe</code>-funktiota. Koodi on niin selkeää, että sen voi oikeastaan lukea ääneen - "expect isTrue to be true", eli "oletetaan, että isTrue on true". Muuttujaan liittyviä oletuksia on lukuisia, tässä tärkeimpiä:
</p>
<pre class="sh_javascript_dom">
describe('An example', function(){
  it('should work when trying to match true with true', function(){
    var isTrue = true;
    expect(isTrue).toBe(true)
  });

  it('should work with negation', function(){
    var isFalse = false;
    // negaatiota, not, voi käyttää kaikkien oletuksien kanssa
    expect(isFalse).not.toBe(true);
  });

  it('should work when checking object equality', function(){
    var foo = {
      a: 12,
      b: 34
    };

    var bar = {
      a: 12,
      b: 34
    };

    // foo- ja bar-objektit ovat samat, jos niissä on samat kentät, joiden arvot ovat samat
    expect(foo).toEqual(bar);
  });

  it('should work when checking variable existence', function(){
    var foo = 'bar';
    // oletetaan, että muuttuja foo on määritelty
    expect(foo).toBeDefined();
  });

  it('should work when checking if item is in array', function(){
    var names = ['Elina', 'Kalle', 'Arto', 'Jorma', 'Matti']
    // oletetaan, että taulukossa names on alkio "Elina"
    expect(names).toContain('Elina');
  });

  it('should work when checking if the value is less or greater than another', function(){
    var age = 21;
    // oletetaan, että age on suurempi kuin 18
    expect(age).toBeGreaterThan(18);
    // oletetaan, että age on pienempi kuin 50
    expect(age).toBeLessThan(50);
  });
});
</pre>
<p>
  Tässä vain pieni osa mahdollisia oletuksia muuttujan arvolle. Kuten huomaat, oletuksien nimeäminen on niin selkeää, että tiedät heti, mitä muuttujalta oletetaan. Voit lukea lisää Jasminen oletuksista sen <a href="http://jasmine.github.io/2.0/introduction.html#section-Expectations" target="_blank">dokumentaatiosta</a>. Katsotan seuraavaksi, miten pystymme testaamaan Angular-sovellustamme Jasminella.
</p>
<p>
  Usein testeissä on toiston välttämäksi suorittaa jotain toimenpiteitä, kuten muuttujien määrittelemistä, ennen jokaista testiä, tai jokaisen jälkeen. Siihen voimme käyttää <code>beforeEach</code> ja <code>afterEach</code>-funktioita. Molemmat ottavat parametrikseen funktion, joka suoritetaan joko ennen jokaista <code>it</code>-kutsua tai sen jälkeen:
</p>
<pre class="sh_javascript_dom">
describe('Kalle', function(){
  var kalle;

  beforeEach(function(){
    kalle = {
      name: 'Kalle',
      friends: ['Arto', 'Elina', 'Henri'];
    };
  });

  it('should have name Kalle', function(){
    expect(kalle.name).toBe('Kalle');
  });

  it('should have three friends', function(){
    expect(kalle.friends.length).toBe(3);
  });
});
</pre>
<p>
  Nyt muuttuja <code>kalle</code> alustetaan objektilla jokaisen testin alussa.
</p>
<h3>Angular sovelluksen testaaminen</h3>
<p>
  Testataan seuraavaksi yksinkertaista ystävälista sovellusta, jonka kautta käyttäjä voi lisätä ystäviä ystävälistalleen ja poistaa niitä. Sovelluksen toteutus on seuraava:
</p>
<pre class="sh_javascript_dom">
var FriendApp = angular.module('FriendApp', []);

FriendApp.controller('FriendListController', function($scope){
  $scope.friends = [];

  $scope.addFriend = function(){
    if($scope.newFriend != ''){
      $scope.friends.push($scope.newFriend);
      $scope.newFriend = '';
    }
  }

  $scope.removeFriend = function(index){
    if($scope.friends.length >= index){
      $scope.friends.splice(index, 1);
    }
  }
});
</pre>
<p>
  Haluamme testata <code>FriendListController</code>-kontrollerissa viittä eri asiaa:
  <ul>
    <li>Ystävälista on aluksi tyhjä.</li>
    <li>Ystävälistaan pystyy lisäämään ystävän kutsumalla <code>addFriend</code>-funktiota.</li>
    <li>Jos lisättän ystävän nimi on tyhjä, häntä ei lisätä ystävälistaan.</li>
    <li>Ystävän pystyy poistamaan ystävälistalta kutsumalla <code>removeFriend</code>-funktiota.</li>
    <li>Ystävää ei poisteta, jos häntä yritetään poistaa <code>friends</code>-taulukon ulkopuolelta.</li>
  </ul>
</p>
<p>
  Aloitetaan testaaminen kutsumalla Jasminen <code>describe</code>-funktiota:
</p>
<pre class="sh_javascript_dom">
describe('FriendListController', function(){
  var controller, scope;

  beforeEach(function(){
    module('FriendApp');

    inject(function($controller, $rootScope) {
      scope = $rootScope.$new();
      controller = $controller('FriendListController', {
        $scope: scope
      });
    });
  });

});
</pre>
<p>
  Jotta voimme testata kontrolleriamme, meidän täytyy ensin alustaa se ennen jokaista testiä, eli <code>it</code>-funktion kutsua. Kätevimmin se tapahtuu kutsumalla <code>beforeEach</code>-funktiota, jonka parametrina saatua funktiota kutsutaan jokaisen <code>it</code>-funktiokutsun alussa. Alustuksessa määrittelemme aluksi, mikä moduuli on testattavana kutsumalla <code>module</code>-funktiota, meidän tapauksessamme se on <code>FriendApp</code>. Seuraavaksi injektoimme testeihimme <code>FriendListController</code>-kontrollerimme ja injektoimme sen <code>$scope</code>-parametrin arvoksi globaalin <code>scope</code>-parametrin arvomme. Nyt pääsemme käsiksi kontrollerin näkyvyysalueeseen testeissämme <code>scope</code>-muuttujan kautta:
</p>
<pre class="sh_javascript_dom">
describe('FriendListController', function(){
  var controller, scope;

  beforeEach(function(){
    module('FriendApp');

    inject(function($controller, $rootScope) {
      scope = $rootScope.$new();
      controller = $controller('FriendListController', {
        $scope: scope
      });
    });
  });

  it('should be initialized with an empty friend list', function(){
    expect(scope.friends.length).toBe(0);
  });

  it('should be able to add a friend', function(){
    expect(scope.friends.length).toBe(0);
    scope.newFriend = 'Arto';
    scope.addFriend();
    expect(scope.friends.length).toBe(1);
  });

  it('should not be able to add a friend with an empty name', function(){
    expect(scope.friends.length).toBe(0);
    scope.newFriend = '';
    scope.addFriend();
    expect(scope.friends.length).toBe(0);
  });

  it('should be able to remove a friend', function(){
    scope.friends = ['Arto', 'Matti', 'Elina', 'Kalle'];
    expect(scope.friends.length).toBe(4);
    scope.removeFriend(0);
    expect(scope.friends.length).toBe(3);
    expect(scope.friends).not.toContain('Arto');
  });

  it('should not be able to remove a friend outside the array boundaries', function(){
    scope.friends = ['Kalle', 'Elina'];
    expect(scope.friends.length).toBe(2);
    scope.removeFriend(6);
    expect(scope.friends.length).toBe(2);
  });
});
</pre>
<p>
  <code>FriendListController</code>-kontrollerille on nyt kirjoitettu viisi eri testiä, joista jokainen on oma <code>it</code>-funktion kutsunsa. Testeissä ei tapahdu mitään kovin erikoista, kutsumme <code>scope</code>-muuttujan kautta kontrollerissamme määriteltyjä <code>addFriend</code>- ja <code>removeFriend</code>-funktiota ja varmistamme, etteivät ne tee mitään kummallista <code>friends</code>-taulukolle.
</p>
<h3>Testien suorittaminen</h3>
<p>
  Tarvitset tässä vaiheessa NetBeansin versiota 8.0.1, tai uudempaa. Uusimman version voit asentaa <a href="https://netbeans.org/downloads/" target="_blank">täältä</a>. Testien ajamiseen tarvitsemme jo mainitun Karman, joka taas tarvitsee toimiakseen <a href="http://nodejs.org/" target="_blank">Node.js</a>:ssän. Lisäksi tarvitsemme <a href="http://git-scm.com/" target="_blank">Git</a>:iä riippuvuuksien hallintaan. Alla on asennusohjeet eri alustoille. Huomaa, että kaksi ensimmäistä ohjetta olettaa, että sinulla on koneellasi pääkäyttäjän oikeudet. Kolmas ohje on laitoksen koneelle, jossa sinulla ei ole pääkäyttäjän oikeuksia.
</p>
<h4>Node.js ja Git Windowsille (pääkäyttäjän oikeuksilla)</h4>
<p>
  Käy hakemassa <a href="http://nodejs.org/" target="_blank">Node.js</a>-asennuspaketti sen kotisivuilta painamalla "Install"-painiketta. Kun asennuspaketti on ladattu, käynnistä se. Kun asennus on valmis avaa Noden komentorivi työkalu siirtymällä "Start", hakemalla ohjelmaa "Node.js command promt" ja käynnistämällä sen. Jos ohjelma löytyy, Node.js on asennettu onnistuneesti.
</p>
<p>
  Jos koneeltasi puuttuu Git, asenna se seuraavaksi <a href="http://git-scm.com/" target="_blank">täältä</a> painamalla "Download"-painiketta. Kun pääset asennusikkunaan, voit käyttää oletusasetuksia, mutta valitse "Run Git from the Windows Command Promt"-asetus, kun se tulee valittavaksi</strong>. Kun asennus on valmis, avaa "Node.js command promt", kuten edellisessä kohdassa ja suorita siinä komento <code>git --version</code>. Terminaaliin pitäisi ilmestyä versionumero, kuten <code>git version 1.8.5.2</code>.
</p>
<h4>Node.js ja Git OS X:lle ja Linuxille (pääkäyttäjän oikeuksilla)</h4>
<p>
  Käy hakemassa <a href="http://nodejs.org/" target="_blank">Node.js</a>-asennuspaketti sen kotisivuilta painamalla "Install"-painiketta. Kun asennuspaketti on ladattu, käynnistä se. Kun asennus on valmis, avaa terminaali ja suorita siinä komento <code>node --version</code>, jonka jälkeen terminaaliin pitäisi ilmestyä jokin versionumero, kuten <code>v0.10.29</code>. Jos versionumero ilmestyy terminaaliin, Node.js on asennettu onnistuneesti.
</p>
<p>
  Jos koneeltasi puuttuu Git, asenna se seuraavaksi <a href="http://git-scm.com/" target="_blank">täältä</a> painamalla "Download"-painiketta. Kun asennus on valmis siirry terminaaliin ja suorita siinä komento <code>git --version</code>. Terminaaliin pitäisi ilmestyä versionumero, kuten <code>git version 1.8.5.2</code>.
</p>
<h4>Node.js laitoksen koneille</h4>
<p>
  Laitoksen koneilla Git:in pitäisi olla valmiina asennettuna, mutta Noden asennuksen kanssa ongelma on se, ettei sinulla ole pääkäyttäjän oikeuksia, joka tekee asioista hieman vaikeampaa. Noden asennus onnistuu kuitenkin suorittamalla terminaalissa seuraava komento:
</p>
<pre class="sh_javascript_dom">
curl https://raw.githubusercontent.com/creationix/nvm/v0.24.1/install.sh | bash
</pre>
<p>
  Komennon suorittamisen jälkeen käynnistä terminaali uudelleen ja suorita vielä seuraavat komennot:
</p>
<pre class="sh_javascript_dom">
nvm install 0.12
echo 'nvm use 0.12' >> ~/.bashrc
</pre>
<p>
  Kun komennot on suoritettu, suorita terminaalissa komento <code>node --version</code>, jonka jälkeen terminaaliin pitäisi ilmestyä jokin versionumero, kuten <code>v0.10.29</code>. Tämä tarkoittaa sitä, että Node on asennettu. <strong>Laitoksen koneilla Node.js komentojen ajaminen NetBeansin kautta ei kuitenkaan onnistu, mutta samat komennot voit ajaa terminaalissa NetBeans-projektien jureessa</strong>.
</p>
<h4>Testien ajaminen NetBeansissa</h4>
<p>
  Kun Node ja Git on asennettua, olemma valmiita siirtymään NetBeansiin pariin. Käynnistä NetBeans ja avaa siinä tämän viikon tehtävä <code>TodoAppTestaaminen</code>. Jos NetBeans oli jo käynnissä, käynnistä se uudelleen, niin asennukset ovat varmasti tulleet voimaan. Kuten huomaat, projektin nimi on punainen, joten jotain on vialla. Ongelma ratkeaa painamalla hiiren oikeaa painiketta projektin päällä ja valitsemalla "Npm install". Klikkaaminen asentaa Karman ja muut tarvittavat riippuvuudet. Kun riippuvuudet on asennettu, klikkaa taas hiiren oikeaa painiketta projektisi nimen päällä ja valitse "Properties". Valitse avautuvasta ikkunasta oikealla sijaitsevasta valikosta "JavaScript Testing" ja valitse "Testing Provider"-valikosta "Karma". Alle ilmestyy tekstikentät "Karma" ja "Configuration", klikkaa molempien oikealta puolelta "Search"-painikkeita, niin tarvittavat tiedostot löytyvät automaattisesti. Voit nyt ajaa testit klikkaamalla hiiren oikeaa painiketta projektisi nimen päällä ja valitsemalla "Test". Testit eivät vielä mene läpi, joudutkin seuraavassa tehtävässä korjaamaan ne.
</p>
<h4>Testien ajaminen terminaalissa</h4>
<p>
  Laitoksen koneilla Node.js-komentoja ei pysty ajamaan NetBeansin kautta, mutta pystyt ajamaan ne terminaalissa. Siirry terminaalissa <code>TodoAppTestaaminen</code>-projektin juureen. Saat selville, missä projektikansio sijaitsee klikkaamalla NetBeansissa projektin nimen päällä hiiren oikeaa painiketta ja valitsemalla "Properties". Kopio avautuneesta ikkunasta "Project Folder"-kentän sisältö ja siirry siihen terminaalissa seuraavasti:
</p>
<pre class="sh_javascript_dom">
cd PROJEKTIN_KANSION_POLKU
</pre>
<p>
  Korvaa vain kohtaan <code>PROJEKTIN_KANSION_POLKU</code> kopioimasi projektikansion sijainti. Kun olet siirtynyt projektikansioon, suorita siinä komento <code>npm install</code>, se asentaa tarvitsemasi riippuvuudet. Kun riippuvuudet on asennettu, voit ajaa testit projektikansion juuressa komennolla <code>./node_modules/karma/bin/karma start</code>.
</p>
<h4>karma.conf.js</h4>
<p>
  <code>karma.conf.js</code> on tiedosto, joka kertoo Karmalle mm. mitkä tiedostot ladataan selaimeen, kun testit ajetaan. Testeihin pitää ladata koko sovelluksen koodi, kaikki sen käyttämät kirjastot ja itse testit. Tiedoston sisältö voi olla esimerkiksi seuraava:
</p>
<pre class="sh_javascript_dom">
module.exports = function(config) {
  config.set({

    // annetaan tiedostojen aloituspolku (jos tyhjä, niin se on karma.conf.js tiedoston polku)
    basePath: '',


    // käytettävät sovelluskehykset
    frameworks: ['jasmine'],

    // tiedostot, jotka ladataan selaimeen, kun testit ajetaan
    files: [
        'bower_components/angular.min.js',
        'js/app.js',
        'js/controllers/*.js'
    ],


    // web-palvelimen portti, jossa testit ajetaan
    port: 9876,


    colors: true,

    config.LOG_INFO || config.LOG_DEBUG
    logLevel: config.LOG_INFO,


    // jos "true", niin Karma ajaa testit aina kun jokin "files"-kentässä määritelty tiedosto tallennetaan
    autoWatch: true,


    // testien ajamiseen käytettävä selain
    browsers: ['Chrome'],

    singleRun: false
  });
};
</pre>
<p>
  Yleensä <code>karma.conf.js</code>-tiedosto löytyy tehtäväpohjasta valmiina, mutta tulevaisuudessa tulee tehtäviä, jossa sinun täytyy määritellä se itse. Silloinkin yleensä <code>karma.conf.js</code>-tiedoston runko on valmiina, jolloin riittää vain määritellä <code>files</code>-kenttään testien ajamisen yhteydessä selaimeen ladattavat tiedostot.
</p>
<div class="tehtavat">
  <h3>Muistilistan testaaminen</h3>
  <p>
    Tehtäväpohjasta löytyy viime viikolla toteutetun muistilistasovelluksen mallivastaus, joka ei vielä käyttänyt Firebasea. Voit halutessasi korvata mallivastauksen omalla toteutuksellasi. Muistilistan testaamista varten on toteutettu runko tiedostossa <code>app/test/todo_controller_test.js</code>, mutta testit eivät vielä meni läpi. Sinun tehtäväsi on testata testeissä muistilistan eri toimintoja ja saada testit menemään läpi. Testattavat toiminnot kuvataan kunkin testin kohdalla, <code>it</code>-funktion kutsussa, toteuta siis kuvausta vastaava testi. Jos käytät tehtäväpohjan toteutusta, aloita tutustumalla <code>TodoController</code>-kontrolleriin tiedostossa <code>app/controllers/todo_controller.js</code>. <strong>Huom! Jos lisäät tehtäväpohjaan tiedostoja tai muokkaat niiden nimiä, muista päivättää <code>karma.conf.js</code>-tiedosto, jotta lisäämäsi/muokkaamasi tiedostot ladataan selaimeen testien ajamisen yhteydessä.</strong>
  </p>
</div>

<h2>Reititys Angularissa</h2>
<p>
  Isompi sovellus on usein jaettu useaan eri näkymään, jotka löytyvät eri poluista, kuten <code>/elokuvat</code>, <code>/elokuvat/1</code> ja <code>elokuvat/uusi</code>. Perinteisesti sovelluksen polut määritetään palvelinpuolen sovelluksessa, mutta kasva trendi on toteuttaa ainakin osa sovelluksen reitityksestä selainpuolella, jolloin sovelluksessa uuteen polkuun siirtyminen ei rasita niin paljon palvelinta. Näitä sovelluksia kutsutaan nimellä "<a href="http://en.wikipedia.org/wiki/Single-page_application">Single-page application</a>".
</p>
<h3>Single-page sovellukset</h3>
<p>
  Single-page sovelluksesissa reitityksen pääpaino on siirtynyt palvelinpuolelta selainpuolella. Mutta miksi, mitä etuja siitä on? Suurin etu on siinä, että kun käyttäjä siirtyy sovelluksessa toiseen polkuun, palvelimelta haetaan vain uuden näkymän esittämiseen vaadittava sisältö, kuten HTML-sivu tai JSON-dataa sen sijaan, että kaikki sivulla esiintyvät resurssit kuten tyyli- ja skripti-tiedostot sekä kuvat haettaisiin uudelleen. Suorituskyky etu on siis melko huomattava, jolloin näkymien välillä siirtyminen on nopeampaa. Selainpuolen reititys ei ole kuitenkaan kaikki maailman ongelmat ratkaiseva tekiä, siinä on huonojakin puolia. Selainpuolen reitit eivät välttämättä toimi kaikilla alustoilla (etenkin mobiililaitteilla) ja usein sivulla on vain yksi sisääntuloväylä, jonka kautta kaikki reitit käsitellään.
</p>
<h3>Reittien määrittäminen Angularissa</h3>
<p>
  Angularissa reititykseen käytetään <code>ngRoute</code>-moduulia. Kuten moduulit yleensä, ennen kuin sitä pääsee käyttämään, se täytyy injektoida omaan moduuliisi:
</p>
<pre class="sh_javascript_dom">
var App = angular.module('MyApp', ['ngRoute']);
</pre>
<p>
  Se on siinä! Injektoin <code>ngRoute</code>-moduulin muiden moduulien tapaan lisäämällä sen nimen moduulin alustamiskutsun toisena parametrina olevaan taulukkoon. Itse reititys tapahtuu konfiguroimalla <code>ngRoute</code>-moduulin komponenttia <code>$routeProvider</code>. Se onnistuu seuraavasti:
</p>
<pre class="sh_javascript_dom">
var App = angular.module('MyApp', ['ngRoute']);

App.config(function($routeProvider){
  $routeProvider
    .when('/', {
      controller: 'HomeController',
      templateUrl: 'templates/home.html'
    })
    .when('/hello', {
      controller: 'HelloController',
      templateUrl: 'templates/hello.html'
    })
    .otherwise({
      redirectTo: '/'
    });
});
</pre>
<p>
  Lisäämme konfiguraatiossa <code>$routeProvider</code>-komponentin kautta sovellukseemme kaksi reittiä <code>/</code> ja <code>/hello</code> kutsumalla sen funktiota <code>when</code>. Kuten huomaat, funktiokutsuja voi ketjuttaa. Funktio <code>when</code> ottaa parametrikseen polun merkkijonona ja objektin, joka kertoo, mitä tulee tapahtua, kun käyttäjä siirtyy sovelluksessa ensimmäisenä parametrina annettuun polkuun. Objekti sisältää kentän <code>controller</code>, joka kertoo, mikä kontrolleri otetaan reitissä käyttöön ja kentän <code>templateUrl</code>, joka kertoo, mitä näkymätiedostoa käytetään. Ketjun viimeisessä funktiokutsussa kutsutaan funktiota <code>otherwise</code>, joka kertoo, mitä tehdään, jos käyttäjä siirtyy polkuun, jota ei ole määritelty <code>when</code>-funktioiden kutsuissa. Funktio <code>otherwise</code> ottaa parametrikseen objektin, jossa yleensä määritetään kenttä <code>redirectTo</code>, joka kertoo, mihin polkuun käyttäjä ohjataan, jos hän yrittää mennä polkuun, jota ei ole määritelty.
</p>
<p>
  Kontrollerin määrittäminen ei ole pakollista, jos haluat esittää polussa käyttäjälle pelkästään staattisen näkymän. <code>templaUrl</code>-kentän sijaan voi määrittää kentän <code>template</code>, jonka arvo on tiedoston sijaan merkkijono, joka sisältää näkymän sisällön HTML-elementteineen. <code>template</code>-kentän määrittäminen <code>templateUrl</code>-kentän sijaan periaatteessa parantaa hieman sovelluksen suorituskykyä, koska näkymätiedostoa ei tarvitse hakea palvelimelta, mutta isojen näkymien esittäminen merkkijonona on todella sekavaa.
</p>
  Liitetään moduulimme kontrollerit <code>HomeController</code> ja <code>HelloController</code>, joihin reiteissä viittaamme:
</p>
<pre class="sh_javascript_dom">
App.controller('HomeController', function($scope){
  $scope.message = 'Olet etusivulla!';
});

App.controller('HelloController', function($scope){
  $scope.message = 'Olet hello sivulla! Hello World!';
});
</pre>
<p>
  Tarvitsemme vielä reiteissä viitatut näkymätiedostot <code>home.html</code> ja <code>hello.html</code>. Tarvitsemme kuitenkin sitä ennen pohjatiedoston, johon näkymät upotetaan, joka on yleensä nimeltään <code>index.html</code>:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;a href="#"&gt;Etusivu&lt;a&gt; | &lt;a href="#/hello"&gt;Hello&lt;a&gt;
    &lt;h1&gt;Kallen Single-page sovellus&lt;/h1&gt;
    &lt;div ng-view&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Pohjatiedostossa määrittelemme moduulimme <code>ng-app</code>-attribuutissa. Lisäksi pohjatiedostossa määritellään, mihin reiteissä määritellyt näkymätiedostot upotetaan. Se tapahtuu lisäämällä <code>ng-view</code>-attribuutti DOM-elementille, jonka sisään näkymätiedostojen sisältö halutaan lisätä.
</p>
<p>
  Jos olit tarkkana, huomasit myös, että lisäsin pohjatiedostoon pienen navigaation, joka hyvä lisätä juuri pohjatiedostoon, koska navigaatio esiintyy joka sivulla. Navigaation linkit eroavat kuitenkin <code>href</code>-attribuutin arvon osalta hieman. On tärkeää, että linkin kohde on muotoa <code>#/hello</code>, eikä <code>/hello</code>. Ero on siinä, että <code>#</code>-alkuiset kohteet ovat nk. sivun sisäisiä linkkejä, eli niihin siirtyminen ei aiheuta pyyntöä palvelimelle, vaan kohteen käsittely jää selainpuolen sovelluksen tulkittavaksi. Tämä mahdollistaa selainpuolella tapahtuvan reitityksen.
</p>
<p>
  Nyt, jos käyttäjä klikkaa linkkiä "Hello", selaimen osoiteriivin ilmestyy sivuston url:in jatkeeksi <code>#/hello</code>, eikä käyttäjä poistu sivulta, vaan selainpuolen sovellus (meidän Angular-sovelluksemme) päättää, mitä tehdään. Olemme määrittäneet <code>$routeProvider</code>-komponentissa, että polussa <code>/hello</code> otetaan käyttöön kontrolleri <code>HelloController</code> ja näytetään näkymä <code>hello.html</code>. Näkymän <code>hello.html</code> sisältö voisi olla vaikka seuraava:
</p>
<pre class="sh_html">
&lt;h2&gt;Hello sivu&lt;/h2&gt;
{{message}}
</pre>
<p>
  Huomaa, ettei näkymätiedostossa tarvitse määrittää <code>html</code>- ja <code>body</code>-tageja, koska tiedoston sisältö upotetaan pohjatiedoston <code>div</code>-elementin sisään, jolla on <code><a href="https://docs.angularjs.org/api/ngRoute/directive/ngView" target="_blank">ng-view</a></code>-attribuutti.
</p>
<p>
  Tässä vielä tähän astinen toteutuksemme (huomaa, etten voi jsFiddlessä määrittää näkymätiedoston polkua, joten joudun laittamaan näkymän sisällön suoraan reitin määritykseen):
  <iframe width="100%" height="300" src="http://jsfiddle.net/Mh2UH/15/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</p>
<div class="tehtavat">
  <h3>PerusMOOC reiteillä</h3>
  <p>
    Tehtäväpohjan mukana tulee viikolla 1 toteutetun PerusMOOC-tehtävän runko ja sivupohjat sivuille "PerusMOOC", "Materiaali" ja "Oma etenemiseni". Muokkaa tehtäväpohjaa niin, että etusivun sisältönä (polussa <code>#/</code>) näytetään "PerusMOOC"-sivupohja, polussa <code>#/materiaali</code> "Materiaali"-sivupohja ja polussa <code>#/oma-etenemiseni</code> "Oma etenemiseni"-sivupohja. Muista injektoida <code>ngroute</code>-moduuli omaan moduulisi, jotta pääset määrittämään sovelluksesi reitit konfiguroimalla <code>$routeProvider</code>-komponenttia. Tee <code>$routeProvider</code>-komponenttiin liittyvät konfiguraatiot tiedostossa <code>app/app.js</code>, jossa itse moduuli sijaitsee. Tarvittavat kontrollerit voit luoda <code>app/controllers</code> kansioon. <strong>Muista linkittää luomasi <code>js</code>-tiedostot <code>index.html</code>-näkymässä <code>script</code>-tagien avulla!</strong>. Kun reitit on toteutettu, muokkaa vielä navigaatiopalkin linkkejä niin, että ne osoittavat oikeisiin paikkoihin. Näkymätiedostot <code>etusivu.html</code>, <code>materiaali.html</code> ja <code>etenemiseni.html</code> löytyvät kansiosta <code>app/views</code>. Muista, että <code>templateUrl</code>-kentässä määritellyn näkymätiedostopolun juuri on projektisi <code>src</code>-kansio.
  </p>
</div>
<h4>Polkujen parametrit</h4>
<p>
  Sovelluksen polun kautta halutaan usein välittää tietoa. Jos meillä on esimerkiksi sovellus, joka esittää käyttäjän profiilisivun, haluamme, että profiilisivulle pääse esimerkiksi polun <code>#/kayttaja/KAYTTAJANIMI</code>-kautta, jossa <code>KAYTTAJANIMI</code> on käyttäjän nimi. Kun käyttäjä tällöin siirtyy sovelluksessa esimerkiksi polkuun <code>#/kayttaja/kalle</code>, voimme hakea tietokannasta (esim. Firebasesta) käyttäjän "kalle" tiedot ja esittää ne profiilisivulla.
</p>
<p>
  Angularissa voimme helposti upottaa polkuihin nk. polkuparametreja, joiden sisältö vaihtelee käyttäjän antaman polun perusteella. Katsotaan, miten voisimme upottaa käyttäjän nimen polkuun <code>#/kayttaja/KAYTTAJANIMI</code>:
</p>
<pre class="sh_javascript_dom">
var App = angular.module('MyApp', ['ngRoute']);

App.config(function($routeProvider){
  $routeProvider
    .when('/kayttaja/:username', {
      controller: 'UserController',
      templateUrl: 'templates/profile.html'
    });
});
</pre>
<p>
  Määrittelemme sovelluksemme reitit tavalliseen tapaan konfiguroimalla <code>ngRoute</code>-moduulin <code>$routeProvider</code>-komponenttia. Tällä kertaa funktiossa <code>when</code> määritelty polku näyttää tosin hieman erinlaiselta, sillä siihen on upotettu parametri <code>username</code>. Parametrin upotus polkuun tapahtuu yksinkertaisesti syntaksilla <code>:parametrinNimi</code>, eli <code>:</code> ja nimi parametrille, jonka kautta voimme hakea sen arvon. Nyt polussa <code>#/kayttaja/arto</code> parametrin <code>username</code> arvo on "arto". Katsotaan, miten voimme käyttää polkumme <code>username</code> parametria määrittelemällä kontrolleri <code>UserController</code>:
</p>
<pre class="sh_javascript_dom">
App.controller('UserController', function($scope, $routeParams){
  var users = {
    'arto': {
      name: 'Arto',
      friends: ['Kalle', 'Matti']
    },
    'kalle': {
      name: 'Kalle',
      friends: ['Elina', 'Arto', 'Matti']
    },
    'elina': {
      name: 'Elina',
      friends: ['Kalle']
    },
    'matti': {
      name: 'Matti',
      friends: ['Arto', 'Kalle']
    }
  }

  if(users[$routeParams.username.toLowerCase()]){
    $scope.user = users[$routeParams.username.toLowerCase()];
  }else{
    $scope.user = null;
  }
});
</pre>
<p>
  Huomasit varmaan, että kontrolleriin on injektoitu <code><a href="https://docs.angularjs.org/api/ngRoute/service/$routeParams" target="_blank">$routeParams</a></code>-muuttuja. Se on objekti, joka sisältää kenttinä kaikki nykyiseen polkuun liittyvät parametrit. <code>username</code>-parametrin arvo on siis <code>$routeParams.username</code>. Voimme käyttää polkuparametrin arvoa, esimerkiksiä määrittämään, minkä käyttäjän profiili esitetään näkymässä, kuten yllä on tehty. Toteutaan vielä näkymä <code>profile.html</code>, jotta saamme homman pakettiin:
</p>
<pre class="sh_html">
&lt;h2&gt;Käyttäjän {{user.name}} profiili&lt;/h2&gt;
Kaverit:
&lt;ul ng-repeat="friend in user.friends"&gt;
  &lt;li&gt;&lt;a ng-href="#/kayttaja/{{friend}}"&gt;{{friend}}&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>
  Huomaa, että linkeissä kannattaa käyttää <code><a href="https://docs.angularjs.org/api/ng/directive/ngHref" target="_blank">ng-href</a></code>-attribuuttia perinteisen <code>href</code>-attribuutin sijaan, muuten voi käydä niin, että linkin <code>href</code>-attribuutti asetetaan ennen kuin muuttujat ovat latautuneet. Tällöin esimerkiksi linkin polku voisi olla <code>#/kayttaja/{{friend}}</code> polun <code>#/kayttaja/elina</code> sijaan.
</p>
<p>
  Tässä vielä lopputulos:
  <iframe width="100%" height="300" src="http://jsfiddle.net/Mh2UH/18/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</p>
<h4>Polkujen käsittely kontrollereissa</h4>
<p>
  Sovelluksen polkuja pystyy käsittelemään monin tavoin kontrollereissa. Tärkein palvelu polkujen käsittelyyn on <code><a href="https://docs.angularjs.org/api/ng/service/$location" target="_blank">$location</a></code>-palvelu. Yksi sen tärkeimmistä toiminnoista on käyttäjän ohjaaminen toiseen polkuun käyttäen <code>path</code>-funktiota:
</p>
<pre class="sh_javascript_dom">
App.controller('UserController', function($scope, $routeParams, $location){
  var users = {
    'arto': {
      name: 'Arto',
      friends: ['Kalle', 'Matti']
    },
    'kalle': {
      name: 'Kalle',
      friends: ['Elina', 'Arto', 'Matti']
    },
    'elina': {
      name: 'Elina',
      friends: ['Kalle']
    },
    'matti': {
      name: 'Matti',
      friends: ['Arto', 'Kalle']
    }
  }

  if(users[$routeParams.username.toLowerCase()]){
    $scope.user = users[$routeParams.username.toLowerCase()];
  }else{
    $location.path('/kayttajat/kalle');
  }
});
</pre>
<p>
  Lisäsin siis kontrollerin <code>if</code>-ehdon <code>else</code>-haaraan ohjauksen polkuun <code>#/kayttaja/kalle</code> (huomaa, ettei polun eteen tarvitse laittaa <code>#</code>-merkkiä!). Nyt jos käyttäjää ei löydy, ohjataan käyttäjä polkuun <code>#/kayttaja/kalle</code>, eli käyttäjän "Kalle" profiilisivulle. Tapa muistuttavaa hyvin paljon palvelinohjelmissa tehtävää uudelleenohjausta. <code>$location</code>-palvelua käytetään myös hyvin paljon selaimen osoitepalkin sisällön tarkkailuun. Esimerkiksi, jos haluamme koko tähän hetkisen url:in (esim. http://cs.helsinki.fi/courses), voimme kutsua <code>absUrl</code>-funktiota ja jos haluamme vain pyynnön osan (esim. /courses), voimme kutsua <code>url</code>-funktiota.
</p>
<div class="tehtavat">
  <h3>Kuin kissat ja koirat</h3>
  <p>
    Tehtäväpohjassa on määritelty palvelut <code>Cat</code> (tiedostossa <code>app/services/cat.js</code>) ja <code>Dog</code> (tiedostossa <code>app/services/dog.js</code>), jotka molemmat tarjoavat funktion <code>all</code>, joka paluttaa taulukon kissoja, tai koiria, riippuen kumman palvelun funktiota kutsutaan. Toteuta kontrollerit <code>ListController</code> (pohja tiedostossa <code>app/controllers/list_controller.js</code>), joka listaa etusivulla (polussa #/) kaikki kissat sekä koirat ja <code>CatController</code> (pohja tiedostossa <code>app/controllers/cat_controller.js</code>), joka näyttää polussa <code>#/kissat/ROTU</code> polkuparametrin <code>ROTU</code>-arvonana (vinkki: <code><a href="https://docs.angularjs.org/api/ngRoute/service/$routeParams" target="_blank">$routeParams</a></code>) annetun kissarodun tiedot seuraavasti:
  </p>
  <h1 class="ignore">Eksoottinen lyhytkarva</h1>
  <p>
    Eksoottisen lyhytkarvan turkki on tiheä ja samettisen pehmeä, luonne koiramaisen seurallinen. Rakenne on roteva ja litteänaamainen kuten persialaisella. Rotumääritelmä on turkin pituutta lukuun ottamatta yhtenevä persialaisen rotumääritelmän kanssa.
  </p>
  <p>
    Sivun otsikko on siis kissarodun nimi ja sen alla on sen kuvaus. Toteuta myös kontrolleri <code>DogController</code> (pohja tiedostossa <code>app/controllers/dog_controller.js</code>), joka näyttää polussa <code>#/koirat/ROTU</code> polkuparametrin <code>ROTU</code>-arvonana annetun koirarodun tiedot samaan tapaan kuin kissojen kanssa. <code>$routeProvider</code>-komponenttiin liittyvät konfiguraatiot kannattaa tehdä tiedostossa <code>app/app.js</code> ja näkymätiedostot voi sijoittaa vaikkapa kansioon <code>app/views</code>.
  </p>
  <p>
    Jos käyttäjä yrittää mennä kissa- tai koirarodun sivulle, jota ei löydy, ohjaa hänet takaisin etusivulle käyttäen <code><a href="https://docs.angularjs.org/api/ng/service/$location" target="_blank">$location</a></code>-palvelua.
  </p>
  <p>
    Kun tehtävä on tehty, voit vaikappa katsoa upen koko perheen elokuvan <a href="http://www.imdb.com/title/tt0239395/" target="_blank">Kuin kissat ja koirat</a>.
  </p>
</div>
<h2>Kehitystyökalut</h2>
<p>
  JavaScriptiin on toteutettu parin viime vuoden aikana tolkuttoman monta eri kehitystyökaluja ja trendit niiden käytön kanssa vaihtelevat melkein kuukausittain. Käymme seuraavaksi läpi vain pari tärkeintä työkalua, jotka ovat luultavasti joidenkin hipsterien mielestä jo todella vanhanaikaisia.
</p>
<h3>Järkevää riippuvuuksien hallintaa: Bower</h3>
<p>
  JavaScript sovellukset ja kirjastot ovat nykyään yhä enemmän riippuvaisia toisista kirjastoista, jotka ovat edelleen riippuvaisia toisista kirjastoista. Riippuvuuksien hallinta oli ennen hankalaa, sillä kirjastojen dokumentaatiossa piti erikseen mainita, mitä riippuvuuksia niissä on ja ohjelmoijan piti itse etsiä riippuvuuksien lähdekoodi ja linkittää ne sovellukseen. Nykyään riippuvuuksien hallinta on onneksi todella helppoa, kiitos <a href="http://bower.io/" target="_blank">Bowerin</a>.
</p>
<p>
  Bower etsii ja asentaa tarvitsemasi kirjastot puolestasi. Lisäksi se pitää kirjaa sovelluksesi riippuvuuksista <code>bower.json</code>-tiedostossa, jotta muut voivat tarvittaessa asentaa sovelluksesi käyttämät riippuvuudet, kun he haluavat käyttää sovellustasi. Aloitetaan hieman tarkempi tutustuminen siihen ja katsotaan, miten voimme käyttää sitä NetBeansissa. Bower vaatii toimiakseen <a href="http://git-scm.com/" target="_blank">Gitin</a> ja <a href="http://nodejs.org/" target="_blank">Noden</a>. Jos asensit molemmat viime viikolla testaamisen yhteydessä, olet jo valmis. Jos ne on vielä asentamatta lue asentamisohjeet kohdasta Testien suorittaminen.
</p>

<h4>Kirjastojen asentaminen</h4>
<p>
  Avataan edellisen tehtävän <code>KuinKissatJaKoirat</code>-projekti NetBeansissa ja katsotaan, mitä riippuvuuksia sillä on avaamalla <code>bower.json</code>-tiedosto kansiosta <code>Important Files</code>. Sen sisältö on seuraava:
</p>
<pre class="sh_javascript_dom">
{
  "name": "weso",
  "version": "0.0.0",
  "authors": [],
  "license": "MIT",
  "dependencies": {
    "angular": "~1.3.13",
    "angular-route": "~1.3.13"
  }
}
</pre>
<p>
  Tiedostoston alku koostuu sovelluksemme perustiedoista, kuten sen nimestä, versiosta ja lisenssistä. Sen jälkeen kerrotaan, mitä riippuvuuksia sovelluksessamme on, ne ovat <code>angular</code> ja reititykseen käyttämämme <code>angular-route</code>. Numerosarja riippuvuuden nimen jälkeen on sen versionumero. Asennetaan seuraavaksi pari riippuvuutta, vaikkapa jQuery ja Mustache. Jokaisella kirjastolla on Bowerin rekistereissä oma nimensä, mutta en ole aivan varma, millä nimellä jQuery ja Mustache löytyvät. Voin tarkastaa asian helposti <a href="http://bower.io/search/" target="_blank">täältä</a>. Ilmeisesti jQuery löytyy nimellä <code>jquery</code> ja Mustache nimellä <code>mustache</code> (yllätys, yllätys!). Määritellään <code>bower.json</code>-tiedostoon kenttä <code>dependencies</code> ja määritellään siihen, että haluamme asentaa sovellukseemme viimeisimmät versiot <code>jquery</code>- ja <code>mustache</code>-kirjastoista:
</p>
<pre class="sh_javascript_dom">
{
  "name": "weso",
  "version": "0.0.0",
  "authors": [],
  "license": "MIT"
  "dependencies": {
    "angular": "~1.3.13",
    "angular-route": "~1.3.13"
    "jquery": "latest",
    "mustache": "latest"
  }
}
</pre>
<p>
  Lisäämällä <code>dependencies</code>-kentän sisältävään objektiin kentät <code>jquery</code> ja <code>mustache</code>, joiden arvo on "latest", saamme asennettua niiden viimeisimmät versiot Bowerin rekistereistä. Riippuvuuksien määrittely on nyt valmis, seuraava vaihe on niiden asentaminen. Se on NetBeansissa helppoa, painetaan vain projektimme nimen päällä hiiren oikeaa painiketta ja valitaan "Npm install", joka asentaa Bowerin ja sen jälkeen valitsemalla "Bower install", joka asentaa asettamamme riippuvuudet <code>jquery</code> ja <code>mustache</code>. Jos käytät laitoksen konetta, suorita terminaalissa NetBeans-projektin juuressa ensin komento <code>npm install</code> ja sen jälkeen komento <code>./node_modules/bower/bin/bower install</code>. Kommennon suorittamisen jälkeen <code>bower_components</code>-kansioon ilmestyy kansiot <code>mustache</code> ja <code>jquery</code>, joista löytyy tarvitsemamme riippuvuudet, joita voimme nyt käyttää sovelluksessamme.
</p>
<h3>Väsymätön työnsankari: Grunt</h3>
<p>
  Ohjelmoijalla on sovellusta kehittäessä usein monta pientä tehävää, jotka pitää toistaa tiuhaan tahtiin. Tehtävät voivat olla joko, skripti- tai tyylitiedostojen yhdistämistä ja pakkaamista, testien automaattista suorittamista, tai lähdekoodin auttomaattista siirtämistä versionhallinta. Kaikki näistä tehtävistä ovat melko työläitä, etenkin kun ne pitää suorittaa manuaalisesti tiuhaan tahtiin. Ratkaisu ongelmaan on JavaScriptin ikioma tehtäviensuorittaja, <a href="http://gruntjs.com/" target="_blank">Grunt</a>, joka suorittaa määrittämiäsi tehtäviä puolestasi aina, kun haluat.
</p>
<h4>Töihin siitä, Grunt!</h4>
<p>
  Grunttiin on toteutettu monta <a href="http://gruntjs.com/plugins" target="_blank">pluginia</a>, joiden avulla sille voi määritellä eri tehtäviä eli "taskeja". Taskien määrittely tapahtuu projektin juuressa sijaitsevassa <code>Gruntfile.js</code>-tiedostossa, jossa pluginit ladataan ja niiden tarjoamat taskit konfiguroidaan tarpeidesi mukaisiksi. Tässä esimerkki <code>Gruntfile.js</code>-tiedostosta, jossa käytetään <a href="https://www.npmjs.com/package/grunt-contrib-uglify" target="_blank">grunt-contrib-uglify</a>-pluginia minimoimaan kasa JavaScript-tiedostoja yhdeksi kompaktiksi tiedostoksi, josta ne kaikki löytyvät pakatusssa muodossa:
</p>
<pre class="sh_javascript_dom">
module.exports = function(grunt) {

  // Konfiguroidaan taskit
  grunt.initConfig({
    // uglify-plugini
    uglify: {
      build: {
        src: ['app/app.js', 'app/services/*.js', 'app/controllers/*.js'],
        dest: 'app/app.min.js'
      }
    }
  });

  // Ladataan plugini "grunt-contrib-uglify", joka tarjoaa taskin "uglify"
  grunt.loadNpmTasks('grunt-contrib-uglify');

  // Asetetaan suoritettava oletustaski, joka on tässä tapauksessa "uglify"
  grunt.registerTask('default', ['uglify']);
};
</pre>
<p>
  Annamme <code>initConfig</code>-funktiolla parametriksi objektin, jossa määrittelemme taskiemme konfiguraatiot. <code>grunt-contrib-uglify</code>-plugin tarjoaa taskin <code>uglify</code>, jonka avulla pystymme minimoimaan JavaScript-tiedostoja. Se on kätevää, koska sivunlataus nopeutuu huomattavasti, jos <code>script</code>-tageja on sivulla monen sijaan yksi. <code>uglify</code>-taskin konfiguroinnissa kerromme, että haluamme minimoida tiedoston <code>app/app.js</code> ja kaikki <code>js</code>-tiedostot kansioista <code>app/services</code> ja <code>app/controllers</code> tiedostoon <code>app/app.min.js</code>. Konfiguroinnin jälkeen lataamme pluginit käyttöömme ja asetamme gruntin oletus taskit. Tässä tapauksessa, kun Grunt aloittaa työn projektimme parissa komennolla <code>grunt</code>, suoritetaan vain taski <code>uglify</code>.
</p>
<p>
  Voimme suorittaa samaan aikaan monta taskia. Otetaan vielä käyttöön <a href="https://www.npmjs.com/package/grunt-contrib-jshint" target="_blank">grunt-contrib-jshint</a>-plugini, joka tarjoaa taskin <code>jshint</code>, joka validoi JavaScript-koodia ja ilmoittaa meille löytämänsä syntaksivirheet:
</p>
<pre class="sh_javascript_dom">
module.exports = function(grunt) {

  // Konfiguroidaan taskit
  grunt.initConfig({
    // uglify-plugini
    uglify: {
      build: {
        src: ['app/app.js', 'app/services/*.js', 'app/controllers/*.js'],
        dest: 'app/app.min.js'
      }
    },
    jshint: {
      src: ['app/**/**.js']
    }
  });

  // Ladataan plugini "grunt-contrib-uglify", joka tarjoaa taskin "uglify"
  grunt.loadNpmTasks('grunt-contrib-uglify');
  grunt.loadNpmTasks('grunt-contrib-jshint');

  // Asetetaan suoritettavat oletustaskit, jotka ovat "jshint" ja "uglify"
  grunt.registerTask('default', ['jshint', 'uglify']);

  // Asetetaan "hint"-ryhmässä suoritettavat taski
  grunt.registerTask('hint', ['jshint']);
};
</pre>
<p>
  Otimme siis käyttöömme taskin <code>jshint</code>, joka etsii syntaksivirheitä kaikista <code>app</code>-kansion alakansioista sijaitsevista <code>js</code>-tiedostoista. Määritimme myös, että <code>jshint</code>-taski suoritetaan oletustaskina ja lisäksi, että sen voi suorittaa ilman erikseen komennolla <code>grunt hint</code>.
</p>
<p>
  Seuraavassa tehtävässä pääset käyttämään Grunttia. Jos et asentanut testaamisen yhteydessä Node.js:ssää ja Git:iä, tee se nyt. Ohjeet löytyvät osiosta Testien suorittaminen. Kun asennus on tehty, avaa NetBeans ja siinä tämän viikon tehtävistä tehtävä <code>GruntToihin</code>. Klikkaa projektin nimen päällä hiiren oikeaa painiketta ja valitse "Npm install", se asentaa tarvitsemasi riippuvuudet, mukaan lukien Gruntin. Sen jälkeen paina taas projektisi nimen päällä hiiren oikeaa painiketta ja valitse "Properties" ja siirry avautuvasta ikkunasta "Grunt"-kategoriaan. Voit valita, milloin Gruntin taskit suoritetaan valitsemalla jonkun kolmesta vaihtoehdosta ja syöttämällä sen viereiseen tekstikenttään, minkä ryhmän taskit suoritetaan (esimerkiksi "default"). Jos käytät laitoksen konetta, voit suorittaa Gruntin taskit terminaalissa NetBeansin-projektin juuressa suorittamalla ensin komennon <code>npm install</code> ja sen jälkeen komennon <code>node -e "require('grunt').cli();"</code>.
</p>
<div class="tehtavat">
<h3>Laitetaan Grunt töihin</h3>
<p>
  Arto on toteuttanut eeppisen kokoisen sovelluksen, mutta hänellä on sen kanssa pari pientä ongelmaa. Ensinnäkin, Matti valitti, että Arton sovellus lataa palvelimelta aivan turhan monta <code>js</code>-tiedostoa ja antoikin vinkiksi, että Gruntilla JavaScript tiedostot voi yhdistää yhdeksi kompaktiksi <code>js</code>-tiedostoksi käyttäen <a href="https://www.npmjs.com/package/grunt-contrib-uglify" target="_blank">grunt-contrib-uglify</a>-pluginia. Sama ongelmalla Artolla on <code>css</code>-tiedostojen kanssa. Siihen soveltuu Matin mukaan <a href="https://www.npmjs.com/package/grunt-contrib-cssmin" target="_blank">grunt-contrib-cssmin</a>-plugini. Lisäksi Artolla on koodissaan syntaksivirhe, jota hän ei millään löydä. Hän tietää, että sen löytämiseen voi käyttää <a href="https://www.npmjs.com/package/grunt-contrib-jshint" target="_blank">grunt-contrib-jshint</a>, mutta hän tarvitsee apua sen konfigurointiin. Voitko auttaa Artoa?
</p>
<p>
  Tehtäväpohjan mukana <code>Important Files</code>-kansiosta löytyy pohja <code>Gruntfile.js</code>-tiedostolle, johon sinun täytyy tehdä tarvittavat muutokset. Aloita suorittamalla komento <code>npm install</code> joko NetBeansissa tai terminaalissa projektisi juuressa, joka asentaa Gruntin. Kun Grunt on asennettu, klikkaa projektisi nimen päällä hiiren oikeaa painiketta ja valitse "Properties". Siirry avautuvasta ikkunasta vasemmalta kohtaan "Grunt" ja valitse checkboxi "Build Project" ja kirjoita sen vieressä olevaan tekstikenttään "default" (ilman lainausmerkkejä). Nyt Grunt ajaa projektin buildaamisen yhteydessä (build-painikkeen klikkaamisen yhteydessä) kaikki taskit ryhmässä <code>default</code>, jotka määritellään <code>Gruntfile.js</code>-tiedostossa. Laitoksen koneella voit ajaa Gruntin suorittamalla terminaalissa NetBeans-projektisi juuressa komennon <code>node -e "require('grunt').cli();"</code>. Toteuta <code>Gruntfile.js</code>-tiedosto, niin, että Grunt suorittaa taskit <code>uglify</code>, <code>cssmin</code> ja <code>jshint</code> seuraavasti:
  <ul>
    <li>
      <code>jshint</code>-taski etsii syntaksivirheitä kaikista <code>app/controllers</code> kansiosta sijaitsevista <code>js</code>-tiedostoista. Löydä siis Arton tekemät syntaksivirheet ja korjaa ne niin, että <code>jshint</code> on tyytyväinen.
    </li>
    <li>
      <code>uglify</code>-taski yhdistää tiedoston <code>app/app.js</code> sekä kaikki <code>js</code>-tiedostot kansioista <code>app/controllers</code>, <code>app/services</code> ja <code>app/directives</code> tiedostoon <code>app/app.min.js</code>.
    </li>
    <li>
      <code>cssmin</code>-taski yhdistää kaikki <code>css</code>-tiedostot kansiosta <code>css/common</code> tiedostoon <code>css/app.min.css</code>
    </li>
  <ul>
</p>
<p>
  <strong>Muistathan, että kaikki tiedostot sijaitsevat <code>src</code>-kansiossa, joten muista lisätä se <code>Gruntfile.js</code>-tiedostossa määrittelemiesi polkujen eteen, kuten <code>src/app/controllers/*.js</code>.</strong>
</p>
</div>
</section>



<section class="week">
  <header>
    <a name="viikko6"></a>
    <h1 data-week-id="6">Viikko 6</h1>
  </header>
  <h2>Suurempi Angular-sovellus: Elokuvakirjasto</h2>
  <p>
    Tällä viikolla keskitymme melko paljon hieman suuremman Angular-sovelluksen toteuttamiseen, jossa käytämme edellisillä viikoilla oppimiamme tekniikoita. Toteuttamamme sovellus on lopullisessa muodossaan elokuvakirjasto, joka jättää <a href="http://www.imdb.com/" target="_blank">IMDb</a>:n varjoonsa (ainakin melkein). Tarkoituksena on, että käyttäjä voi lisätä sovellukseen elokuvia, katsella, sekä muokata ja poistaa niitä. Käytämme sovelluksessamme viime viikolla tututuksi tullutta Firebasea, jotta lisätyt elokuvat pysyvät sovelluksessamme. Aiomme myös julkaista sovelluksemme, jolloin muut pääset näkemään ja käyttämään sitä. Puhutaan siitä seuraavaksi.
  </p>
   <h3>Sovellus muiden nähtäville: Heroku</h3>
  <p>
    <a href="https://www.heroku.com/home" target="_blank">Heroku</a> on suosittu, lukuisilla eri alustoilla toteutettujen sovelluksien hostaamiseen tarkoitettu pilvipalvelu. Tulemme tällä viikolla toteuttamaan sovelluksen, jonka lisäämme sinne muiden nähtäväksi. Aloita rekisteröitymällä Herokuun <a href="https://signup.heroku.com/login" target="_blank">täältä</a>. Asenna rekisteröitymisen jälkeen koneellesi <a href="https://toolbelt.heroku.com/" target="_blank">Heroku toolbelt</a>, joka sisältää kaikki Herokun käyttöön tarvittavat työkalut. <strong>Jos käytät laitoksen konetta, sinulle ei <code>sudo</code>-oikeuksia, mutta voit asentaa Heroku toolbeltin alla olevan ohjeen avulla</strong>.
  </p>
  <h4>Heroku toolbeltin asentaminen laitoksen koneille</h4>
  <ol>
    <li>Poista pajan koneeen kotihakemistosta tiedosto <code>.netrc</code></li>
    <li>luo fs-kotihakemistoon samanniminen tyhjä tiedosto. fs-kotihakemistosi on polulla /home/tktl-csfs/fs/home/omakayttajatunnus tai /home/tktl-csfs/fs2/home/omakayttajatunnus. Voit luoda tyhjän tiedoston esim. komennolla touch <code>.netrc.</code></li>
    <li>luo symbolinen linkki suorittamalla seuraava komento <strong>pajakoneen kotihakemistosta</strong> <code>ln -s /home/tktl-csfs/fs2/home/omakayttajatunnus/.netrc</code>. <strong>fs tai fs2 riippuen kummasta hakemistosta kotihakemistosi löytyy</strong>.</li>
    <li>Varmista että olet kotihakemistossasi komennolla <code>cd $HOME</code></li>
    <li>Lataa ja pura heroku client komennolla <code>wget -qO- https://s3.amazonaws.com/assets.heroku.com/heroku-client/heroku-client.tgz | tar xz</code></li>
    <li>Lisää heroku client PATH:iin komennolla <code>echo 'export PATH="$HOME/heroku-client/bin:$PATH"' >> ~/.bashrc</code></li>
    <li>Käynnistä terminaali uudelleen</li>
    <li>Tarkista että heroku on asennettu oikein suorittamalla <code>heroku --version</code> jonka pitäisi tulostaa jotain <code>heroku-toolbelt/3.22.1 (x86_64-linux) ruby/2.2.0</code> tapaista.</li>
  </ol>
<p>
  Asennusohjeet on otettu "Web palvelinohjelmointi Ruby on Rails"-kurssin materiaalista.
</p>
<h4>
  Uuden sovelluksen julkaiseminen Herokussa
</h4>
<p>
  Käydään seuraavaksi hakemassa Herokussa julkaistavan sovelluksellemme pohja <a href="https://github.com/web-selainohjelmointi/Elokuvakirjasto" target="_blank">tästä</a> GitHub reposta. Jos et ole vielä rekisteröitynyt GitHubiin, tee se nyt <a href="https://github.com/join">täältä</a>. Kun olet kirjautunut sitään GitHubiin saat kopioitua repon omien repojesi joukkoon klikkaamalla sivun oikeasta yläkulmasta "Fork"-painiketta. Forkkauksen jälkeen sinut ohjataan forkatun reposi sivulle. Kopioi sieltä sivun oikeassa alalaidassa sijaitsevan "HTTPS clone URL"-kentän sisältö, joka on seuraavanlainen <code>https://github.com/KAYTTAJATUNNUS/Elokuvakirjasto.git</code>. Kun kentän sisältö on kopioitu, siirry terminaalissa hakemistoon, johon haluat kloonata reposi ja suorita komento <code>git clone REPON_URL</code> (käytä kopioimaasi kentän sisältöä kohdassa <code>REPON_URL</code>). Kun kloonaus on tehty, siirry kloonattuun kansioon komennolla <code>cd Elokuvakirjasto</code> ja suorita sen juuressa komento <code>heroku create --buildpack https://github.com/heroku/heroku-buildpack-php</code>. Komennon suorittamisen jälkeen terminaaliin pitäisi ilmestyä teksti <code>Git remote heroku added</code>. Siiretään seuraavaksi sovelluksemme pohja Herokuun suorittamalla komento <code>git push heroku master</code>. Komennon suorittaminen luultavasti pyytää Heroku-käyttäjäsi tietoja. Kun kaikki on valmista, voit avata sovelluksesi selaimessa suorittamalla komennon <code>heroku open</code>. Löydät uuden sovelluksesi myös oman <a href="https://dashboard.heroku.com/apps" target="_blank">Heroku-käyttäjäsi sivulta</a>.
</p>
<h4>Muutosten julkaiseminen Herokussa</h4>
<p>
  Herokussa julkaisemamme sovelluksen pohja on seuraavanlainen:
</p>
<pre class="sh_xml">
test/

web/
  app/
    app.js
    index.html
  .htaccess
  index.php
.bowerrc
bower.json
package.json
karma.conf.js
composer.json
composer.lock
Procfile
README.md
</pre>
<p>
  Tiedostoja on jonkin verran, mutta ainoat, joita sinun tulee muuttaa löytyvät kansiosta <code>app</code> ja mahdollisesti <code>bower_components</code>, jos satut tarvitsemaan muita riippuvuuksia, kun ne, jotka on mainittu <code>bower.json</code>-tiedostossa. <app>app</code>-kansiossa sijaitsevassa <code>index.html</code>-tiedostossa on pohja sovelluksesi etusivulle, eli sivulle, jonka näit, kun siirryit ensimmäistä kertaa selaimessa sovellukseesi. Tee harjoituksen vuoksi tiedostoon pieni muutos, muuta vaikka sivulla olevan otsikon sisältöä. Voit avata <code>Elokuvakirjasto</code>-kansion NetBeansiin valitsemalla siinä File > New Project > HTML5 > HTML5 Application with Existing Sources ja valitsemalla kansioksi <code>Elokuvakirjasto</code>-kansion. Asenna sen jälkeen tarvittavat riippuvuudet klikkaamalla oikeaa hireen painiketta projektin nimen päällä ja valitsemalla ensin "Npm install" ja sen jälkeen "Bower install". Riippuvuuksien mukana tulee mm. Karma, jonka avulla voit testata sovellustasi. Lisäksi <code>bower_components</code>-kansioon ilmestyy läjä kirjastoja, joista on sinulle luultavasti hyötyä. Jos tarvitset muita kirjastoja, lisää vain tarvittavat riippuvuudet <code>bower.json</code>-tiedostoon ja valitse "Bower install". Jos käytät laitoksen koneita, suorita terminaalissa <code>Elokuvakirjasto</code>-kansion juuressa komennot <code>npm install</code> ja <code>./node_modules/bower/bin/bower install</code>.
</p>
<p>
  Kun haluat ajaa sovelluksesi selaimessasi, klikkaa hiiren oikeaa painiketta projektin nimen päälle ja valitse "Properties", avautuvast ikkunasta "Run" ja valitse "Start File" kenttään tiedosto <code>web/index.html</code>.
</p>
<p>
  Kun jokin muutos on tehty, siirry terminaalissa hakemistoon <code>Elokuvakirjasto</code> ja suorita komennot <code>git add</code>, <code>git commit -m "Pieni muutos index.html-tiedostoon"</code> ja <code>git push heroku master</code>. Komennon suorittamisen jälkeen Heroku julkaisee tekemäsi muutokset. Kun Heroku on valmis, siirry sovellukseesi selaimella (joko komennolla <code>heroku open</code> tai menemällä sovellukseen suoraan selaimella) ja varmista, että muutoksesi on tullut voimaan.
</p>
  <div class="tehtavat">
    <p>
      Jos sinulla on vaikeuksia sovelluksen kehittämisessä NetBeansissa, lue <a href="#17.1.3-Muutosten-julkaiseminen-Herokussa">tämä</a> ohje.
    </p>
    <h3>Look Mama, I'm in Heroku!</h3>
    <p>
      Noudata yllä olevia ohjeita ja julkaise <code>Elokuvakirjasto</code>-projektin pohja Herokussa. Harjoittele lisäksi hieman muutosten julkaisemista tekemällä jokin pieni muutos sovellukseesi (esimerkiksi etusivun otsikon vaihtaminen) ja julkaise muutettu sovellus. Kun olet saanut sovelluksesi pohjan Herokuun ja osaat julkaista muutoksia, voit palauttaa tehtävän lisäämällä <code>index.html</code>-tiedostoon linkin Herokussa sijaitsevaan sovellukseesi.
    </p>
  </div>
  <h3>Lisää Angularia: sisäkkäiset kontrollerit</h3>
  <p>
    Usein Angular-sovelluksessa halutaan jakaa malli kahden kontrollerin kesken. Tällöin on kätevää muodostaa sovellukseen kontrollerihierarkioita, jossa kontrollerin sisällä määritellyt kontrollerit pääsevät käsiksi sen näkyvyysalueeseen. Määrittelemällä sisäkkäisiä kontrollereja pystymme vähentämään yhden kontrollerin vastuulla olevia tehtäviä ja toteuttamaan kompakteja kontrollereita, joilla on vain yksi tehtävä. Tässä käytännön esimerkki, miten pystymme siitimään viikon neljä esimerkissä toteutettua ystävien listaa sisäkkäisillä kontrollereilla:
  </p>
<pre class="sh_html">
&lt;div ng-app="FriendApp"&gt;
  &lt;div ng-controller="FriendController"&gt;
    &lt;ul ng-repeat="friend in person.friends"&gt;
      &lt;li&gt;{{friend}} &lt;button ng-click="removeFriend($index)"&gt;Poista&lt;/button&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div ng-controller="AddFriendController"&gt;
      &lt;input type="text" ng-model="newFriend"&gt;
      &lt;button ng-click="addFriend()"&gt;Lisää ystävä&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>
  Nyt <code>FriendController</code>-kontrollerin sisään on määritelty kontrolleri <code>AddFriendController</code>, jonka tehtävä on yksittäisen ystävän lisääminen <code>friends</code>-taulukkoon. Katsotaan, miten se tapahtuu kontrollerissa:
</p>
<pre class="sh_javascript_dom">
FriendApp.controller('AddFriendController', function($scope){
  $scope.addFriend = function(){
    $scope.$parent.friends.push($scope.newFriend);
    $scope.newFriend = '';
  }
});
</pre>
<p>
  Vanhemman näkyvyysalueeseen pääse siis <code>$parent</code>-muuttujan kautta. Tosin tässä tilanteessa <code>AddFriendController</code>-kontrollerin näkyvyysalueeseen ei ole määritelty muuttujaa <code>friends</code>, niin vanhemman näkyvyysalueen muuttujaan voi viitata ilman <code>$parent</code>-muuttujaa. Kontrollereja voi olla sisäkkäin vaikka kuinka monessa tasossa ja <code>$parent</code>-muuttuja pystyy ketjuttamaan niin, että kontrollerihierarkiassa sisemmässä kontrollerissa pääsee aina ulomman kontrollerin näkyvyysalueeseen.
</p>
  <h3>Lisää testaamista: Injektoitavien komponenttien käyttäminen testeissä</h3>
  <p>
    Palataan tässä vaiheessa hetkeksi takaisin testaamiseen. Toteutimme viime viikolla Firebase-osion yhteydessä sovellukseemme <code>FirebaseService</code>-palvelun, joka keskusteli Firebasen kanssa. Koska Firebase oli avainasemassa sovelluksessamme, koko sovelluksemme nojautui hyvin vahvasti <code>FirebaseService</code>-palveluun. Jos miettii sovelluksen testaamista, sitä käyttävän kontrollerin testaaminen kuulostaa hyvin hankalta mm. siitä syystä, että <code>FirebaseService</code>-palvelu käyttää tietokantaa, jonka sisältö on testeissä arvaamaton. Miten voisimme siis testata kontrolleriamme, johon on injektoitu <code>FirebaseService</code>-palvelu?
  </p>
  <p>
    Selviämme testaamisesta paljon helpommalla, jos vain oletamme, että <code>FirebaseService</code>-toimii, kuten pitääkin (ideaalitilanteessa se varmistettaisiin vielä testeillä) ja luomme sille nk. "mockin" (suomeksi "väärennös"), jonka injektoimme testeissä kontrolleriimme. Tällöin voimme testata sovellustamme komponentti kerrallaan ja varmistaa, että jokainen komponentti toimii sekä yksin, että yhdessä muiden komponenttien kanssa. Komponentin mockkaaminen ei ole sen kummempaa, kuin määrittämällä sen tarjoamien funktioiden paluuarvot etukäteen. Tällöin tiedämme testeissämme, mitä arvoja olettaa testeissä. Tässä esimerkki mockista, jonka <code>FirebaseService</code>-palvelulle voisi luoda:
  </p>
<pre class="sh_javascript_dom">
describe('MyController', function(){
  var controller, scope;

  // FireBaseService-palvelun mockki
  var FirebaseServiceMock;

  beforeEach(function(){
    module('MyApp');

    FirebaseServiceMock = (function(){
      // Nämä viestit esittävät Firebasessa olevia viestejä
      var messages = [
        {
          text: 'Hi girls!'
        },
        {
          text: 'Mikä boogie?'
        },
        {
          text: 'Angular on parasta!'
        }
      ];

      return {
        addMessage: function(message){
          messages.push(message);
        },

        getMessages: function(){
          return messages;
        },

        editMessage: function(message){
          // Etsitään muokattava viesti mockin taulukosti
          messageToEdit = messages.find(function(m){ return m.text = message.text });
          if(messageToEdit){
            // Muokataan viestiä
            messageToEdit.text = message.text;
          }
        },

        removeMessage: function(message){
          // Valitaan kaikki viestit, paitsi poistettava viesti
          messages = messages.filter(function(m){ m.text != message.text });
        }
      }

    })();

    inject(function($controller, $rootScope) {
      scope = $rootScope.$new();
      controller = $controller('MyController', {
        $scope: scope,
        FirebaseService: FirebaseServiceMock
      });
    });
  });

  it('should be able to get all the messages', function(){
    expect(scope.messages.length).toBe(3);
    expect(scope.messages[0].text).toBe('Hi girls!');
  });

  it('should be able to add a message', function(){
    scope.newText = 'I am back!';
    scope.addMessage();
    expect(scope.messages.length).toBe(4);
    expect(scope.messages[3].text).toBe('I am back!');
  });

  it('should be able to edit a message', function(){
    var message = scope.messages[0];
    message.editText = 'Hi boys!';
    scope.editMessage(message);
    expect(scope.messages[0].text).toBe('Hi boys!');
  });

  it('should be able to remove a message', function(){
    var message = scope.messages[0];
    scope.removeMessage(message);
    expect(scope.messages.length).toBe(2);
  });
});
</pre>
<p>
  Toteutamme siis kaikki <code>FirebaseService</code>-palvelun tarjoamat funktiot <code>FirebaseServiceMock</code>-mockkiimme, jossa palautamme funktiot objektina. Nyt tiedämme, mitä dataa <code>FirebaseService</code>-palvelu palauttaa kutsuttaessa ja miten se muokkaa sitä, joten voimme keskittyä pelkän kontrollerin testaamiseen. Mockatussa palvelussa tarjoamme täysin samat palvelut kuin oikeassa palvelussamme, mutta sen sijaan, että viestimme olisivat oikeasti tietokannassa, ne ovat pelkästään taulukossa. Tätä kontrolleri ei kuitenkaan tiedä, koska sen käyttämä rajapinta pysyy täysin samana. Nyt testeissä kontrolleriin injektoidaan <code>FirebaseService</code>-palvelun sijaan testissä määrittämäämme mockki <code>FirebaseServiceMock</code>, kuten <code>$controller</code>-funktion kutsusta näkee.
</p>
<h4>Funktiokutsujen vakoilu</h4>
<p>
  Testeissä on usein hyvä varmistaa, että jotain funktiota kutsutaan, kun suoritetaan tietyt toiminnot. Esimerkiksi, kun käyttäjä lisää viestin, pitäisi kontrollerissa kutsua <code>FirebaseService</code>-palvelun funktiota <code>addMessage</code>. Jasmine testeissä voikin asettaa "vakoojia", jotka tarkkailevat tietyn objektin funktiota. Voimme esimerkiksi asettaa edellisessä esimerkissä käytettyyn <code>FirebaseServiceMock</code>-mockkiin vakoojat, jotka tarkkailevat sen funktiota <code>addMessage</code>, <code>getMessages</code>, <code>editMessage</code> ja <code>removeMessage</code>. Tehdään se <code>beforeEach</code>-funktiokutsun yhteydesessä, jotta vakoojat asetetaan funktioihin jokaisen testin yhteydessä:
</p>
<pre class="sh_javascript_dom">
describe('MyController', function(){
  var controller, scope;

  // FireBaseService-palvelun mockki
  var FirebaseServiceMock;

  beforeEach(function(){
    module('MyApp');

    FirebaseServiceMock = // ...

    // Laitetaan vakoilijat tositoimeen
    spyOn(FirebaseServiceMock, 'addMessage').and.callThrough();
    spyOn(FirebaseServiceMock, 'getMessages').and.callThrough();
    spyOn(FirebaseServiceMock, 'editMessage').and.callThrough();
    spyOn(FirebaseServiceMock, 'removeMessage').and.callThrough();

    inject(function($controller, $rootScope) {
      scope = $rootScope.$new();
      controller = $controller('MyController', {
        $scope: scope,
        FirebaseService: FirebaseServiceMock
      });
    });
  });

  it('should initially call getMessages-function', function(){
    // Kutsutaan toHaveBeenCalled-funktiota, jolloin oletamme, että getMessages funktiota on kutsuttu
    expect(FirebaseServiceMock.getMessages).toHaveBeenCalled();
  });

  it('should call addMessage-function when adding a message', function(){
    scope.newText = 'Viestiä pukkaa!';
    scope.addMessage();
    expect(FirebaseServiceMock.addMessage).toHaveBeenCalled();
  });
});
</pre>
<p>
  Lisäsimme funktioille vakoilijat kutsumalla <code>spyOn</code>-funktiota, joka ottaa ensimmäiseksi parametrikseen objektin, jonka funktiota halutaan vakoilla ja toiseksi parametriksi itse tarkkailtavan funktion nimen. Ketjutamme funktiokutsun perään vielä kutsun <code>and.callTrough()</code>. Kun vakoilija on asetettu, voimme testeissä olettaa, että jotain funktiota, kuten <code>FirebaseService</code>-palvelun <code>addMessage</code>-funktiota, on kutsuttu <code>toHaveBeenCalled</code>-oletuksen avulla. Usein halutaan myös varmistaa, että jotain funktiota ei kutsuta, se onnistuu <code>not.toHaveBeenCalled</code>-oletuksella.
</p>
<h3>Lisää Firebasea: yksittäisen objektin haku</h3>
<p>
  Firebase lisää jokaiselle lisätylle objektille yksilöllisen avaimen, joka erottaa sen muista taulukon objekteista. Avain on satunnainen merkkijono, joka löytyy jokaisesta objektista kentästä <code>$id</code>. Avainta voi käyttää hyväkseen vaikkapa sovelluksen reiteissä, jos halutaan toteuttaa objektikohtaisia näkymiä, kuten esittelysivuja.
</p>
<p>
  Yksittäisen objektin saa haettua Firebasesta käyttämällä <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-getrecordkey" target="_blank">$getRecord</a></code>-funktiota:
</p>
<pre class="sh_javascript_dom">
MyApp.service('FirebaseService', function($firebase){
  var firebaseRef = new Firebase('OMA_FIREBASE/data');
  var sync = $firebase(firebaseRef);
  var dataAsArray = sync.$asArray();

  this.getObject = function(key, done){
    dataAsArray.$loaded(function(){
      done(dataAsArray.$getRecord(key));
    });
  }
});
</pre>
<p>
  <code>$getRecord</code>-funktion kutsussa on vaaran paikka, koska se olettaa, että Firebasesta haettu taulukko <code>dataAsArray</code> on kutsumisen hetkellä ladattu. <code>getObject</code>-funktiossa täytyy varmistua, että <code>dataAsArray</code>-taulukko on ladattu ennen kuin haemme sieltä objektin. Se onnistuu käyttämällä <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-loaded">$loaded</a></code>-funktiota, joka ottaa parametrikseen funktion, jota kutsutaan, kun <code>dataAsArray</code>-taulukko on haettu Firebasesta. Olemme välittäneen <code>getObject</code>-funktiolla avaimen lisäksi toisen parametrin, joka on oma callback-funktiomme, jonka voimme antaa kontrollerissa:
</p>
<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, $routeParams, FirebaseService){
  FirebaseService.getObject($routeParams.key, function(data){
    $scope.data = data;
  });
});
</pre>
<p>
  Tässä kontrollerissa haettavan objektin avain otetaan polkuparametrista, jolloin käyttäjän siirtyessä esimerkiksi polkuun <code>#/data/-JifGkiMM_GDi6fiZbyk</code>, haetaan Firebasesta objekti avaimella <code>-JifGkiMM_GDi6fiZbyk</code>.
</p>
  <div class="tehtavat">
    <p>
      Jos sinulla on vaikeuksia sovelluksen kehittämisessä NetBeansissa, lue <a href="#17.1.3-Muutosten-julkaiseminen-Herokussa">tämä</a> ohje.
    </p>
    <p style="padding-top: 10px">
      Kaikki näistä tehtävistä palautetaan Herokuun, joten tehtäpohjien palautuksessa riittää laittaa linkki Heroku-sovellukseesi tehtäväpohjien <code>index.html</code>-tiedostoon. Tehtävien tekoon kannattaa kuitenkin käyttää forkkaamasi <code>Elokuvakirjasto</code>-repon pohjaa, jotta voit helposti julkaista tekemäsi muutokset Herokuun. Pystyt avaamaan sen NetBeansissa valitsemalla File > New Project > HTML5 > HTML5 Application with Existing Sources ja valitsemalla kansioksi <code>Elokuvakirjasto</code>-kansion. Muista asentaa riippuvuudet klikkaamalla hiiren oikeaa painiketta projektin nimen päällä ja valitsemalla "Npm install" ja "Bower install". Jos käytät laitoksen konetta, suorita terminaalissa projektisi juuressa komennot <code>npm install</code> ja <code>./node_modules/bower/bin/bower install</code>, jotka tekevät täysin saman asian.
    </p>
    <h3>Elokuvien listaaminen ja lisääminen (2p)</h3>
    <p>
      Toteutaan sovellukseemme ensimmäisenä toiminnot elokuvien listaamiselle ja lisäämiselle. Voit aloittaa toteuttamalla palvelun, joka hakee Firebasesta kaikki elokuvat ja lisää sinne elokuvan annetuilla tiedoilla. Muistin virkistämiseksi, datan haku Firebasesta toimi näin:
    </p>
<pre class="sh_javascript_dom">
var firebaseRef = new Firebase('OMA_FIREBASE/movies');
var sync = $firebase(firebaseRef);
var movies = sync.$asArray();

this.getMovies = function(){
  return movies;
}
</pre>
    <p>
      Ja lisääminen puolestaan näin:
    </p>
<pre class="sh_javascript_dom">
this.addMovies = function(movie){
  movies.$add(data);
}
</pre>
    <p>
      Muista myös injektoida, <code>firebase</code>-moduuli omaan moduuliisi, sekä <code>$firebase</code> palveluusi:
    </p>
<pre class="sh_javascript_dom">
var MyApp = angular.module('MyApp', ['firebase']);

MyApp.service('FirebaseService', function($firebase){
  // ...
});
</pre>
    <p>
      Käyttämällämme AngularFire-kirjastolla on hyvä <a href="https://www.firebase.com/docs/web/libraries/angular/guide.html" target="_blank">ohje</a> Firebasen käyttöön Angularissa, johon kannattaa ehdottomasti tutustua.
    </p>
    <p>
      Kun palvelu on toteutettu, toteuta kaksi kontrolleria, jotka käyttävät toteuttamaasi palvelua: kontrolleri elokuvien listaamiselle ja elokuvan lisäämiselle. Kontrollereista pitäisi löytyä ainakin toiminnot Firebasesta löytyvien elokuvien listataamiselle, elokuvan lisäämäämiseksi Firebaseen sen nimellä, ohjaajalla, julkaisuvuodella ja kuvauksella. Jos joku näistä kentistä on tyhjä, ei elokuvaa tule lisätä. Näytä käyttäjälle virhetilanteissa virheilmoitukset (vinkki: <a href="https://docs.angularjs.org/guide/forms" target="_blank">lomakkeet ja niiden validointi</a>). Kun elokuva on lisätty, tulee käyttäjä ohjata polkuun <code>#/movies</code> (vinkki: <code><a href="https://docs.angularjs.org/api/ng/service/$location" target="_blank">$location</a></code>). Muista injektoida toteuttamasi palvelu kontrollereihisi, jotta pääset käyttämään sitä niissä!
    </p>
    <p>
      Kun kontrollerit on toteutettu, toteuta sovellukseesi reititys, jossa näkymä elokuvien listaamiselle löytyy sekä polusta <code>#/movies</code>, että polusta <code>#/</code> (etusivu) ja näkymä elokuvan lisäämiselle löytyy polusta <code>#/moviews/new</code>. Näkymien ei tarvitse olla nättejä, riittää että elokuvien listassa löytyy elokuvat niiden nimillä ja elokuvien lisäyksessä elokuvan pystyy lisäämään sen nimellä, ohjaajalla, julkaisuvuodella ja kuvauksella sopivan lomakkeen kautta.
    </p>
    <p>
      Elokuvien listaamiselle ja lisäämiselle löytyy pari testiä <code>test</code>-kansiota. Elokuvien listaamisen testit löytyvät kansiosta <code>test/movie_list_test.js</code> ja elokuvien lisäämisen testit kansiosta <code>test/add_movie_test.js</code>. Testaa mollemmissa teisteissä kuvattuja toimintoja. Muista mockata Firebasen kanssa keskuteleva palvelusi niin, että tiedät, mitä dataa kontrollerien pitäisi saada. Testaa lisäksi, että Firebasea käyttävän palvelun funktiota kutsutaan kontrollereissa lisäämällä funktioihin vakoilijat <code>spyOn</code>-funktiolla ja lisäämällä <code>toHaveBeenCalled</code>-oletukset funktioihin, joita pitäisi kutsua. Muista muokata tarvittaessa <code>Elokuvakirjasto</code>-kansion juuressa sijaitsevaa <code>karma.conf.js</code>-tiedostoa, niin että testattavat tiedostot ladataan selaimeen, joka onnistui lisäämällä niiden polut tiedostossa määriteltyyn <code>files</code>-taulukkoon.
    </p>
    <h3>Elokuvien esittäminen, muokkaaminen ja poistaminen (2p)</h3>
    <p>
      Toteuta seuraavaksi Firebase käyttävään palveluusi toiminnot elokuvan esittämiselle muokkaamisella, poistamiselle. Muokkaukseen voit käyttää funktiota <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-saverecordorindex" target="_blank">$save</a></code> ja poistamiseen funktiota <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-removerecordorindex" target="_blank">$remove</a></code>. Elokuvan esittäminen kannattaa toteuttaa niin, että haet Firebasea käyttävästä palvelussa elokuvan avaimella, jolla se on talletettu käyttäen <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-getrecordkey" target="_blank">$getRecord</a></code>-funktiota. Muistathan, että yksittäisin objektin haku Firebasesta onnistui seuraavasti:
    </p>
<pre class="sh_javascript_dom">
var firebaseRef = new Firebase('OMA_FIREBASE/movies');
var sync = $firebase(firebaseRef);
var movies = sync.$asArray();

this.getMovie = function(key, done){
  movies.$loaded(function(){
    done(movies.$getRecord(key));
  });
}
</pre>
<p>
  Muista varoa vaarallista asynkronisuusmörköä! Odota, että data on haettu Firebasesta ennen kuin yrität hakea sieltä objektia käyttämällä <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-loaded" target="_blank">$loaded</a></code>-funktiota, jonka sisällä kutsut parametrina saatua callback-funktiota haetulla objektilla.
</p>
<p>
  Kun Firebasea käyttävät toiminnot on toteutettu palveluun, luo kontrollerit elokuvan esittämiselle ja muokkaamiselle. Kuten elokuvan lisäyslomakkeen kanssa, muista myös validoida muokkauslomakkeen kentät ja näytä käyttäjälle virhetilanteissa virheilmoitukset (vinkki: <a href="https://docs.angularjs.org/guide/forms" target="_blank">lomakkeet ja niiden validointi</a>). Lisää myös viime tehtävässä toteutettuun elokuvat listaavaan kontrolleriin toiminto elokuvan poistamiselle, jotta käyttäjä voi poistaa elokuvan esimerkiksi painamalla "Poista"-painiketta elokuvan nimen vieressä.
</p>
<p>
  Lisää kontrollereillesi myös reitit. Elokuvan esittelysivun tulee löytyä polusta <code>#/movies/KEY</code>, jossa parametri <code>KEY</code> on Firebaseen talletetun elokuvan avain. Muistathan, että yksittäisen objektin voi hakea Firebasesta käyttämällä <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-getrecordkey" target="_blank">$getRecod</a></code>-funktiota seuraavasti:
</p>
<p>
  Muokaa elokuvat listaavaa näkymää niin, että elokuvien nimet ovat linkkejä, jotka johtavat niiden esittelysivuille esimerkiksi seuraavasti:
</p>
<pre class="sh_html">
&lt;ul&gt;
  &lt;li ng-repeat="movie in movies"&gt;
    &lt;a ng-href="#/movies/{{movie.$id}}"&gt;{{movie.name}}&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>
  Jokaisella Firebasesta haetulla elokuvalla on <code>$id</code>-kenttä, jossa on sen avain, jonka avulla sen voi hakea käyttämällä <code>$getRecord</code>-funktiota. Elokuvan esittelysivulta tulee olla otsikkona elokuvan nimi ja sen alapuolella sen ohjaaja, julkaisuvuosi ja kuvaus haluamassasi muodossa.
</p>
<p>
  Lisää myös muokkaussivulle polku <code>#/movies/KEY/edit</code>, jossa <code>KEY</code>-parametri on muokattavan elokuvan avain. Täytä muokkauslomakkeessa kentät automaattisesti muokattavan elokuvan tiedoilla.
</p>
<p>
  Elokuvan esittelylle, muokkaukselle ja poistolle löytyy muutama testi <code>test</code>-kansion tiedostoista <code>edit_movie_test.js</code> ja <code>show_movie_test.js</code>. Joudut molemmissa luomaan mockin sekä käytämällesi Firebase-palvelulle, että <code>$routeParams</code>-muuttujalle, jonka avulla määrität elokuvalla kuvitteellisen avaimen polun parametreihin. <code>RouteParamsMock</code>-voisi toimia esimerkiksi seuraavasti:
</p>
<pre class="sh_javascript_dom">
RouteParamsMock = (function(){
  return {
    key: 'abc123'
  }
})();
</pre>
<p>
  Nyt Firebase-palvelun mockkiin voi toteuttaa elokuvan haun sen avaimelle esimerkiksi seuraavasti:
</p>
<pre class="sh_javascript_dom">
FirebaseServiceMock = (function(){
  return {
    getMovie: function(key, done){
      if(key == 'abc123'){
        done({
          name: 'Joku leffa',
          director: 'Kalle Ilves',
          release: 2015,
          description: 'Mahtava leffa!'
        });
      }else{
        done(null);
      }
    },
    // ...
  }
});
</pre>
<p>
  Testaa lisäksi, että Firebasea käyttävän palvelusta kutsutaan oikeita funktioita lisäämällä niihin vakoojat <code>spyOn</code>-funktion avulla ja lisäämällä <code>toHaveBeenCalled</code>-oletukset funktioihin, joita pitäisi kutsua.
</p>
<p>
   Muista muokata tarvittaessa <code>Elokuvakirjasto</code>-kansion juuressa sijaitsevaa <code>karma.conf.js</code>-tiedostoa, niin että testattavat tiedostot ladataan selaimeen, joka onnistui lisäämällä niiden polut tiedostossa määriteltyyn <code>files</code>-taulukkoon.
</p>
  <h3>Elokuvien haku: OMDb API</h3>
  <p>
    Toteutaan lopuksi sovellukseemme elokuvien haku käyttäen <a href="http://www.omdbapi.com/" target="_blank">The Open Movie Databasen API:a</a>. Sen kautta voimme hakea elokuvia eri <a href="http://www.omdbapi.com/#parameters" target="_blank">parametrien</a> perusteella. Voimme esimerkiksi hakea kaikki elokuvat, joiden nimestä löytyy sana "lord" osoitteesta <code>http://www.omdbapi.com/?s=lord</code>, jolloin saamme vastauksena JSON-muotoisen objektin haun tuottamista tuloksista. Vastaus voi olla esimerkiksi tämä:
  </p>
<pre class="sh_javascript_dom">
{"Search":[{"Title":"The Lord of the Rings: The Fellowship of the Ring","Year":"2001","imdbID":"tt0120737","Type":"movie"},{"Title":"The Lord of the Rings: The Return of the King","Year":"2003","imdbID":"tt0167260","Type":"movie"},{"Title":"The Lord of the Rings: The Two Towers","Year":"2002","imdbID":"tt0167261","Type":"movie"},{"Title":"Lord of War","Year":"2005","imdbID":"tt0399295","Type":"movie"},{"Title":"The Lord of the Rings","Year":"1978","imdbID":"tt0077869","Type":"movie"},{"Title":"Lord of the Flies","Year":"1990","imdbID":"tt0100054","Type":"movie"},{"Title":"Greystoke: The Legend of Tarzan, Lord of the Apes","Year":"1984","imdbID":"tt0087365","Type":"movie"},{"Title":"Lord of the Flies","Year":"1963","imdbID":"tt0057261","Type":"movie"},{"Title":"Lord of Illusions","Year":"1995","imdbID":"tt0113690","Type":"movie"},{"Title":"Something the Lord Made","Year":"2004","imdbID":"tt0386792","Type":"movie"}]}
</pre>
<p>
  Vastauksena saamme siis objektin, jonka <code>Search</code>-kentästä löytyy taulukko haun tuloksista, joista jokainen on objekti, jossa on elokuvan nimi (<code>Title</code>), julkaisuvuosi (<code>Year</code>), id sen esittelysivulle <a href="http://www.imdb.com" target="_blank">IMDb</a>:ssä (<code>imdbID</code>).
</p>
<p>
  Toteuta sovellukseesi palvelu, jonka kautta elokuvaa voi hakea sen nimellä ja julkaisuvuodella OMDb API:n kautta. Voit tehdä Angularissa AJAX-kutsuja käyttämällä <code><a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a></code>-palvelua. Tässä tapauksessa kyseessä on GET-pyyntö, joten voimme käyttää palvelun tarjoamaa <code><a href="https://docs.angularjs.org/api/ng/service/$http#get" target="_blank">get</a></code>-funktiota seuraavasti:
</p>
<pre class="sh_javascript_dom">
MyApp.service('APIService', function($http){
  this.findMovie = function(name){
    return $http.get('http://www.omdbapi.com', { params: { s: name } });
  }
});
</pre>
<p>
  <code>get</code>-funktio ottaa siis parametreikseen pyynnön osoitteen ja objektin, joka sisältää kyselyyn liittyviä konfiguraatioita. Tässä kyselyssä lisäämme kyselyyn <code>s</code>-parametrin, jonka arvo on <code>findMovie</code>-funktion parametrina saama elokuvan nimi. Huomaa, että palautamme funktiossa koko kyselyn. Voimme käyttää palveluun toteutettua funktiota kontrollerissa seuraavasti:
</p>
<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, APIService){
  APIService.findMovie('lord').success(function(movies){
    $scope.movies = movies;
  });
});
</pre>
<p>
  <code>findMovie</code>-funktion kutsu siis palauttaa suoritettan kyselyn. Koska kysely on asynkroninen, täytyy sille antaa funktio, jota kutsutaan, kun kyselyyn on vastattu. Se onnistuu kutsumalla palautetulle kyselylle <code>success</code>-funktiota, jonka parametrina saatua funktiota kutsutaan, kun kyselyyn on vastattu parametreina palvelimelta saatu vastaus.
</p>
<p>
  Angular tekee AJAX-pyynnöissä ikävän tempun ja lisää pyyntöihin otsakkeen <code>X-Requested-With</code>, jonka seurauksena, emme voi tehdä AJAX-pyyntöjä oman sovelluksemme ulkopuolelle. Pystymme kuitenkin poistamaan otsakkeen konfiguroimalla hieman moduuliamme:
</p>
<pre class="sh_javascript_dom">
var MyApp = angular.module('MyApp', []);

MyApp.config(['$httpProvider', function($httpProvider) {
  delete $httpProvider.defaults.headers.common["X-Requested-With"]
}]);
</pre>
<p>
  Riittää siis konfiguroida <code>$httpProvider</code>-komponenttia, niin, että <code>X-Requested-With</code>-otsake poistetaan pyynnön oletusotsakkeista. Nyt pyynnöt toimivat, kuten pitääkin!
</p>
<p>
  Toteuta elokuvat listaavaan kontrolleriin elokuvien haku niin, että käyttäjä voi näkymässä hakea elokuvaa sen nimellä ja julkaisuvuodella täyttämällä hakulomakkeen, jossa on kaksi tekstikenttää (nimelle ja julkaisuvuodelle). Jos haku tuottaa tuloksia, listaa ne hakulomakkeen alapuolelle niin, että elokuvan nimi on linkki sen IMDb-sivulle. Elokuvan IMDb-sivut ovat muotoa <code>http://http://www.imdb.com/title/imdbID</code>, jossa <code>imdbID</code>-arvon saat hakukyselystä OMDb API:in. Jos haku ei tuota tuloksia, tulee hakulomakkeen alla olla otsikko "Hakusanalla ei löytynyt elokuvia". Jos haku tuottaa tuloksia näytä hakulomakkeen alla otsikko "Haulla löytyi X elokuvaa", jossa <code>X</code> on löytyneiden elokuvien määrä. Muista selkeä suomen kieli, eli jos elokuvia löytyi monta, käytä sanaa "elokuvaa" ja jos niitä löytyi vain yksi käytä sanaa "elokuva" (vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngPluralize" target="_blank">ng-pluralize</a></code>). Onnistuneella haualla listaa otsikon alle elokuvan nimi linkkinä sen sivulle <a href="http://www.imdb.com/" target="_blank">IMDb</a>:ssä ja sen vieressä sen julkaisuvuosi.
</p>
</div>
<h3>Turvallisuus ennen kaikkea: authentikaatio Firebasen avulla</h3>
<p>
  Tällä hetkellä Elokuvakirjasto-sovelluksessamme ei ole minkäänlaista estettä sille, ettei kuka pystyisi lisäämään, muokkaamaan ja poistamaan elokuvia mielensä mukaan. Se ei ole kovin hyvä asia, haluammekin sovellukseemme authentikaation, jonka avulla vain sovellukseen rekisteröityneet käyttäjät pääsevät tekemään muutoksia sovelluksemme elokuviin.
</p>
<p>
  Firebasessa on monta tapaa toteuttaa sovellukseen authentikaatio, kuten Facebookin tai Twitterin kautta. Me kuitenkin toteutamme perinteisen kirjautumisen sähköpostiosoitteella ja salasanalla. Aloitetaan luomalla palvelu <code>AuthenticationService</code>, jonka kautta voimme lisätä Firebaseen käyttäjän ja kirjata käyttäjän sisään sovellukseemme:
</p>
<pre class="sh_javascript_dom">
MyApp.service('AuthenticationService', function($firebase, $firebaseAuth){
  var firebaseRef = new Firebase('OMA_FIREBASE');
  var firebaseAuth = $firebaseAuth(firebaseRef);

  this.logUserIn = function(email, password){
    return firebaseAuth.$authWithPassword({
      email: email,
      password: password
    });
  }

  this.createUser = function(email, password){
    return firebaseAuth.$createUser({
      email: email,
      password: password
    });
  }
});
</pre>
<p>
  Authentikaatio Firebasen kautta onnistuu sen tarjoaman <code>$firebaseAuth</code>-palvelun avulla, jonka olemme injektoineet omaan palveluumme. Talletimme authentikaatio-objektin, jonka luimme kutsumalla <code>$firebaseAuth</code>-palvelua viitteellä omaan Firebaseemme, muuttujaan <code>firebaseAuth</code>. Palvelussamme on kaksi funktiota, <code>logUserIn</code>, jonka avulla käyttäjä voi kirjautua sisään sähköpostiosoitteella ja salasanalla käyttäen <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-users-and-authentication-authwithpasswordcredentials-options" target="_blank">$authWithPassword</a></code>-funktiota, sekä funktio <code>createUser</code>, jonka avulla käyttäjä voi luoda uuden käyttäjätilin sähköpostiosoitteella ja salasanalla käyttäen <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-users-and-authentication-createusercredentials" target="_blank">$createUser</a></code>-funktiota. Molemmissa tapauksissa palautamme funktiokutsut, jotka ovat asynkronisia. Joudumme siis seuraavaksi kontrollerissa määrittelemään, mitä tehdään, kun asynkronin funktiokutsu on suoritettu ja mitä tapahtuu, jos jokin menee pieleen.
</p>
<p>
  Authentikaation hoitavan palvelun toteuttaminen ei tosin vielä riitä, koska emme ole missään vaiheessa määrittäneet, että vain kirjautuneet käyttäjät saavat tehdä muokkauksia. Siirrytään seuraavaksi sovelluksesi hallintasivulle Firebasessa ja valitaan oikeasta laidasta "Security & Rules". Tällä hetkellä "FIREBASE RULES"-kentän sisältö on suurin piirtein seuraava:
</p>
<pre class="sh_javascript_dom">
{
    "rules": {
        ".read": true,
        ".write": true
    }
}
</pre>
<p>
  Kentän arvo on JSON-muotoinen objekti, jossa <code>rules</code>-kentässä määritellään joko kaikkiin resursseihin, tai tiettyihin resursseihin kohdistuvat säännöt. Kuten varmasti jo arvasit, tämän hetkisten sääntöjen perusteella kaikilla on luku- ja kirjoitusoikeudet jokaiseen resurssiin. Se ei ole kovin hyvä asia. Muokataan elokuva-resurssia niin, että vain kirjautuneilla käyttäjillä on kirjoitusoikeus:
</p>
<pre class="sh_javascript_dom">
{
    "rules": {
      "movies": {
          ".read": true,
          ".write": "auth !== null && auth.provider === 'password'"
      }
    }
}
</pre>

<img src="img/firebase-authentikaatio.png" style="float: left; margin-right: 15px; margin-bottom: 15px; width: 400px">

<p>
  Lisäsimme siis <code>rules</code>-objektiin resurssin <code>movies</code>, jonka sisällä määräsimme kirjoitusoikeudelle ehdon <code>auth !== null && auth.provider === 'password'</code>. Selvällä suomen kielellä ehto tarkoittaa sitä, että käyttäjän on pitänyt authentikoitua ja lisäksi käyttäjän on pitänyt authentikoitua salasanan kanssa ennen kuin hänellä on kirjoitusoikeus resurssiin <code>movies</code>. Meidän täytyy vielä erikseen sallia authentikaatio salasanalla sovelluksemme asetuksista. Se onnistuu klikkaamalla Firebasesovelluksen hallintasivun vasemmasta laidasta "Login & Auth" ja valitsemalla sieltä checkboxi "Enable Email & Password Authentication". Jos skrollaat sivua hieman alaspäin näet otsikon "Registered Users" alla kaikki sovelluksesi käyttäjät (joita tuskin vielä on) ja pystyt lisäämään, muokkaamaan ja poistamaan niitä.
</p>

<div style="clear: both;"></div>
<p>
  Lisätään seuraavaksi sovellukseemme kontrolleri, jonka kautta käyttäjä voi kirjautua sisään tai luoda uuden käyttäjätilin:
</p>
<pre class="sh_javascript_dom">
MyApp.controller('UserController', function($scope, $location, AuthenticationService){

  $scope.logIn = function(){
    AuthenticationService.logUserIn($scope.email, $scope.password)
    .then(function(){
      $location.path('/movies');
    })
    .catch(function(){
      $scope.message = 'Väärä sähköpostiosoite tai salasana!'
    });
  }

  $scope.register = function(){
    AuthenticationService.createUser($scope.newEmail, $scope.newPassword)
    .then(function(){
      AuthenticationService.logUserIn($scope.newEmail, $sopce.newPassword)
      .then(function(){
        $location.path('/movies');
      });
    })
    .catch(function(){
      $scope.message = 'Tapahtui virhe! Yritä uudestaan';
    });
  }
});
</pre>
<p>
  Kontrollereissa kutsutaan <code>AuthenticationService</code>-palvelun funktioita, jotka molemmat palauttavat asynkronisen funktiokutsun. Funktiokutsujen perään voi ketjuttaa <code>then</code>-funktion kutsun, jonka parametrina määriteltyä funktiota kutsutaan, kun Firebasesta saadaan pyynnölle myöntävä vastaus. Jos jotain menee pieleen, kutsutaan <code>catch</code>-funktion parametrina annettua funktiota. Nyt kun käyttäjä kirjautuu sisään oikealla sähköpostiosoitteella ja salasanalla, hänet ohjataan sivulle, josta löytyy lista elokuvista. Jos sähköpostiosoite tai salasana on virheellinen, voi kirjautumislomaakkeessa näyttää virheilmoituksen. Käyttäjä voi myös rekisteröityä, jonka jälkeen hän kirjautuu sisään automaattisesti (kuten näet <code>register</code>-funktion ensimmäisestä <code>then</code>-funktion kutsusta).
</p>
<p>
  Nyt authentikaatio toimii, kuten pitääkin, eli kirjautumaton käyttäjä ei pysty lisäämään, muokkaamaan tai poistamaan elokuvia. Sovelluksessa on tosin yksi pieni ongelma, sillä kirjautumaton käyttäjä pääsee vielä lisäys- ja muokkaussivuille sekä näkee listaussivulla poistopainikkeen. Ongelma on kuitenkin helppo ratkaista, lisätään ensin palveluumme funktio <code>checkLoggedIn</code>, joka tarkastaa, onko käyttäjä kirjaunut sisään käyttämällä <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-users-and-authentication-waitforauth" target="_blank">$waitForAuth</a></code>-funktiota:
</p>
<pre class="sh_javascript_dom">
MyApp.service('AuthenticationService', function($firebase, $firebaseAuth){
  var firebaseRef = new Firebase('OMA_FIREBASE');
  var firebaseAuth = $firebaseAuth(firebaseRef);

  // ...

  this.checkLoggedIn = function(){
    return firebaseAuth.$waitForAuth();
  }
});
</pre>
<p>
  Se on siinä! Voimme seuraavaksi käyttää palveluumme toteutettua funktiota sovelluksemme reittin määrittelemisessä:
</p>
<pre class="sh_javascript_dom">
MyApp.config(function($routeProvider){
  // Muut reitit...
  .when('/movies', {
    controller: // ...
    templateUrl: // ...,
    resolve: {
      currentAuth: function(AuthenticationService) {
        return AuthenticationService.checkLoggedIn();
      };
    }
  })
  .when('/movies/new', {
    controller: // ...
    templateUrl: // ...,
    resolve: {
      currentAuth: function(AuthenticationService) {
        return AuthenticationService.checkLoggedIn();
      };
    }
  })
  .when('/movies/:key/edit', {
    controller: // ...
    templateUrl: // ...,
    resolve: {
      currentAuth: function(AuthenticationService) {
        return AuthenticationService.checkLoggedIn();
      };
    }
  })
  // ...
});
</pre>
<p>
  Reittien määrittelyyn on nyt ilmestynyt mystinen <code>resolve</code>-kenttä. Se kertoo, mitä tulee tehdä ennen kuin reittiin siirrytään. <code>resolve</code>-kenttään voi määritellä vaikka kuinka monta "lupausta" (promise) tahansa, jotka kaikki toteutetaan ennen kuin reitissä määritelty kontrolleri ottaa ohjat käsisäänsä. Kun kaikki lupaukset on toteutettu, niiden palautusarvot injektoidaan reitissä määriteltyyn kontrolleriin.Tässä tilanteessa haluamme tarkastaa, onko käyttäjä kirjautunut sisään kutsumalla funktiota <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-users-and-authentication-waitforauth" target="_blank">$waitForAuth</a></code>. Kun Firebase antaa tiedon käyttäjän kirjautumisesta, se lisätään <code>currentAuth</code>-kenttään, joka injektoidaan reitin kontrolleriin seuraavasti:
</p>
<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, currentAuth, $location){
  if(!currentAuth){
    $location.path('/login');
  }
  // ...
});
</pre>
<p>
  Kuten huomaat, <code>resolve</code>-kentässä määritelty <code>currentAuth</code>-kenttä on injektoitu kontrolleriin ja se sisältää tiedon kirjautuneesta käyttäjästä. Jos <code>currentAuth</code> arvo on <code>null</code> tarkoittaa se sitä, että käyttäjä ei ole kirjautunut sisään, jolloin hänet tulee ohjata toiseen polkuun, kuten vaikkapa kirjautumissivulle.
</p>
<h4>Uloskirjautuminen</h4>
<p>
  Käyttäjällä pitäisi olla vielä mahdollisuus kirjautua ulos. Lisätään <code>AuthenticationService</code>-palveluun vielä funktio <code>logUserOut</code>, joka käyttää funktiota <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-users-and-authentication-unauth" target="_blank">$unauth</a></code>, joka poistaa tiedon käyttäjän kirjautumisesta Firebasesta:
</p>
<pre class="sh_javascript_dom">
MyApp.service('AuthenticationService', function($firebase, $firebaseAuth){
  var firebaseRef = new Firebase('OMA_FIREBASE');
  var firebaseAuth = $firebaseAuth(firebaseRef);

  // ...

  this.logUserOut = function(){
    firebaseAuth.$unauth();
  };

  this.getUserLoggedIn = function(){
    return firebaseAuth.$getAuth();
  }
});
</pre>
<p>
  Se on siinä! Toteutin palveluun myös funktion <code>getUserLoggedIn</code>, joka palauttaa tiedot kirjautuneesta käyttäjästä käyttämällä <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-users-and-authentication-getauth" target="_blank">$getAuth</a></code>-funktiota. <code>$getAuth</code>-funktio palauttaa null, jos käyttäjä ei ole kirjautunut sisään, muuten se palauttaa kirjautuneen käyttäjän tiedot. Seuraavaksi meidän täytyy lisätä kontrolleriin funktio, joka kutsuu palveluun toteuttamaamme funktiota. Olisi hyvä, jos funktio olisi käytössä jokaisessa kontrollerissa ja näkyvyysalueessa. Siksi onkin järkevää lisätä se koko sovelluksemme laajuiseen näkyvyysalueeseen, joka on nimeltään <code><a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope" target="_blank">$rootScope</a></code>. Voimme lisätä uloskirjautumiseen käytettävän funktion siihen seuraavasti:
</p>
<pre class="sh_javascript_dom">
MyApp.run(function(AuthenticationService, $rootScope){
  $rootScope.logOut = function(){
    AuthenticationService.logUserOut();
  };

  $rootScope.userLoggedIn = AuthenticationService.getUserLoggedIn();
});
</pre>
<p>
  <code>run</code>-funktion kutsutta suoritetaan moduulissa jokin funktio, aivan kuten jo reitityksen yhteydessä käyttämämme <code>config</code>-funktio. Ero funktioiden välillä on vain siinä, että <code>config</code>-funktio suoritetaan moduulin alustuksen yhteydessä ennen <code>run</code>-funktiota. Funktiokutsussa suoritamme funktion, jossa asetamme <code>$rootScope</code>-objektiin funktion <code>logOut</code>, joka käyttää palveluamme kirjatakseen käyttäjän ulos. Lisäksi lisäsin muuttujan <code>userLoggedIn</code>, jonka avulla näkymässä voi tarkastaa, onko käyttäjä kirjautunut sisään ja jos, niin millä tiedoilla. Määrittelemämme funktio ja muuttuja on nyt käytössä kaikissa näkymissä, joten voimme lisätä uloskirjautumista varten pohjatiedostoon (tiedostoon, jossa on määritelty <code>ng-view</code>-direktiivi) esimerkiksi seuraavan painikkeen:
</p>
<pre class="sh_html">
&lt;button ng-click="logOut()" ng-if="userLoggedIn"&gt;Kirjaudu ulos&lt;/button&gt;
</pre>
<p>
  Painikkeen ei siis tarvitse olla minkään kontrollerin näkyvyysalueessa, koska <code>$rootScope</code>-objektiin määritetyt kentät ovat näkyvissä koko sovelluksen näkyvyysalueessa, eli kaikkialla <code>ng-app</code>-direktiivin sisällä. Kuten huomaat käytin myös <code>userLoggedIn</code>-muuttujaa hyväkseni näkymässä, koska olisi hölmöä näyttää uloskirjautumispainike, jos käyttäjä ei ole  kirjautunut sisään.
</p>
<div class="tehtavat">
<h3>Elokuvakirjaston authentikaatio</h3>
<p>
  Toteuta seuraavaksi Elokuvakirjasto-sovellukseesi authentikaatio. Aloita toteuttamalla palvelu, jonka kautta käyttäjä voi luoda uuden käyttäjätilin sähköpostiosoitteella ja salasanalla (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-users-and-authentication-createusercredentials" target="_blank">$createUser</a></code>-funktio), kirjautua sisään käyttäjätilin tiedoilla (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-users-and-authentication-authwithpasswordcredentials-options" target="_blank">$authWithPassword</a></code>-funktio) ja kirjautua ulos (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-users-and-authentication-unauth" target="_blank">$unauth</a></code>-funktio). Lisää myös funktio, joka palauttaa tiedot kirjautuneesta käyttäjästä (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-users-and-authentication-getauth" target="_blank">$getAuth</a></code>-funktio). Muista injektoida palveluun <code>$firebaseAuth</code>-palvelu, joka tarjoaa authentikaatioon tarkoitetut funktiot. Lisää lisäksi Firebaseen sääntö, joka estää kirjoittamisen elokuvaresurssiin ilman kirjautumista. Elokuvaresurssin lukemisen voit sallia halutessasi kaikille käyttäjille. Muista myös aktivoida authentikaatio salasanalla sovelluksesi hallintasivulta kohdasta "Login & Auth".
</p>
<p>
Kun palvelu on toteutettu, toteuta kontrolleri, jonka kautta käyttäjä voi luoda uuden käyttäjätilin sähköpostiosoitteella ja salasanalla. Jos kirjautuminen epäonnistuu, näytä käyttäjälle näkymässä viesti "Väärä käyttäjätunnus tai salasana!". Jos kirjautuminen onnistuu, ohjaa käyttäjä elokuvat listaavalle sivulle <code>$location</code>-palvelun avulla.
</p>
<p>
Toteuta samaan kontrolleriin toiminto, jonka avulla käyttä voi luoda uuden käyttäjätilin sähköpostiosoitteella ja salasanalla. Jos käyttäjätili luodaan onnistuunesti, kirjaa käyttäjä sisään ja ohjaa hänet elokuvat listaavalle sivulle. Jos rekisteröityminen epäonnistuu, näytä käyttäjälle viesti "Tapahtui virhe! Yritä uudestaan". Lisää kontrollerille vielä reitti <code>#/login</code> ja toteuta näkymä, josta löytyy kirjautumis- ja rekisteröitymislomake. Lisää myös koko sovelluksen näkyvyysalueeseen funktio, jonka kautta käyttäjä voi kirjautua ulos käyttämällä toteuttamaasi palvelua ja muuttuja, joka palauttaa kirjautuneen käyttäjän tiedot (vinkki: suorita moduulissasi <code>run</code>-funktion avulla funktio, joka lisää <code>$rootScope</code>:en sopivan funktion ja muuttujan).
</p>
<p>
  Kun kontrolleri on valmis, viimeistellään authentikaatio vielä niin, ettei käyttäjä pääse elokuvan lisäys- ja muokkaussivulle ilman kirjautumista. Jos käyttäjä yrittää päästä sivuille ilman kirjautumista, ohjaa hänet polkuun <code>#/login</code>. Piilota lisäksi elokuvien listasta elokuvan poistamiseen tarkoitettu painike, jos käyttäjä ei ole kirjautunut sisään. Se onnistuu esimerkiksi tallentamalla tieto käyttäjän kirjautumisesta muuttujaan kontrollerin näkyvyysalueessa ja lisäämällä näkymään sopiva <code>ng-show</code>-direktiivi. Älä näytä myöskään kirjautumispainiketta, jos käyttäjä on kirjautunut sisään. Voit sijoittaa uloskirjautumispainikkeen haluamaasi paikkaan <code>index.html</code>-tiedostossa.
</p>
<p>
  Kuten muutkin Elokuvakirjasto-sovelluksen tehtävät, toteuta tämäkin tehtävä Heroku-sovellukseesi ja kun olet valmis, voit palauttaa tehtävän lisäämällä tehtäväpohjan <code>index.html</code>-tiedostoon linkin sovellukseesi herokussa.
</p>
</div>
  <h2>Twitter Bootstrap</h2>
  <p>
    <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> on Mark Otton and Jacob Thorntonin Twitterillä kehittämä front-end sovelluskehys, joka on saavuttanut todella suuren suosin viime vuosin aikana. Bootstrap tarjoaa laajan skaalan HTML- ja CSS-pohjaisia suunnittelupohjia selkeiden käyttöliittymien toteuttamiseen. Siinä on myös vahvasti esillä nk. "Responsive Design"-periaate, jonka perusteella jokaisen käyttöliittymän tulisi toimia laitteesta ja näytön koosta riippumatta. Puhumme responsiivisestä web-suunnittelusta lisää myöhemmin, käydään ensin läpi Boostrapin tärkeimpiä ominaisuuksia.
  </p>
  <h3>Käyttöliittymään kimalletta Bootstrapin avulla</h3>
  <p>
    Suunnitestaan sivulle <a href="http://getbootstrap.com/" target="_blank">http://getbootstrap.com</a>, jossa Bootstrap sovelluskehyksen kotisivut lymyävät. Seuraavassa tehtävässä aiomme hieman kohentaa Elokuvakirjaston ulkoasua käyttämällä siinä Bootstrapin komponentteja, joten on aika ottaa Bootstrap käyttöön. Aloitetaan lataamalla Bootstrapin lähdekoodit <a href="https://github.com/twbs/bootstrap/releases/download/v3.3.2/bootstrap-3.3.2-dist.zip">täältä</a>. Kun lähdekoodit on ladattu, pura zip-paketti ja siirrä se <code>Elokuvakirjasto</code>-kansion juuressa sijaitsevaan <code>web</code>-kansioon. Sen jälkeen meidän täytyy lisätä seuraavanlainen <code>link</code>-tagi <code>web/app</code>-kansiossa sijaitsevan <code>index.html</code>-tiedoston <code>head</code>-tagiin:
  </p>
<pre class="sh_html">
&lt;head&gt;
  &lt;!-- ... --&gt;
  &lt;link rel="stylesheet" type="text/css" href="bootstrap-3.3.2-dist/css/bootstrap.min.css"&gt;
  &lt;!-- ... --&gt;
&lt;/head&gt;
</pre>
<p>
  <code>link</code>-tagin <code>href</code>-attribuutissa on siis vain määritelty polku Bootstrapin <code>css</code>-tiedostoon. Jos lataamallasi kansiolla on eri nimi, muuta tarvittaessa tiedoston polkua. Bootstrap tarjoaa, myös komponentteja, jotka vaativat siihen liittyvät JavaScript-tiedostot ja jQueryn. Jos haluat käyttää niitä, lisää vielä <code>index.html</code>-tiedoston <code>body</code>-tagin loppuun seuraavat <code>script</code>-tagit:
</p>
<pre class="sh_html">
  &lt;!-- ... --&gt;
  &lt;!-- jQuery --&gt;
  &lt;script src="http://code.jquery.com/jquery-1.11.2.min.js"&gt;&lt;/script&gt;
  &lt;!-- Bootstrap --&gt;
  &lt;script src="bootstrap-3.3.2-dist/js/bootstrap.min.js"&gt;&lt;/script&gt;
&lt;/body&gt;
</pre>
<p>
  Avaa sen jälkeen tiedosto <code>index.html</code> selaimessa esimerkiksi NetBeansin kautta ja näet jo, että ulkoasussa on tapahtunut pieniä muutoksia. Tällä hetkellä pääasiassa fontti ja linkkien väri on muuttunut, mutta seuraavaksi teemme suurempia muutoksia.
</p>
  <div class="tehtavat">
    <h3>Kiillota kilpesi</h3>
    <p>
      Lisää Elokuvakirjasto-sovellukseesi Bootstrapin lähdekoodit, kuten yllä olevassa ohjeessa on tehty. Tutustu sen jälkeen Bootstrapin <a href="http://getbootstrap.com" target="_blank">dokumentaatioon</a> lukemalla sieltä ainakin seuraavat sivut:
      <ul>
        <li><a href="http://getbootstrap.com/css/#type" target="_blank">Typography</a></li>
        <li><a href="http://getbootstrap.com/css/#tables" target="_blank">Tables</a></li>
        <li><a href="http://getbootstrap.com/css/#forms" target="_blank">Forms</a></li>
        <li><a href="http://getbootstrap.com/css/#buttons" target="_blank">Buttons</a></li>
        <li><a href="http://getbootstrap.com/css/#navbar" target="_blank">Navbar</a></li>
      </ul>
    </p>
    <p>
      Kun sivut on luettu, ala ehostaa Elokuvarkijasto-sovelluksesi ulkoasua, niin että näkymät ovat lopulta tämän näköiset:
      <h4 class="ignore">Elokuvien lista</h4>
      <img src="img/kiillotakilpesi-1.png" style="width: 450px; border: 1px solid rgb(220,220,220); border-radius: 4px">
      <h4 class="ignore">Elokuvan lisäyssivu</h4>
      <img src="img/kiillotakilpesi-2.png" style="width: 450px; border: 1px solid rgb(220,220,220); border-radius: 4px">
      <h4 class="ignore">Elokuvan esittelysivu</h4>
      <img src="img/kiillotakilpesi-3.png" style="width: 450px; border: 1px solid rgb(220,220,220); border-radius: 4px">
      <h4 class="ignore">Elokuvan muokkaussivu</h4>
      <img src="img/kiillotakilpesi-4.png" style="width: 450px; border: 1px solid rgb(220,220,220); border-radius: 4px">
      <h4 class="ignore">Kirjautumis- ja rekisteröitymissivu</h4>
      <img src="img/kiillotakilpesi-5.png" style="width: 450px; border: 1px solid rgb(220,220,220); border-radius: 4px">
    </p>
  </div>
  <h2>Responsiivinen web-suunnittelu</h2>
  <p>
    Viime osiossa mainitsimme lyhyesti "Responsive Design"-periaatteen, jonka perusteella jokaisen käyttöliittymän tulisi toimia laitteesta ja näytön koosta riippumatta. Verkkosovelluksia käytetään yhä useammin pieninäyttöisillä sovelluksilla, jolloin on välttämätöntä, että sovelluksen käyttöliittymä osaa mukautua pienempään näyttöön.
  </p>
  <p>
    Esimerkikki huonosta responsiviisesta suunnittelusta on ikävä kyllä <a href="http://www.cs.helsinki.fi/home/" target="_blank">Tietojenkäsittelytieteen laitoksen kotisivu</a>. Jos kavennat selaimesi ikkunaa, ulkoasu ei sopeudu mitenkään pienenevään ikkunaan, jolloin pienillä näytöillä ulkoasu on aivan liian leveä.
  </p>
  <p>
    Esimerkki hyvästä responsiivisesta suunittelusta on taas <a href="https://www.heroku.com/home" target="_blank">Herokun kotisivu</a>. Tässä tapauksessa, jos kavennat selaimesi ikkunaa, huomaat että ulkoasu alkaa asettua erilailla. Kun ikkuna kapenee leveä navigaatio muuttuu painikkeeksi oikeaan yläkulmaan ja sisältö muuttuu rivittäisestä sarakkaiseksi tilan säästämiseksi.
  </p>
  <p>
    Responsiivisen käyttöliittymän toteuttaminen saattaa kuulostaa vaikealta, mutta tulemme pian huomaamaan, ettei se ole sitä. Etenkin kun käytössämme on Bootstrap.
  </p>
  <h3>Media-kyselyt</h3>
  <p>
    Työskentelimme kurssin alkuosassa aika paljon tyylien kanssa. Toteuttamamme käyttöliittymät eivät kuitenkaan hirveästi reagoineet näytön leveyden muuttumiseen. Otetaan hyvä esimerkkinä viikolla 1 toteutettu "PerusMOOC"-sivusto, jossa navigaatio on melko leveä kapeammille näytöille, kuten mobiililaitteiden näytöille. Lisäksi fonttien koot olivat melko suuret. Sivuston tyylitiedosto muistutti tätä:
  </p>
<pre class="sh_css">
body{
    background-color: rgb(233, 229, 217);
    font-size: 20px;
    font-family: Arial, sans-serif;
}

h1{
    color: rgb(73, 69, 69);
}

#navigation{
    list-style-type: none;
    margin: 0px;
    padding: 0px;
    overflow: hidden;
    background-color: rgb(73, 69, 69);
    border-radius: 10px;
    padding: 0px 40px;
    margin-bottom: 40px;
}

#navigation li{
    float: left;
}

#navigation li a{
    display: inline-block;
    padding: 15px 30px;
    font-size: 1.1em;
    color: rgb(233, 229, 217);
    text-decoration: none;
}

#navigation li a:hover{
    color: rgb(73, 69, 69);
    background-color: rgb(233, 229, 217);
}
</pre>
<p>
  Pienemmällä näytöllä voisi olla järkevämpää esittää linkit allekkain. Mutta miten voisimme määrittää tyylejä sen mukaan, kuinka leveä käyttäjän näyttö on?
</p>
<p>
  CSS:ssä on käytössä <a href="http://www.w3schools.com/cssref/css3_pr_mediaquery.asp" target="_blank">mediakyselyt</a>, joiden avulla voimme määrittää tyylejä erilaisille laitteille. Käytännössä tämä tarkoittaa sitä, että voimme muodostaa ehtolauseiden kaltaisia rakenteita, joissa voimme määrittää esimerkiksi, että kapeammilla kuin 500 pikselin kokoisilla näytöillä otsikoiden koko on <code>1.5em</code>. Yleensä suurin osa mediakyselyistä kohdistuu juuri käyttäjän näytön leveyteen, niitä voi kohdistaa myös mm. näytön resoluutioon.
</p>
<p>
  Mediakyselyt kirjoitetaan tyylitiedostoihin ympäröimällä tyylejä <code>@media</code>-lohkolla. Lohko määrittely alkaa usein <a href="http://www.w3.org/TR/2011/REC-CSS2-20110607/media.html" target="_blank">mediatyypin</a> määrittelemisellä, joka voi olla esimerkiksi "screen" (tietokoneiden, tablettien, puhelimien, ym. näytöt), "print" (tulostimet), tai "all" (kaikki mediatyypit). Yleensä mediatyyppiä ei kuitenkaan erikseen määritellä, jolloin mediakysely kohdistuu kaikkiin mediatyyppeihin. Mediatyyppiä seuraa luettelo mediakyselyyn kohtistuvia <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Media_queries#Media_features" target="_blank">ehtoja</a>, jotka erototellaan toisistaan and/or-operaattoreilla aivan kuten if-lauseissa. Otetaan tähän väliin muutama käytännön esimerkki:
</p>
<pre class="sh_css">
h1{
  font-size: 2em;
}

// Kun näytön leveys on korkeintaan 500 pikseliä, h1-elementtien fontin koko on 1.5em
@media screen and (max-width: 500px){
  h1{
    font-size: 1.5em;
  }
}

// Kun näytön leveys on vähintään 500 pikseliä, h1-elementtien taustaväri on vihreä
@media scree and (min-width: 500px){
  h1{
    background-color: green;
  }
}

// Kun näytön leveys on välillä 1000px-1500px, h1-elementtien fontin väri on punainen
@media screen and (min-width: 1000px) and (max-width: 1500px){
  h1{
    color: red;
  }
}
</pre>
<p>
  Yllä olevassa esimerkissä lisäsimme tyylitiedostoon kolme mediakyselyä. Ensimmäisessä kyselyssä kohdistamme kyselyn, joka muuttaa h1-elementtien fontin kooksi <code>1.5em</code>, kaikkiin laitteisiin, joiden mediatyyppi on "screen" (tietokoneiden, tablettien, puhelimien tai vastaava näyttö) ja joiden näytön leveys on korkeintaan 500 pikseliä. Toisessa mediakyselyssä taas kohdistimme kyselyn, joka muuttaa h1-elementtien taustavärin vihreäksi, kaikissa laittaissa, joiden mediatyyppi on "screen" ja joiden näytön leveys on vähintään 500 pikseliä. Lopuksi määritämme vielä mediakyselyn, joka kohdistuu laitteisiin, joiden näytön leveys on välillä 1000-1500 pikseliä.
</p>
<p>
  Tehdään vielä PerusMOOC-sivusta hieman responsiivisempi tekemällä media-kyselyllä muutoksia sivun tyyleihin, kun käyttäjän näytön koko on pienempi kuin 700 pikseliä. Sivulla on kapeilla näytöillä tällä hetkellä pari ongelmaa. Ensinäkin navigaation linkit eivät rivity kauniisti, vain siirtyvät yksi kerrallaan alemmas. Korjataan ongelma lisäämällä media-kyselyssä navigaation <code>li</code>-elementtien <code>display</code>-ominaisuudeksi <code>block</code>, jolloin ne vievät rivillä kaiken tilan ja asemmalla <code>float</code>-ominaisuuden arvoksi <code>initial</code>, jolloin ne eivät "kellu". Tehdään sama <code>li</code>-elementtien sisäisille <code>a</code>-elementeille ja vähennetään tyhjää tilaa navigaation reunoilla asettamalla navigaation <code>padding</code>-ominaisuuden arvoksi <code>0px</code>. Toinen ongelma on, että fontit ovat melko isoja kapeilla näytöillä, joten pienennetään niitä. Responsiivinen versio olisi siis tämä:
</p>
<pre class="sh_css">
body{
    background-color: rgb(233, 229, 217);
    font-size: 20px;
    font-family: Arial, sans-serif;
}

h1{
    color: rgb(73, 69, 69);
}

#navigation{
    list-style-type: none;
    margin: 0px;
    padding: 0px;
    overflow: hidden;
    background-color: rgb(73, 69, 69);
    border-radius: 10px;
    padding: 0px 40px;
    margin-bottom: 40px;
}

#navigation li{
    float: left;
}

#navigation li a{
    display: inline-block;
    padding: 15px 30px;
    font-size: 1.1em;
    color: rgb(233, 229, 217);
    text-decoration: none;
}

#navigation li a:hover{
    color: rgb(73, 69, 69);
    background-color: rgb(233, 229, 217);
}

@media screen and (max-width: 700px){
    h1{
        font-size: 1.4em;
    }

    #navigation{
        padding: 0px;
    }

    #navigation li{
        display: block;
        float: initial;
    }

    #navigation li a{
        display: block !important;
        font-size: 0.9em !important;
    }
}
</pre>
<p>
  Katso vielä havainnollistava <a href="http://jsfiddle.net/1v035jfj/1/" target="_blank">jsFiddle</a> (kavenna "Result"-ikkunaa, niin huomaat, kuinka media-kysely vaikuttaa tyyleihin).
</p>
  <h3>Bootstrapin grid-järjestelmä</h3>
  <p>
    Käyttämämme Bootstrap sisältää responsiivisten sivujen toteutusta varten käytettävän <a href="http://getbootstrap.com/css/#grid" target="_blank">grid-järjestelmän</a>. Sen avulla voimme jakaa sivumme nk. "gridiin", joka koostuu erikokoisista riveistä ja sarakkeista. Hienoa grid-järjestelmässä on se, että näytön koon pienentyessä grid mukautuu pienenevään tilaan rivittämällä sarakkeita, tekemällä gridistä korkean leveän sijaan. Saattaa kuulostaa monimutkaiselta, mutta grid-järjestelmän avulla responsiivisten sivujen toteuttaminen on lasten leikkiä.
  </p>
  <p>
    Oman ulkoasun muovaaminen gridiksi onnistuu jakamalla se riveihin, joiden sisällä on sarakkeita, joihin itse sisältö tulee. Jokainen rivi koostuu maksimissaan 12 sarakkeesta ja yksi sarake voi olla leveydeltään useamman sarakkeen pituinen. Jos riville yrittää laittaa yli 12 saraketta, siirtyvät yli menneet sarakkeet automaattisesti uudelle riville. Rivit tulee sijoittaa elementin sisään, jossa on joko luokka <code>container</code> (kiinteä leveys), tai <code>container-fluid</code> (koko vanhemman leveys). Riviin tulee lisätä luokka <code>row</code> ja sen sisäisiin sarakkeisiin luokka <code>col-LEVEYS-*</code>. Sarakkeen luokan <code>LEVEYS</code>-muuttuja kertoo, kuinka leveä rivin yksi sarake on. Sen arvo voi olla joko <code>xs</code>, <code>sm</code>, <code>md</code> ja <code>lg</code>, joista <code>md</code> on useimmin käytetty. Tarkemmat kuvaukset sarakkeisiin liittyvistä vaihtoehdoista löytyy <a href="http://getbootstrap.com/css/#grid-options" target="_blank">tästä</a> taulukosta. Sarakkeen perässä oleva <code>*</code>-muuttuja kertoo, kuinka monen sarakkeen levyinen kyseinen sarake on. Sen arvo on välillä 1-12. Otetaan tähän väliin muutama esimerkki.
  </p>
  <h4>Esimerkki: Kolmijakoinen ulkoasu</h4>
  <p>
    Toteutetaan grid ehkä yleisimmästä ulkoasumallista, kolmijakoisesta ulkoasusta. Jaetaan siis ulkoasu kolmeen osaan: keskelle yksi leveä sarake ja sen vieressä vasemalla ja oikealla kapeammat sarakkeet:
  </p>
<pre class="sh_html">
&lt;div class="container-fluid"&gt;
  &lt;div class="row"&gt;
    &lt;div class="col-md-3"&gt;
      Vasemmanpuoleinen sisältö
    &lt;/div&gt;
    &lt;div class="col-md-6"&gt;
      Keskimmäinen sisältö
    &lt;/div&gt;
    &lt;div class="col-md-3"&gt;
      Oikeanpuoleinen sisältö
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>
  Nyt keskimmäinen sarake kattaa koko rivistä kuuden sarakkeen tilan ja sen viereiset sarakkeet molemmat kolmen sarakkeen tilan. Yhteensä rivin koko on siis <code>3+6+3=12</code> saraketta, kuten kuuluukin. Kapealla näytöllä sarakkeet siirtyvät allekkain, niin että vasemmanpuolein sarake on ylimmäisenä ja sen alapuolella on keskimmäinen ja oikeanpuolinen sarake. Tässä vielä <a href="http://jsfiddle.net/DTcHh/4612/" target="_blank">jsFiddle</a> esimerkistä (muuta "Result"-laatikon kokoa, niin näet, kuinka grid muuttaa muotoaan).
</p>
<h4>Esimerkki: rivi sarakkeen sisällä</h4>
<p>
  Rivejä pystyy myös laittamaan sarakkeiden sisään, jolloin ulkoasuun voi luoda monimutkaisempia rakenteita. Tässä esimerkki, jossa edellisen esimerkin keskimmäiseen sarakkeeseen lisätään rivi, jossa on kolme saraketta:
</p>
<pre class="sh_html">
&lt;div class="container-fluid"&gt;
  &lt;div class="row"&gt;
    &lt;div class="col-md-3"&gt;
      Vasemmanpuoleinen sisältö
    &lt;/div&gt;
    &lt;div class="col-md-6"&gt;
      Keskimmäinen sisältö
      &lt;div class="row"&gt;
        &lt;div class="col-md-4"&gt;
          Keskimmäisen sisällön alasisältö 1.
        &lt;/div&gt;
        &lt;div class="col-md-4"&gt;
          Keskimmäisen sisällön alasisältö 2.
        &lt;/div&gt;
        &lt;div class="col-md-4"&gt;
          Keskimmäisen sisällön alasisältö 3.
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="col-md-3"&gt;
      Oikeanpuoleinen sisältö
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>
  Nyt keskimmäiseen sarakkeeseen on lisätty rivi, joka jaetaan kolmeen sarakkeeseen. Tässä lopputulos <a href="http://jsfiddle.net/DTcHh/4613/" target="_blank">jsFidlessä</a> (muuta "Result"-laatikon kokoa, niin näet, kuinka grid muuttaa muotoaan).
</p>
<h4>Esimerkki: erillään olevat sarakkeet</h4>
<p>
  Sarakkeisiin saa myös lisättyä poikkeamaa, jonka avulla sitä saa siirrettyä rivillä tietyn sarakemäärän verran oikealla. Se onnistuu käyttämällä sarakkeessa luokkaa <code>col-md-offset-*</code>, jossa <code>*</code> kertoo, kuinka monta saraketta sarake siirtyy alkuperäisestä paikastaan. Tässä esimerkki, jossa sarakkeita on erillään kolmella rivillä:
</p>
<pre class="sh_html">
&lt;div class="row"&gt;
  &lt;div class="col-md-4">Tämä sarake ei siirry&lt;/div&gt;
  &lt;div class="col-md-4 col-md-offset-4">Tämä sarake siirtyy 4 saraketta&lt;/div&gt;
&lt;/div&gt;
&lt;div class="row"&gt;
  &lt;div class="col-md-3 col-md-offset-3">Tämä sarake siirtyy 3 saraketta&lt;/div&gt;
  &lt;div class="col-md-3 col-md-offset-3">Tämä sarake siirtyy 3 saraketta&lt;/div&gt;
&lt;/div&gt;
&lt;div class="row"&gt;
  &lt;div class="col-md-6 col-md-offset-3">Tämä sarake siirtyy 3 saraketta&lt;/div&gt;
&lt;/div&gt;
</pre>
<p>
  Ensimmäisellä rivillä ensimmäinen sarake ei siirry, mutta seuraavaan sarakkeeseen on lisätty luokka <code>col-md-offset-4</code>, joten se siirtyy alkuperäisestä paikastaan neljä saraketta oikealla. Nyt sarakkeiden väliin jaa neljän sarakkeen leveyinen tila. Toisella rivillä molemmat sarakkeet siirtyvät kolmen sarakkeen verran oikealla, koska molempiin on lisätty luokka <code>col-md-offset-3</code>. Samoin käyttäytyy kolmannen rivin ainoa sarake. Tässä vielä <a href="http://jsfiddle.net/DTcHh/4614/" target="_blank">jsFiddle</a>, joka havainnollistaa yllä olevaa esimerkkiä (muuta "Result"-laatikon kokoa, niin näet, kuinka grid muuttaa muotoaan). Lisää Bootstrapin grid-järjestelmästä voit lukea halutessasi <a href="http://getbootstrap.com/css/#grid" target="_blank">täältä</a>.
</p>
<div class="tehtavat">
    <h3>Ulkoasu responsiiviseksi</h3>
    <p>
      Tehtäväpohjan <code>index.html</code>-tiedostosta löytyy sivupohja joka ei ole lainkaan responsiivinen. Tämän tehtävän aikana me aiomme tosin muuttaa asian täysin. Aloitetaan lisäämällä tyyleihin media-kyselyita, jonka avulla voimme mukauttaa ulkoasua kapenevaan näyttöön. Toteuta <code>css/site.css</code>-tiedostoon media-kyselyt ja tyyleihin kohdistuvat muutokset, jotka tekevät seuraavat asiat:
      <ul>
        <li>Muuta id:llä <code>main-container</code> varustettua <code>section</code>-elementtiä niin, että sen leveys ei ole kiinteät 1300 pikseliä, vaan sen leveys on maksimissaan 1300 pikseliä ja kapeammilla näytöillä se on koko näytön leveyinen (vinkki: et välttämättä tarvitse media-kyselyä, jos käytät <code><a href="http://www.w3schools.com/cssref/pr_dim_max-width.asp" target="_blank">max-width</a></code>-ominaisuutta)</li>
        <li>
          Kun näytön leveys on alle 1000 pikseliä, piilota hakulomake navigaatiopalkista (vinkki: <code><a href="http://www.w3schools.com/cssref/pr_class_display.asp" target="_blank">display</a></code>-ominaisuus). Hakulomake sijaitsee <code>section</code>-elementissä, jonka id on <code>search-form</code>.
        </li>
        <li>
          Kun näytön leveys on alle 800 pikseliä, muuta lilan laatikon fontin kooksi <code>1em</code>. Lila laatikko muodostuu <code>section</code>-elementistä, jonka id on <code>jumbo-container</code>
        </li>
        <li>
          Kun näytön leveys on alle 800 pikseliä, piilota navigaatiopalkki, joka muodostuu <code>ul</code>-elementistä, jonka id on <code>navigation</code> ja näytä pudotusvalikko, joka muodostuu <code>div</code>-elementistä, jonka id on <code>dropdown-navigation</code> (vinkki: <code><a href="http://www.w3schools.com/cssref/pr_class_display.asp" target="_blank">display</a></code>-ominaisuus)
        </li>
      </ul>
    </p>
    <p>
      <strong>Muista sijoittaa media-kyselyt tyylitiedoston loppuun tai käytä ominaisuuksia määrittelemisessä <code>!important</code>-päätettä, muuten ne peittyvät muissa valitsimissa määriteltyjen ominaisuuksien alle.</strong>
    </p>
    <p>
      Tämän jälkeen ulkoasu on sisältöä vaille responsiivinen. Laitetaan seuraavaksi sisältö gridiin käyttämällä Bootstrapin tarjoamaa grid-järjestelmää. Toteuta grid seuraavanlaiseksi:
      <ul>
        <li>
          Vasemmanpuoleinen ja oikeanpuoleinen sisältö muodostavat rivin, jossa on kaksi saraketta. Vasemmanpuoleisen sarakkeen leveys on kahdeksan saraketta ja oikeanpuoleisen sarakkeen leveys on neljä saraketta.
        </li>
        <li>
          Vasemmanpuoleisen sarakkeen sisällä on rivi, jossa on kolme saraketta. Kaikkien sarakkeiden leveys on kolme saraketta.
        </li>
      </ul>
    </p>
    <p>
      Kun sisältö on gridissä, on ulkoasu täysin responsiivinen. Totea se vielä itse kaventamalla selaimesi ikkunaa. Mahtavaa!
    </p>
  </div>
  <h2>Selkeyttä ja rakennetta tyylitiedostoihin: Less</h2>
  <p>
    CSS-kielellä saa aikaan hienoja ulkoasuja, mutta siinä on huomattavia puutteita, jotka ilmenevät etenkin kuin tyylien määrä kasvaa. Ongelmaan on kehitetty viime vuosina monia laajennuksia, jotka lisäävät CSS-kieleen lukuisia toimintoja, kuten muuttujia, funktiota ja sisäkkäisiä valitsimia. Kaikki laajennukset toimivat käynnössä samalla tavalla, niillä on oma syntaksinsa, mutta lopulta kaikki niistä käännetään omalla kääntäjällään CSS-kielelle. Suosituinpia CSS-kielen laajennuksia ovat <a href="http://lesscss.org/" target="_blank">Less</a> ja <a href="http://sass-lang.com/" target="_blank">Sass</a>, joiden syntaksi muistuttaa hyvin paljon toisiaan ja tarjoat käytännössä samat toiminnot. Keskitymme kuitenkin pelkästään Lessiin, jolla ollut viime vuosina paljon nostetta.
  </p>
  <h3>Lessin ominaisuudet</h3>
  <p>
    Kuten jo mainittiin, Less lisää CSS-kieleen useita ominaisuuksia, jotka tekevät tyylitiedoista selkeämpiä ja ylläpidettävämpiä. Tutustutaan seuraavaksi sen tärkeimpiin ominaisuuksiin.
  </p>
  <h4>Muuttujat</h4>
  <p>
    Lessin ehkä paras ominaisuus on muuttujien käyttö. Muuttujiin voi tallentaa oikeastaan mitä vain, värejä, taustakuvien polkuja, fontin kokoja ja jopa valitsimia. Muuttujat määritellään <code>@</code>-merkillä seuraavasti:
  </p>
<pre class="sh_css">
@grey: rgb(100,100,100);
@fontSize: 1.1em;
@imagesPath: "../images";
@backgroundImage: "@{imagesPath}/background.png";
@selector: box-container;

.@{selector}{
  color: @grey;
  font-size: @fontinKoko;
  background-image:url(@imagesPath);
}
</pre>
<p>
  Määritimme siis muuttujat <code>@grey</code>, <code>@fontSize</code>, <code>@imagesPath</code>, <code>@backgroundImage</code> ja <code>@selector</code>. Kuten huomaat, muuttujan pystyy upottamaan merkkijonoon käyttämällä <code>"@{muuttujanNimi}"</code>-syntaksia. Lisäksi samankaltaisesti muuttujan arvoa voi käyttää valitsimena, kuten esimerkissä määrittelin muuttujan <code>@selector</code> avulla valitsimen <code>.box-container</code>. Kun yllä oleva tyylitiedosto käännetään CSS-kielellä on lopputulos tämä:
</p>
<pre class="sh_css">
.box-container{
  color: rgb(100,100,100);
  font-size: 1.1em;
  background-image:url("../images/background.png");
}
</pre>
<p>
  Saattaa vaikuttaa aluksi siltä, että muuttujien määrittäminen vain monimutkaistaa tyylien määrittelyä, mutta niiden uudelleenkäytettävyydestä on valtava hyöty. Voimme myös lisätä muuttujaan taulukon, josta saamme tietyssä indeksissä olevan muuttujan arvon käyttämällä <code><a href="http://lesscss.org/functions/#list-functions-extract" target="_blank">extract</a></code>-funktiota tähän tapaan:
</p>
<pre class="sh_css">
@font: bold 1.1em sans-serif;

h1{
  font-family: extract(@font, 3);
}
</pre>
<p>
  Määrittelimme siis taulukon <code>@font</code>, jossa on kolme alkiota: <code>bold</code>, <code>1.1em</code> ja <code>sans-serif</code>. Nyt <code>h1</code>-elementin <code>font-family</code>-ominaisuuden arvoksi tulee <code>sans-serif</code>. Huomaa, että taulukon ensimmäisen alkion indeksi ei ole nolla, vaan yksi. Lisäksi taulukon alkioita ei eroteta pilkulla, kuten normaalisti, vaan välilyönillä. Yllä oleva tyylitiedosto kääntyy CSS-kielelle seuraavasti:
</p>
<pre class="sh_css">
h1{
  font-family: sans-serif;
}
</pre>
<p>
  Eli <code>h1</code>-elementtien fontiksi tulee <code>@font</code>-taulukon kolmas alkio, eli <code>sans-serif</code>.
</p>
<p>
  Kuten esimerkiksi JavaScriptissä, myös Lessissä muuttujilla on oma näkyvyysalue, joita voi muodostaa loogisesti valitsimien sisään:
</p>
<pre class="sh_css">
// määritellään muuttuja @color globaaliin näkyvyysalueeseen
@color: red;

#selector{
  // määritellään muuttuja @color valitsimen näkyvyysalueeseen
  @color: blue;
  color: @color;
}
</pre>
<p>
  Määritämme siis valitsimen sisäisessä näkyvyysalueessa muuttujan <code>@color</code>, jolloin globaalissa näkyvyysalueessa määritelty muuttuja <code>@color</code> peittyy. CSS-kielelle käännetty tyylitiedosto näyttää siis tältä:
</p>
<pre class="sh_css">
#selector{
  color: blue;
}
</pre>
<p>
  Lopuksi on muuttujista vielä hyvä tietää se, ettei niitä tarvitse Lessissä määritellä ennen kuin niitä voi käyttää. Tätä kutsutaan muuttujien "laiskaksi lataamiseksi" (lazy loading):
</p>
<pre class="sh_css">
#selector{
  color: @color;
}
// määritellään muuttuja vasta sen käytön jälkeen
@color: red;
</pre>
<p>
  Yllä oleva tyylitiedosto ei siis aiheuta ongelmia Lessin kääntäjälle, vaan se kääntyy CSS-kielelle, kuten pitääkin:
</p>
<pre class="sh_css">
#selector{
  color: red;
}
</pre>
  <p>
    Ei sis ole väliä määritelläänkö muuttuja <code>@color</code> ennen vain jälkeen sen käyttöä. Voit lukea halutessasi lisää muuttujista <a href="http://lesscss.org/features/#variables-feature" target="_blank">täältä</a>.
  </p>
  <h4>Miksaaminen</h4>
  <p>Miksaaminen (mixin) tarkoittaa toisessa valitsimessa määriteltyjen ominaisuuksien liittämistä toiseen valitsemeen. Se on kätevää, jos haluamme laajentaa valitsimessa toisen valitsimen ominaisuuksia. Jos määrittelemme esimerkiksi luokan <code>button</code> ominaisuudet ulkoasun painikkeille, jota voimme laajentaa eri värisiä painikkeita sen kautta seuraavasti:</p>
<pre class="sh_css">
// tavallisen painikkeen ominaisuudet
.button{
  padding: 10px 15px;
  border: 1px solid black;
  border-radius: 3px;
  color: white;
}

// laajennetaan tavallista painiketta lisäämällä musta taustaväri
.button-black{
  // liitetään valitsimeen tavallisen painikkeen ominaisuudet
  .button;
  background-color: black;
}

.button-blue{
  .button;
  background-color: blue;
}
</pre>
<p>
  Määrittelimme siis kaikkia painikkeita koskevat ominaisuudet valitsimessa <code>.button</code>. Sen jälkeen laajensimme sen ominaisuuksia valitsimessa <code>.button-black</code>, joka lisää tavalliseen painikkeeseen mustan taustavärin ja valitsimessa <code>.button-blue</code>, joka lisää siihen sinisen taustavärin lisäämällä molempiin valitsimen <code>.button</code>. Kun tyylitiedosto käännetään CSS-kielelle on lopputulos tämä:
</p>
<pre class="sh_css">
.button{
  padding: 10px 15px;
  border: 1px solid black;
  border-radius: 3px;
  color: white;
}

.button-black{
  padding: 10px 15px;
  border: 1px solid black;
  border-radius: 3px;
  color: white;
  background-color: black;
}

.button-blue{
  padding: 10px 15px;
  border: 1px solid black;
  border-radius: 3px;
  color: white;
  background-color: blue;
}
</pre>
<p>
  Kuten huomaat, säästyimme todella suurelta määrältä toistoa käyttämällä miksaamista. Valitsimen ominaisuuksia voi laajentaa vaikka kuinka monen valitsimen ominaisuuksilla. Voit halutessasi lukea lisää miksaamisesta <a href="http://lesscss.org/features/#mixins-feature" target="_blank">täältä</a>.
</p>
  <h4>Sisäkkäiset valitsimet</h4>
  <p>
    CSS-kielessä ei itsessään ole mahdollista määrittää valitsimia toisten sisään, minkä vuoksi tyylitiedostoihin syntyy hyvin nopeasti tämän kaltaisia valitsinhirviöitä:
  </p>
<pre class="sh_css">
#main-container{
  padding: 20px;
  background-color: white;
  border: 1px solid black;
  border-radius: 10px;
}

#main-container nav{
  background-color: grey;
}

#main-container nav ul{
  list-style-type: none;
  padding: 0px;
  margin: 0px;
}

#main-container nav ul li{
  float: left;
}

#main-container nav ul li a{
  display: inline-block;
  padding: 10px 15px;
}

#main-container nav ul li a:hover{
  background-color: black;
  color: white;
}
</pre>
<p>
  Tämä on melko yleinen näky tyylitiedostoissa. Ongelmana on, että valitsimissa on hirveästi toistoa ja lopulta niistä tulee niin pitkä, ettei kukaan enää tiedä mihin ne liittyvät. Lessissä hierarkiset valitsimet pystyy määrittelemään sisäkkäin, joka on huomattavasti selkeämpää, eikä siinä synny toistoa. Tässä edellisen esimerkki Lessin sisäkkäisillä valitsimilla:
</p>
<pre class="sh_css">
#main-container{
  padding: 20px;
  background-color: white;
  border: 1px solid black;
  border-radius: 10px;

  nav{
    background-color: grey;

    ul{
      list-style-type: none;
      padding: 0px;
      margin: 0px;

      li{
        float: left;

        a{
          display: inline-block;
          padding: 10px 15px;

          &:hover{
            background-color: black;
            color: white;
          }
        }
      }
    }
  }
}
</pre>
<p>
  Valitsimet eivät ole enää peräkkäin, vaan sisäkkäin, jolloin niiden välinen hierarkia näkyy huomattavasti selvemmin. Valitsimen pseudoluokkiin, kuten <code>:hover</code> ja <code>:focus</code> pystyy viittamaan <code>&</code>-syntaksilla.
</p>
  <h4>Funktiot</h4>
<p>
  Lessissä pystyy määrittelemään yksinkertaisia funktiota, joita voi kutsua eri parametreilla. Funktiot ovat yksi Lessin parhaista ominaisuuksista, koska niiden avulla pystyy luomaan todella paljon uudelleenkäytettäviä tyylejä. Esimerkiksi varjon lisäämiseksi elementtiin täytyy kutsua kolmea eri selaimen ominaisuutta seuraavasti:
</p>
<pre class="sh_css">
.container-with-shadow{
  -webkit-box-shadow: 0px 0px 1px black;
     -moz-box-shadow: 0px 0px 1px black;
          box-shadow: 0px 0px 1px black;
}
</pre>
<p>
  Tämä on todella työlästä, etenkin kun varjon haluaa liittää moneen elementtiin hieman eri arvoilla. Varjon lisäämisestä kannattaakin tehdä funktio, jota kutsutaan eri parametreilla:
</p>
<pre class="sh_css">
.box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) {
  -webkit-box-shadow: @arguments;
     -moz-box-shadow: @arguments;
          box-shadow: @arguments;
}
</pre>
<p>
  Funktion voi määritellä millä tahansa valitsimella, joka ottaa parametreja sulkujen sisään. Parametreilla voi määrittää oletusarvot ja niitä voi käyttää funktion sisältä joko yksittäin, tai kaikkia kerrallaan käyttämällä <code>@arguments</code>-muuttujaa, jotka sisältävät kaikki funktion parametrit. Jos funktiokutsussa ei määritellä kaikkia parametreja, käytetään niiden tilalla siinä määriteltyjä oletusarvoja. Tässä esimerkki <code>.box-shadow</code>-funktion käytöstä:
</p>
<pre class="sh_css">
.container-with-shadow{
  .box-shadow(0px, 0px, 1px);
}

.container-with-red-shadow{
  .box-shadow(0px, 0px, 1px, red);
}
</pre>
<p>
  Kutsuimme määrittämäämme <code>.box-shadow</code>-funktiota siis kahdesti hieman eri parametreilla. Ensimmäisessä kutsussa määrittelimme vain kolme ensimmäistä parametria, jolloin varjon väriksi asetetaan funktiossa määritelty oletusarvo <code>#000</code> (musta). Toisessa kutsussa taas määrittelimme kaikki parametrit. Funktioissa pystyy myös määrittelemään laskutoimituksia ja lisäämään kutsuttavan valitsimen näkyvyysalueeseen uusia muuttujia, joita voi ajatella paluuarvoina:
</p>
<pre class="sh_css">
.average(@x, @y) {
  @average: ((@x + @y) / 2);
}

.box{
  .average(16px, 50px);
  padding: @average;
}
</pre>
<p>
  Kun tämä käännetetään CSS-kielelle saadaan seuraava lopputulos:
</p>
<pre class="sh_css">
.box{
  padding: 33px;
}
</pre>
<p>
  Todella kätevää! Lessissä on määritelty läjäpäin valmiita funktiota, joiden käyttö selkeyttää tyylitiedostoja ja säästää rutkasti aikaa. Tärkeimpiä funktioita ovat matemaattiset ja värien manipulointiin liittyvät funktiot. Tässä esimerkki matemaattisista funktioista:
</p>
<pre class="sh_css">
// ceil-funktio pyöristää desimaaliluvun ylöspäin
ceil(2.2); // 3
// floor-funktio pyöristää desimaaliluvun alaspäin
floor(2.8); // 2
// round-funktio pyöristää desimaaliluvun
round(2.5); // 3
// sqrt-funktio laskee arvon juuren
sqrt(25px); // 5px
// min-funktio palauttaa arvoista pienimmän
min(2px, 10px, 16px, 102px); // 2px
// max-funktio palauttaa arvoista suurimman
min(2px, 10px, 16px, 102px); // 102px
</pre>
<p>
  Lisää matemaattisia funktioita löytyy <a href="http://lesscss.org/functions/#math-functions" target="_blank">täältä</a>. Lisäksi käytössä on suuri joukko värien manipulointiin käytettäviä funktioita. Niiden parametreina voi käyttää joko <code>rgb</code>-, heksadesimaali- tai <code>rgba</code>-arvoja (red, green, blue, alpha. Väri, jolla on läpinäkyvyysarvo välillä 0-1). Tässä hieman esimerkkejä:
</p>
<pre class="sh_css">
// lighten-funktio vaalentaa väriä annetun prosenttimäärän verran
lighten(red, 10%); // #ff3333
// darken-funktio tummentaa väriä annetun prosenttimäärän verran
darken(red, 10%); // #cc0000
// fadein-funktio vähentää värin läpinäkyvyyttä annetun prosenttimäärän verran
fadein(rgba(255,0,0,0.5), 20%); // rgba(255, 0, 0, 0.7)
// fadeout-funktio lisää värin läpinäkyvyyttä annetun prosenttimäärän
fadeout(rgba(255,0,0,0.5), 20%); // rgba(255, 0, 0, 0.3)
</pre>
<p>
  Lisää värien manipulointiin liittyviä funktioita löydät <a href="http://lesscss.org/functions/#color-operations" target="_blank">täältä</a>. Lessistä löytyy myös monia muita valmiita funktioita, joista kaikki löytyy <a href="http://lesscss.org/functions/#functions-overview" target="_blank">täältä</a>.
</p>
<h3>Less-tiedostojen kääntäminen NetBeansissa</h3>
<p>
  Avaa NetBeansissa tämän viikon tehtävä <code>LessIsMore</code>, klikkaa hiiren oikeaa painiketta sen nimen päällä ja valitse "Npm install", joka asentaa Less-kääntäjän. Jos käytät laitoksen konetta suorita terminaalissa projektin juuressa komento <code>npm install</code>. Kun kääntäjä on asennettu paina taas hiiren oikeaa painiketta projektin nimen päällä ja valitse "Properties". Valitse avautuneen ikkunan vasemmasta valikosta "CSS Preprocessors" ja sieltä "Less". Valitse checkboxi "Compile Less Files on Save" ja paina "Configure Executables"-painiketta. Klikkaa avautuneesta ikkunasta "Less path"-tekstikentän vierestä "Browse..."-painiketta ja valitse projektin juuresta tiedosto <code>node_modules/less/bin/lessc</code>. Paina sen jälkeen "Ok"-painiketta. Less-tiedostot käännetään nyt tallenuksen yhteydessä.
</p>
  <div class="tehtavat">
    <h3>Less is more</h3>
    <p>
      Tehtäväpohjan kansiossa <code>less</code> on tyylitiedosto <code>site.less</code>, joka kaipaa kipeästi refaktorointia. Tyylitiedoston ilmeisiä ongelmia ovat pitkät valitsimet ja toistuvuus, joihin aiomme seuraavaksi puuttua. Refaktoroi tiedosto <code>site.less</code>-tiedosto seuraavasti:
      <uL>
        <li>Toteuta kaikki valitsimet sisäkkäisinä niin, ettei <code>site.less</code>-tiedosta löydy yhtään monen peräkkäisen valitsimen ryhmää (lue tarvittaessa <a href="http://lesscss.org/features/#features-overview-feature-nested-rules" target="_blank">sisäkkäisistä valitsimista</a>)</li>
        <li>Määrittele väri <code>#5BB12F</code> muuttujassa <code>@green</code>, väri <code>#008BBA</code> muuttujassa <code>@blue</code> ja väri <code>#DC403B</code> muuttujassa <code>@red</code>. Korvaa sen jälkeen värien esiintyjät muuttujilla niin, ettei tyylitiedostossa enää löydy värien heksadesimaali esityksiä</li>
        <li>Toteuta funktio <code>.btn(@color)</code>, joka määrittää painikkeen annetulla värillä. Käytä funktion pohjana valitsimissa <code>.btn-blue</code>, <code>.btn-green</code> ja <code>.btn-red</code> toistuvia ominaisuuksia ja aseta sen taustaväri parametrin <code>@color</code>-mukaan. Lisää funktioon <code><a href="http://www.w3schools.com/cssref/sel_hover.asp" target="_blank">:hover</a></code>-pseudovalitsin, jossa painikkeen taustaväri muuttuu 20% alkuperäistä taustaväriä (parametrin <code>@color</code> arvoa) tummemmaksi (vinkki: <code><a href="http://lesscss.org/functions/#color-operations-darken" target="_blank">darken</a></code>-funktio). Käytä toutettamaasi funktiota valitsimissa <code>.btn-red</code>, <code>.btn-blue</code> ja <code>.btn-green</code>, joissa kutsut <code>.btn</code>-funktiota edellisessä kohdassa määrittämilläsi muuttujien <code>@red</code>, <code>@blue</code> ja <code>@green</code> arvoilla</li>
        <li>
          <p>
            Toteuta funktio <code>.gradient(@start, @end)</code>, joka lisää elementtiin <a href="http://www.w3schools.com/css/css3_gradients.asp" target="_blank">gradientin</a>-taustan. Gradientti tausta määritellään eri selainten ominaisuuksilla seuraavasti:
          </p>
<pre class="sh_css">
background: -webkit-linear-gradient(red, blue); /* Safarille */
background: -o-linear-gradient(red, blue); /* Operalle */
background: -moz-linear-gradient(red, blue); /* Firefoxille */
background: linear-gradient(red, blue); /* Standardi */
</pre>
<p>
  Tämä esimerkki luo gradientin, joka alkaa sinisenä ja päättyy punaiseen. Käytä omassa funktiossasi alkuvärinä parametrin <code>@start</code>-arvoa ja loppuvärinä parametrin <code>@end</code> arvoa. Kun funktio on toteutettu, kutsu sitä <code>.btn</code>-funktiossa niin, että tausvärin asettamisen sijaan painikkeeseen liitetään gradientti-tausta, joka alkaa <code>@color</code>-parametrina annetusta väristä ja päättyy siitä 15% vaaleampaan väriin (vinkki: <code><a href="http://lesscss.org/functions/#color-operations-lighten" target="_blank">lighten</a></code>). Vaihda myös <code>:hover</code>-pseudovalitsinta niin, että se käyttää <code>.gradient</code>-funktiota <code>@color</code>-parametria 20% tummemmalle värillä (vinkki: alkuväri on <code>darken(@color, 20%)</code> ja loppuväri 15% vaaleampi, eli <code>darken(@color, 5%)</code>).
</p>
        </li>
        <li>
          <p>
            Määrittele taulukko <code>xs, sm, md, lg, xl</code> muuttujaan <code>@sizes</code> ja poista tiedostosta valitsimet <code>.btn-xs</code>, <code>.btn-sm</code>, <code>.btn-md</code>, <code>btn-lg</code> ja <code>.btn-xl</code>. Tutustu sen jälkeen <a href="http://lesscss.org/features/#loops-feature" target="_blank">toistorakenteisiin</a> ja toteuta funktio <code>.btn-sizes(@counter: 1, @fontSize: 0.6em)</code>, joka generoi valitsimet eri kokoisille painikkeille niin, että <code>.btn-xs</code>-painikkeen fontin koko on <code>0.6em</code> ja fontin koko kasvaa aina <code>0.2em</code> painikkeen kasvaessa, kunnes <code>.btn-xl</code>-painikkeen fontin koko on <code>1.4em</code>. Käytä funktion <code>@counter</code>-parametria pitämään kirjaa siitä, kuinka mones kierros rekursiossa on käynnissä ja lopeta rekursio, kun <code>@counter</code>-parametrin arvo saavuttaa arvon <code>length(@sizes)</code>, eli taulukon <code>@sizes</code> pituuden. Kasvata rekursiossa <code>@fontSize</code>-parametrin arvoa aina <code>0.2em</code>:llä. Muista, että saat alkion taulukon indeksissä käyttämällä <code><a href="http://lesscss.org/functions/#list-functions-extract">extract</a></code>-funktiota, mistä on hyötyä generoidessa valitsimien nimiä. Valmiin funktion kutsuminen generoi seuraavat tiedostoon <code>css/site.css</code> seuraavat valitsimet:
<pre class="sh_css">
.btn-xs{
  font-size: 0.6em;
}
.btn-sm{
  font-size: 0.8em;
}
.btn-md{
  font-size: 1em;
}
.btn-lg{
  font-size: 1.2em;
}
.btn-xl{
  font-size: 1.4em;
}
</pre>
        </li>
      </ul>
    </p>
  </div>
</section>


<!--
<h1>Päivitysraja</h1>

<div>
<img src="img/gandalf___you_shall_not_pass______by_killmeromantic.jpg"/>
</div>
<a href="http://killmeromantic.deviantart.com/art/Gandalf-quot-YOU-SHALL-NOT-PASS-quot-286365167" target="_blank">source</a>
-->

<!--
<div>
  <h1 style="text-align: center" id="epic-heading" class="ignore">$$$ EXTRA CREDIT!!! $$$</h1>
  <p style="text-align: center">Tämän viikon tehtävillä voit korvata edellisillä viikoilla tekemättömiä tehtäviä</p>
</div>

<script>
  $(document).ready(function(){
    setInterval(function(){
      var r = Math.round(Math.random() * 255);
      var g = Math.round(Math.random() * 255);
      var b = Math.round(Math.random() * 255);
      $('#epic-heading').css('color', 'rgb(' + r + ',' + g + ',' + b + ')');
    }, 200);
  });
</script>
-->

<section class="week">
  <header>
    <a name="viikko7"></a>
    <h1 data-week-id="7">Viikko 7</h1>
  </header>
  <p>
    Olemme tähän mennessä tehneet selainpuolen sovelluksissamme AJAX-kyselyitä moniin lähteisiin ottammatta kovinkaan paljon kantaa siihen, mitä palvelimella kulissien takana tapahtuu.<!-- Mitä esimerkiksi viikon kolme JQuerySpoilaajanBackend tehtävässä spoilauksen lisäämisen yhteydessä palvelimen puolella tapahtuu.-->
  </p>
  <p>
    Viimeisen viikon kunniaksi otamme mukaan hieman palvelinpuolen ohjelmointia, mutta pysymme silti kurssin aikana tutuksi tulleessa ohjelmointikielessä - JavaScriptissä. Lisää palvelinohjelmointikokemusta saat kursseilta <em>Web-palvelinohjelmointi: Java</em> sekä <em>Web-palvelinohjelmointi: Ruby on Rails</em>.<!-- Vaikka palvelinpuolen toteutus saattaa kuulostaa hankalalta, tulemme pian huomaan, että se ei ole sitä, kunhan olemme valinneet hyvät työkalut.-->
  </p>

  <h2>Palvelinohjelmointia JavaScriptillä - Node.js ja Express</h2>
  <p>
    Olemme edeltävillä viikoilla jo tehneet pienen pintaraapaisun Node.js:ään <code>npm</code>:n yhteydessä, mutta vielä ei ole välttämättä täysin selvää, mistä Node.js:ssä. Node.js on Googlen kehittämän <a href="https://code.google.com/p/v8/" target="_blank">V8 JavaScript moottorin</a> päälle rakennettu alusta nopeiden ja skaalautuvien web-sovellusten toteuttamiseen.
  </p>
  <p>
    Node.js-palvelimen toimii tapahtumapohjaisesti, jossa jokaista tapahtumaa käsittelee yksi säie. Jokainen palvelimelle tekemämme kysely, esimerkiksi spoilausten haku, on yksi tapahtuma. Palvelin alkaa käsitellä tapahtumaa (esimerkiksi pyyntöämme) niin, että se ei jää odottamaan, että tapahtuman käsittely on valmis, vaan rekisteröi funktion, jota kutsutaan, kun tapahtuman käsittely on valmis ja ottaa heti toisen tapahtuman (esimerkiksi toisen pyynnön) käsiteltäväksi. Tätä kutsutaan ei-blokkaavaksi I/O-malliksi.
  </p>
  <p>
    Tekniset löpinät sikseen, miten tämä käytännössä toimii? Node.js-palvelimen toteuttaminen olemassaolevia kirjastoja käyttäen on erittäin suoraviivaista, tässä pieni esimerkki porttia <code>3000</code> kuuntelevasta web-palvelimesta:
  </p>

<pre class="sh_javascript_dom">
var http = require('http');

http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}).listen(3000, '127.0.0.1');

console.log('Palvelin odottaa pyyntöäsi osoitteessa http://127.0.0.1:3000');
</pre>

  <p>
    Lisää tämä koodi esimerkiksi työpöydällesi tiedostoon <code>palvelin.js</code> ja suorita terminaalissa työpöydälläsi komento <code>node palvelin.js</code>. Nyt terminaaliin pitäisi ilmestyä viesti <code>Palvelin odottaa pyyntöäsi osoitteessa http://127.0.0.1:3000</code>. Parasta tehdä, kuten käsketään ja siirtyä selaimessa osoitteeseen <code>http://127.0.0.1:3000</code>. Kuten jo varmasti arvasit, sivulle ilmestyy teksti "Hello World".</p>

  <p>Hetkinen, toteutimme siis yksinkertaisen web-palvelimen käynnistävän sovelluksen näin pienellä määrällä koodia? Kuulostaa hullulta, mutta näin on. Vaikkakin edellinen toteutus oli suoraviivainen, on suuremman sovelluksen kehittäminen tältä pohjalta hieman työlästä. Tutustutaan sen vuoksi yhteen Node.js:än suosituimmista web-sovelluskehyksistä, <a href="http://expressjs.com/" target="_blank">Express</a>:iin
  </p>

  <h3>Express - nopea ja minimalistinen web-sovelluskehys Node.js:lle</h3>

  <p>
    Tällä viikolla toteutamme pienen keskustelualuesovelluksen Express-sovelluskehyksellä, ja tutun selainpuolen totetutuksen lisäksi mukana on hieman palvelinohjelmointia. Ennen kuin ryhdymme tositoimiin, puhutaan hieman, mihin palvelinpuolen sovelluksen toiminta perustuu.
  </p>
  <p>
    Kuten jo edellisillä viikoilla on kerrottu, selaimen ja palvelimen välinen kommunikointi perustuu HTTP-protokollaan, jonka avulla palvelin vastaanottaa pyyntöjä selaimelta ja lähettää vastauksen. Olemme tähän mennessä tottuneet samaan palvelimelta GET-pyyntöihimme pääasiassa JSON-muotoisia vastauksia, jonka otsakkeissa on (ainakin toivottavasti) ollut statuskoodi 200, jonka perusteella selain tietää, että pyyntö on kunnossa. GET-pyyntöjen lisäksi olemme tehneet palvelimelle POST-pyyntöjä, joihin olemme tyypillisesti liittäneet jonkinlaista dataa, esimerkiksi JQuerySpoilaajanBackend tehtävässä spoilauksen JSON-muodossa.
  </p>
  <p>
    Pyynnöt kohdistuvat aina johonkin palvelimella sijaitsevaan polkuun. Kun esimerkiksi tehdään GET-pyyntö osoitteeseen <code>http://bad.herokuapp.com/app/spoilers</code>, täytyy osoitteessa <code>http://bad.herokuapp.com</code> olevan palvelinohjelmiston päättää, miten pyyntö polkuun <code>app/spoilers</code> käsitellään. Käytännössä kyseisessä sovelluksessa haetaan kaikki spoilaukset tietokannasta ja lähetetään ne käyttäjälle JSON-muotoon renderöitynä vastauksena.
  </p>
  <p>
    Express tarjoaa erään tavan toteuttaa palvelinrajapinnan, jonka kautta selainpuolen sovellus voi erilaisten HTTP-pyyntöjen avulla tehdä muutoksia tietokantaamme. Tämä tapahtuu yksinkertaisesti määrittelemällä sovellukseen polkuja, joihin voi määrittää eri HTTP-pyyntöjä. Voimme esimerkiksi määrittää, että GET-pyyntöön sovelluksemme polkuun <code>/hello</code> lähettää selaimelle vastauksena tekstin "Hello World":
  </p>

<pre class="sh_javascript_dom">
var express = require('express');
var app = express();

app.get('/hello', function(req, res) {
  res.send('Hello world');
});
</pre>

  <p>
    Esimerkissä ladataan <code>express</code>-moduuli <code>require</code>-funktion avulla, joka on Node.js:än tapa ladata moduuleja. Sen jälkeen voimme <code>get</code>-funktiokutsun avulla määrittää, että GET-pyyntö parametrina annettuun polkuun aiheuttaa toisena parametrina annettun funktion kutsumisen. Toisena parametrina annettu funktio tarvitsee kaksi parametria, joista <code>req</code> sisältää pyyntöön liittyvät tiedot, ja <code>res</code>-parametria käytetään vastauksen muodostamiseen. Tässä esimerkissä selaimelle annetaan vastauksena pelkkää testiä <code>send</code>-funktion avulla. Olisimme yhtä hyvin voineet antaa selaimelle vastauksena pelkän statuskoodin 200 <code>OK</code> kutsulla <code>res.send(200)</code>, tai JSON-muotoisen objektin kutsulla <code>res.json({ message: 'Hello world' })</code>.
  </p>
  <p>
    Aloitetaan seuraavaksi pienen Express-sovelluksen toteuttaminen. Tätä varten sinulle on toteutettu pieni pohja, josta löytyy kaikki valmiina kaikki tarvitsemasi riippuvuudet. Pohja löytyy <a href="https://github.com/web-selainohjelmointi/Foorumi" target="_blank">tästä</a> GitHub repositoriosta. Saat repon omien repojesi joukkoon, kuten viime viikon Elokuvakirjasto-repon, klikkaamalla sivun oikeasta ylälaidasta "Fork"-painiketta, kunhan olet ensin kirjautunut Githubiin. Painikkeen painamisen jälkeen siirryt forkatun repon sivulle, josta voit kopioida "HTTPS clone URL"-kentän sisällön ja suorittaa terminaalissa haluamassasi kansiossa komennon <code>git clone https://github.com/KAYTTAJATUNNUS/Foorumi.git</code>, jossa <code>git clone</code> komennon jälkeinen URL on kopioimasi "HTTPS clone URL"-kentän sisältö. Kun repositorio on kloonattu koneellesi, siirry siihen terminaalissa komennolla <code>cd Foorumi</code> ja suorita komento <code>npm install</code>.
  </p>
  <p>
    Saatat törmätä <code>npm install</code>-komennon suorituksen yhteydessä tähän virheeseen:
<pre class="sh_xml">
npm ERR! sqlite3@2.1.19 install: `node build.js`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the sqlite3@2.1.19 install script.
npm ERR! This is most likely a problem with the sqlite3 package,
npm ERR! not with npm itself.
</pre>
  <p>
    Se johtuu siitä, että Node.js-versiosi on vanhempi kuin <code>0.12</code>, eikä <code>sqlite3</code>-kirjaston asentaminen onnistu. Tämä ongelma saattaa ilmetä, jos suoritit komennon laitoksen koneilla. Ratkaise ongelma suorittamalla terminaalissa komento <code>nvm install 0.12</code>. Kun uudempi versio on asennettu, editoi <code>~/.bashrc</code>-tiedostoa niin, että käytössä on aina versio <code>0.12</code>. Se onnistuu suorittamalla terminaalissa komento <code>vim ~/.bashrc</code>, painamalla "a"-näppäintä, jolloin pääset editoimaan tiedostoa ja korvaamalla rivi <code>nvm use 0.X</code> rivillä <code>nvm use 0.12</code>. Paina sen jälkeen "esc"-näppäintä, syötä terminaaliin <code>wq</code> ja paina <code>enter</code>-näppäintä. Käynnistä terminaali uudelleen ja varmista, että käytettävä version on <code>0.12</code> suorittamalla komento <code>nvm current</code>. Nyt <code>npm install</code>-komennon suorittamisen kanssa ei pitäisi olla ongelmia.
  </p>
  <p>
    Komennon suorittaminen asentaa läjän riippuvuuksia, kuten Express:in. Kun riippuvuudet on asennettu, suorita samaisessa kansiossa komento <code>node bin/www</code>, joka käynnistää palvelimen. Siirry sen jälkeen selaimella polkuun <code>http://localhost:3000</code> ja saavut hieman keskeneräisen keskustelualueen etusivulle. Ryhdytään seuraavaksi hommiin.
  </p>
  <h2>Yksinkertaisen API:n toteuttaminen</h2>
  <p>
    Seuraavaksi toteutamme keskustelualue-sovellukseemme palvelinpuolen API:n, jota selainpuolen sovelluksemme voi käyttää. API (Application programming interface) tarkoittaa ohjelmointirajapintaa, jonka kautta eri ohjelmoivat voivat kommunikoida keskenään. Meidän tapauksessamme haluamme toteuttaa rajapinnan, joka käsittelee selaimen lähettämiä HTTP GET- ja POST-pyyntöjä.
  </p>
  <h3>Sovelluksen mallit</h3>
  <p>
    Tarkastellaan aluksi hieman sovelluksemme malleja, eli minkälaisia olioita haluamme tallentaa ja miten ne liittyvät toisiinsa. Keskustelualue koostuu neljästä mallista:
    <ul>
      <li><strong>Aihealue</strong> (topic), jolla on nimi ja kuvaus. Aihealue voi olla esimerkiksi "ohjelmointikielet", "videopelit" tai "elokuvat". Jokaiseen aihealueeseen kuuluu monta <strong>viestiä</strong>.</li>
      <li><strong>Viesti</strong> (message), jolla on otsikko ja sisältö. Viesti on johonkin <strong>aihealueeseen</strong> liittyvä viestiketju. Esimerkiksi aihealueeseen "ohjelmointikielet" voisi kuulua viestiketju "JavaScript vinkit". Jokaiseen viestiin liittyy aihealueen lisäksi <strong>käyttäjä</strong>, joka sen on lisännyt, sekä monta <strong>vastausta</strong>.</li>
      <li><strong>Vastaus</strong> (reply), jolla on pelkästään sisältö. Vastaus on siis aina tietyn viestiketjun osa. Esimerkiksi "JavaScript vinkit" viestiketjun vastaus voisi olla "Kannattaa kokeilla Angularia". Jokaiseen vastaukseen liittyy <strong>viestin</strong> lisäksi <strong>käyttäjä</strong>, joka sen on lisännyt.</li>
      <li><strong>Käyttäjä</strong> (user), jolla on käyttäjätunnus ja salasana. Käyttäjä voi luoda aihealueita, viestejä ja vastauksia, kunhan hän on vain ensin kirjautunut sisään. Oman käyttäjän voi luoda rekisteröitymällä.</li>
    </ul>
  </p>
  <p>
    Tässä vielä sama UML-kaaviona:
    <p>
    <img src="img/foorumi.png">
    </p>
    Jos et täysin ymmärrä kaaviota, ei hätää, niitä käydään tarkemmin kurssilla Ohjelmistotekniikan menetelmät.
  </p>
  <p>
    Kurkistetaan seuraavaksi, miltä tietosisältö näyttää sovelluksessamme. Avaa <code>Foorumi</code>-kansion <code>models</code>-kansiossa sijaitseva <code>index.js</code>-tiedosto. Voit avata koko <code>Foorumi</code>-kansion NetBeansissa valitsemalla siinä File > New Project > HTML5 > HTML5 Application with Existing Sources ja valitsemalla kansioksi <code>Foorumi</code>-kansion. Tiedoston sisällä on alustettu juuri kuvaillut mallit muodossa, jota sovelluksemme ymmärtää. Kuten huomaat, jokaisessa mallissa on kuvailtujen attribuuttien lisäksi kokonaislukuarvoinen <code>id</code>-attribuutti, jonka avulla mallin oliot erotetaan toisistaan tietokannassa. Jos meillä on esimerkiksi kaksi viestiä, meidän täytyy jotenkin pystyä erottamaan ne toisistaan. Sisällön vertaaminen kuulostaa hankalalta ja lisäksi silloin meillä ei voisi olla kahta viestiä, joilla on sama sisältö. Mallien oliot erotetaankin toisistaan yksilöllisellä kokonaislukuarvolla, joka generoituu automaattisesti. Mallien sisällön määrittelemisen lisäksi, niiden väliset relaatiot on määritelty. Esimerkiksi relaatio "Viestillä on monta vastausta" kuvaillaan sovelluksellemme rivillä <code>Message.hasMany(Reply)</code> ja relaatio "Vastaukseen liittyy käyttäjä" rivillä <code>Reply.belongsTo(User)</code>. Käytämme sovelluksemme datan hakuun ja manipulointiin <a href="http://docs.sequelizejs.com/en/latest/" target="_blank">Sequelize</a>-kirjastoa, josta puhumme lisää myöhemmin.
  </p>
  <h3>Sequelize - datan lisääminen ja hakeminen</h3>
  <p>
    Olet luultavasti alkanut miettimään, että miten sovelluksemme data talletetaan siten, ettei se katoa, kun sammutamme tietokoneemme. Tähän tarkoitukseen meillä on käytössä tietokanta, jossa data pysyy tallessa tietokoneemme kovalevyllä, kuten tiedostosi. Käytössämme on yksinkertainen <a href="https://www.sqlite.org/" target="_blank">SQLite</a> tietokanta, joka tallentaa kaiken sovelluksemme datan yhteen, <code>database.sqlite</code> tiedostoon, joka sijaitsee sovelluksemme kansiossa <code>db</code>. Tämä ratkaisu ei ole kovin hyvä sovelluksiin, joissa on suuret määrät dataa, mutta sovelluksen kehittämiseen pienellä määrällä dataa se on käypä ratkaisu.
  </p>
  <p>
    Jotta datasta olisi jotain hyötyä, tulee sitä pystyä hakemaan ja manipuloimaan. Tähän tarkoitukseen käytämme jo mainittua Sequelize-kirjastoa, joka on nk. <a href="http://en.wikipedia.org/wiki/Object-relational_mapping" target="_blank">ORM</a> (Object-relational mapping)-kirjasto, jonka avulla voimme käyttää tietokantaamme sovelluksessamme helppokäyttöisen rajapinnan kautta ilman tietoa käytössä olevasta tietokantateknologiasta. Hienoa tässä on se, että voimme vaihtaa tietokantamme SQLite-tietokannasta mihin tahansa Sequelize:n tukemaan tietokantaan, kuten PostgreSQLään ilman suurempia muutoksia sovelluksessamme. Ilman ORM:n käyttöä tämä ei onnistuisi, sillä eri tietokantamoottorien hakukielten syntaksi -- vaikka ne ovat tyypillisesti SQL-pohjaisia -- vaihtelee usein paljon.
  </p>
  <p>
    Otetaan muutama käytännön esimerkki, jotta saamme paremman kuvan, mistä oikein tässä <em>mallissa</em> on kyse. Kuvitellaan, että käytössäme on kirja-malli, jolla on nimi (name), julkaisuvuosi (year) ja julkaisija (publisher). Malli kuvaillaan Sequelize:lle seuraavasti:
  </p>

<pre class="sh_javascript_dom">
var Book = sequelize.define('Book', {
  id: { type: Sequelize.INTEGER, autoIncrement: true, primaryKey: true },
  name: Sequelize.STRING,
  year: Sequelize.INTEGER,
  publisher: Sequelize.STRING
});
</pre>

<p>
  <code>name</code>-attribuutti on tyypiltään merkkijono (string), <code>year</code>-attribuutti kokonaisluku (integer) ja <code>publisher</code>-attribuutti merkkijono (string). Lisäämme myös kirjalle <code>id</code>-attribuutin, jotta kirjat voi erottaa toisistaan. Voimme lisätä tietokantaamme uuden kirjan kutsumalla <code>create</code>-funktiota seuraavasti:
</p>

<pre class="sh_javascript_dom">
Book.create({
  name: 'Fahrenheit 451',
  year: 1966,
  publisher: 'Kirjayhtymä'
}).then(function(book){
  console.log(book.name + ' on lisätty tietokantaan onnistuneesti!');
});
</pre>

<p>
  <code>create</code>-funktio ottaa parametrikseen lisättävän objektin. Huomaa, että <code>id</code>-attribuuttia <strong>ei tarvitse asettaa</strong>, koska se generoituu automaattisesti. Kaikki Sequelize:n tietokantaan suorittamat operaatiot ovat <strong>asynkronisia</strong>, joten operaation päätteeksi tulee kutsua <code>then</code>-funktiota, jonka parametrina saatua funktiota kutsutaan, kun operaatio on suoritettu. Katsotaan vielä, miten voimme hakea dataa tietokannasta:
</p>

<pre class="sh_javascript_dom">
// Haetaan kaikki tietokannasta löytyvät kirjat
Book.findAll().then(function(books){
  console.log(books);
});

// Haetaan kirjat, jotka on julkaistu vuonna 1966
Book.findAll({ where: { year: 1966 } }).then(function(books){
  console.log(books);
});

// Haetaan kirja tietyllä id-attribuutilla. Tässä esimerkissä id:llä 1
Book.findOne(1).then(function(book){
  console.log(book);
});

// Haetaan kirja, jonka nimi on "Fahrenheit 451"
Book.findOne({ where: { name: 'Fahrenheit 451' } }).then(function(book){
  console.log(book);
});
</pre>

<p>
  Tietokannasta voidaan hakea tietyn mallin objekteja eri funktioiden avulla. Tässä esimerkissä käytämme funktioita <code><a href="http://docs.sequelizejs.com/en/latest/api/model/#findalloptions-queryoptions-promisearrayinstance" target="_blank">findAll</a></code>, joka palauttaa taulukon mallin objekteja ja <code><a href="http://docs.sequelizejs.com/en/latest/api/model/#findoneoptions-queryoptions-promiseinstance" target="_blank">findOne</a></code>, joka palauttaa yksittäisen objektin. Funktioista molemmat ovat asynkronisia, kuten muutkin tietokannan manipulointiin ja hakuun liittyvät funktiot. Molempiin funktioista voi antaa parametrina objektin, joka kertoo, minkälaisia attribuutteja haettavilla objekteilla tulee olla. <code>findOne</code>-funktion kohdalla parametrin ei tarvitse olla objekti, vaan se voi olla kokonaisluku, joka kertoo, mikä on haettavan objektin <code>id</code>-attribuutin arvo. Jokaisella objektilla on yksilöllinen <code>id</code>-attribuutin arvo, joten tietyllä id:llä löytyy aina yksi objekti (olettaen, että jollakin objektilla on parametrina annettu kokonaisluku <code>id</code>-attribuuttinaan). Molempiin funktioihin voi määrittää <code>where</code> objektin, joka määrittää ehtoja haettujen objektien attribuuteille. Voimme esimerkiksi hakea vain kirjat, joilla on tietty julkaisuvuosi.
</p>
<h3>Selaimen tekemien pyyntöjen käsittely</h3>
<h4>GET-pyyntöjen käsittely</h4>
<p>
  Kuten, jo kävimme lyhyesti läpi, API:n toteuttaminen perustee siihen, että määrittelemme palvelinpuolen sovelluksessamme mitä tehdään, kun selain lähettää tietynlaisen pyynnön tiettyyn polkuun. Siirrytään <code>Foorumi</code>-kansiossa sijaitsevan <code>routes</code>-kansion <code>topics.js</code>-tiedostoon. Tiedosto sisältää valmiiksi määritellyt polut GET- ja POST-pyyntöjä varten. Kaikki polut alkavat polulla <code>/topics</code>, joten tiedostosta määritelty polku <code>/</code> viittaa polkuun <code>/topics</code>. Näin on määritelty <code>Foorumi</code>-kansion tiedostossa <code>app.js</code> kohdassa:
</p>
<pre class="sh_javascript_dom">
var topics = require('./routes/topics');
// ...
app.use('/topics', topics);
</pre>
<p>
  Tämä on tehty vain siitä syystä, että on kätevä jaotella sovelluksen polut eri tiedostoihin, koska niitä kertyy niin paljon. Yksittäisen reitin määrittäminen onnistuu kutsumalla, joko <code>get</code>- tai <code>post</code>-funktiota riippuen, kummanlaiseen pyyntöön halutaan vastata. Tarkastellaan <code>topics.js</code>-tiedoston ensimmäistä reittiä hieman tarkemmin:
</p>
<pre class="sh_javascript_dom">
router.get('/', function(req, res, next) {
    // Hae kaikki aihealueet tässä (Vinkki: findAll)
    res.send(200);
});
</pre>
<p>
  Kun selain tekee GET-pyynnön sovelluksemme polkuun <code>/topics</code> reitissä määriteltyä funktiota. Tällä hetkellä funktio ei tee muuta, kuin lähettää vastauksena statuskoodin 200 kutsumalla <code>res</code>-parametrin <code>send</code>-funktiota. Voisimme lähettää JSON-muotoisen taulukon kutsumalla <code>json</code>-funktiota seuraavasti:
</p>
<pre class="sh_javascript_dom">
router.get('/', function(req, res, next) {
    // Hae kaikki aihealueet tässä (Vinkki: findAll)
    res.json(['a', 'b', 'c']);
});
</pre>
<p>
  Reitin polkuun voi myös määritellä parametreja, jolloin voimme käsitellä pyynnöt sovelluksemme polkuihin <code>/topics/1</code> ja <code>/topics/99</code> yhden reitin määrittelemisellä:
</p>
<pre class="sh_javascript_dom">
router.get('/:id', function(req, res, next) {
  // Hae viesti tällä id:llä ja siihen liittyvät vastaukset tässä (Vinkki: findOne ja sopiva include)
  var messageId = req.params.id;
  res.send(200);
});
</pre>
<p>
  Olemme määritelleet polkuun parametrin <code>id</code> syntaksilla <code>:id</code>. Saamme polkuparametrin pyynnön parametreista <code>id</code>-kentästä (<code>req.params.id</code>.
</p>
<h4>POST-pyyntöjen käsittely</h4>
<p>
  POST-pyynnön käsittely ei juurikaan eroa GET-pyynnön käsittelystä. Ainoa eroavaisuus on, että POST-pyynnön yhteydessä saamme selaimelta usein enemmän dataa. Tämä data voi olla esimerkiksi chattiin lisättävä viesti JSON-muotoisena. Selaimen lähettämään dataan pääsee käsiksi <code>req</code>-parametrin <code>body</code>-kentän kautta. <code>topics.js</code>-tiedostosta löytyy valmis runko reitille aihealueen lisäämiseksi:
</p>
<pre class="sh_javascript_dom">
router.post('/', function(req, res, next) {
  // Lisää tämä aihealue
  var topicToAdd = req.body;
  res.send(200);
});
</pre>
<h4>Postman - API:n testaaminen</h4>
<p>
  <a href="https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm" target="_blank">Postman</a> on Chrome-selaimen plugini, jonka avulla voit helposti testata toteuttamaasi API:a. Sen kautta on helppo lähettää HTTP GET- ja POST-pyyntöjä haluamaasi osoitteeseen ja tarkastella palvelimen lähettämiä vastauksia. Asenna Postman ja siirry sen jälkeen Chrome-selaimella osoitteeseen <a href="chrome://apps/">chrome://apps/</a> ja klikkaa avautuvalta sivulta Postman-ikonia.
</p>
<p>
  Kokeillaan hieman Postman-pluginia viikon 2 Chat-Chat tehtävän kanssa. Viestin haku onnistuu tehtävänannon mukaan seuraavasti: "Viestit saa haettua HTTP GET-pyynnöllä osoitteesta <code>http://bad.herokuapp.com/app/messages</code>. Jos viestien hakeminen onnistuu, palvelin palauttaa statuskoodin 200, muuten statuskoodi on jokin muu". Haetaan viestit Postmanilla lisäämällä "Enter request URL here"-kenttään osoite <code>http://bad.herokuapp.com/app/messages</code> ja valitsemalla viereisestä pudotusvalikosta "GET". Paina sen jälkeen sinistä "Send"-painiketta, jonka jälkeen palvelimelle lähetään GET-pyyntö. Painikkeen alapuolella sijaitsevaan "Body"-tabiin pitäisi ilmestyä palvelimelta saatu JSON-muotoinen vastaus ja "Headers"-tabissa palvelimelta saadun vastauksen otsakkeet. Älä murehdi, jos vastauksena tulee tyhjä taulukko (<code>[]</code>), se vain tarkoittaa, että chatissa ei ole viestejä.
</p>
<p>
  Katsotaan vielä, miten POST-pyynnön lähettäminen onnistuu. Tehtävänannon mukaan chattiin täytyy kirjautua, ennen kuin sinne voi lähettää viestejä. Se onnistuu seuraavasti: "Kun käyttäjä kirjoittaa käyttäjätunnuksen ja painaa Login-nappia, selainsovellus lähettää palvelimelle JSON-merkkijonon, joka on muotoa <code>{ "nickname": nick }</code>, missä <code>nick</code> on käyttäjän kirjoittama käyttäjätunnus. Kirjautumispyyntö tehdään HTTP POST-pyyntönä osoitteeseen <code>http://bad.herokuapp.com/app/auth</code>. Jos kirjautuminen onnistuu, palvelin palauttaa statuskoodin 200, muuten statuskoodi on jokin muu". Aloitetaan, kuten GET-pyynnön kanssa, lisätään "Enter request URL here"-kenttään osoite <code>http://bad.herokuapp.com/app/auth</code>, mutta valitaan viereisesti pudotusvalikosta "GET" sijaan "POST". Lisätään kyselyyn yksi otsake, jotta palvelin tietää, että olemme lähettämässä JSON-muotoista dataa. Se onnistuu klikkaamalla "Headers"-painiketta ja lisäämällä "Header"-kenttään "Content-Type" ja "Value"-kenttään "application/json". Valitse sen jälkeen alapuolelta "raw"-tabi ja sen viereisestä pudotusvalikosta "JSON". Tämän jälkeen voimme lisätä alapuolella sijaitsevaan kenttään JSON-muotoisen objektin, joka sisältää nimimerkkisi. Lisään kenttään esimerkiksi <code>{ "nickname": "foo" }</code> ja klikkaa "send"-painiketta. Palvelimelta pitäisi tulla vastauksena JSON-objekti ja statuskoodi 200.
</p>
<div class="tehtavat">
  <h3>API:n toteuttaminen: Aihealueet</h3>
  <p>
    <strong>Älä koske tämän viikon tehtävien tehtäväpohjiin, vaan toteuta kaikki tehtävät githubista saatavaan <code><a href="https://github.com/web-selainohjelmointi/Foorumi" target="_blank">Foorumi</a></code>-pohjaan. Kun tehtävä on valmis, lähetä vain tehtäväpohja TMC:llä.</strong>
  </p>
  <p>
    Toteuta <code>routes/topics.js</code>-tiedosta määritellyt reitit <code>routes.get('/', ...)</code>, <code>routes.get('/:id', ...)</code> ja <code>routes.post('/', ...)</code> niin, että aihealueita pystyy hakemaan ja lisäämään. Hae reiteistä ensimmäisessä kaikki aihealueet (vinkki: <code><a href="http://docs.sequelizejs.com/en/latest/api/model/#findalloptions-queryoptions-promisearrayinstance" target="_blank">findAll</a></code>) ja palauta ne JSON-muotoisina. Toisessa reitissä hae aihealue id:llä, joka on määritelty muuttujassa <code>topicId</code> (vinkki: <code><a href="http://docs.sequelizejs.com/en/latest/api/model/#findoneoptions-queryoptions-promiseinstance" target="_blank">findOne</a></code>) ja palauta se JSON-muotoisena. Kolmannessa reitissä tallenna muuttujaan <code>topicToAdd</code> talletettu objekti (vinkki: <code><a href="http://docs.sequelizejs.com/en/latest/api/model/#createvalues-options-promiseinstance" target="_blank">create</a></code>). Kun aihealue on lisätty, lähetä selaimelle vastauksena lisätty aihealue JSON-muotoisena. Älä välitä neljännestä reitistä, sitä ei tarvitse vielä toteuttaa.
  </p>
  <p>
    Pääset käyttämään Sequelizen operaatioita <code>topics.js</code>-tiedostossa määritellyn <code>Models</code>-muuttujan kautta. Voit esimerkiksi hakea kaikki aihealueet seuraavasti:
  </p>
<pre class="sh_javascript_dom">
Models.Topic.findAll().then(function(topics){
  console.log(topics)
});
</pre>
<p>
  <strong>Muista, että operaatiot ovat asynkronisia, joten lähetä selameille vastaus vasta <code>then</code>-funktion parametrina annetussa funktiossa! Muista myös käynnistää palvelin uudelleen, kun teet muutoksia. Voit sulkea palvelimen näppäilemällä <code>Ctrl+c</code> ja suorittamalla sen jälkeen <code>node bin/www</code>!</strong>
</p>
<p>
  Toteuta yksi API:n toiminto kerrallaan ja testaa niistä jokaista Postmanin avulla lisäämällä ensin aihealue POST pyynnön osoitteeseen <code>http://localhost:3000/topics</code>, joka sisältää lisättävän aihealuun JSON-muotoisena (katso, miltä aihealue näyttää <code>models/index.js</code>-tiedostosta). Testaa sen jälkeen GET-pyyntöjä osoitteisiin <code>http://localhost:3000/topics</code> ja <code>http://localhost:3000/topics/ID</code>, jossa <code>ID</code> on tietokannassa olevan aihealueen <code>id</code>-attribuutin arvo.
</p>
</div>
<h3>API:n käyttäminen selainpuolen sovelluksessa</h3>
<p>
  Toteutamme sovelluksemme selainpuolen tutulla ja turvallisella Angularilla. Jos kurkistat <code>Foorumi</code>-kansiossa sijaitsevaan <code>public</code>-kansioon, löydät sovellukseen valmiiksi asennetut riippuvuudet <code>bower_components</code>-kansiosta ja Angular-sovelluksen rungon <code>app</code>-kansiosta. Kaikki tarvitsemasi riippuvuudet pitäisi olla asennettuna, mutta voit vapaasti asentaa uusia riippuvuuksia suorittamalla terminaalissa <code>Foorumi</code>-kansion juuressa komennon <code>bower install riippuvuus</code>, tai lisäämällä ne manuaalisesti haluaamasi paikkaan <code>public</code>-kansion sisällä.
</p>
<p>
  Sovelluksen reitit on määritelty <code>app</code>-kansion tiedostossa <code>app.js</code>. Tällä hetkellä reiteissä esitetään vain staattisia näkymiä, eikä niihin ole liitetty yhtäkään kontrolleria. Kansiossa <code>app/views</code> on valmiiksi toteutettuja, staattisia näkymätiedostoja, joita voit halutessasi muokata. Sivupohjan virkaa ajava tiedosto, johon mm. navigaatiopalkki kuuluu, löytyy <code>Foorumi</code>-kansion juuresta tiedostosta <code>views/index.html</code> (ei siis <code>app/views</code>-kansiosta!).
</p>
<p>
  Toteuttamaamme APIa varten on tehty pohja palvelulle <code>Api</code>, joka löytyy kansiosta <code>app/services/api.js</code>. Lisäksi <code>app/controllers</code> löytyy pohjat neljälle kontrollerille, <code>ShowMessageController</code>-, <code>ShowTopicController</code>-, <code>TopicsListController</code>- ja <code>UsersController</code>-kontrollerille.
</p>
<h4>AJAX-pyyntöjen lähettäminen palvelimelle</h4>
<p>
  Angular tarjoaa <code><a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a></code>-palvelun, jonka avulla pystemme lähettämään pyyntöjä palvelimelle. GET-pyyntö onnistuu funktiolla <code>get</code> seuraavasti:
</p>
<pre class="sh_javascript_dom">
$http.get('/messages')
  .success(function(data, status, headers, config){
    console.log('Palvelin lähetti vastauksen!');
    console.log(data);
  })
  .error(function(data, status, headers, config){
    console.log('Jotain meni pieleen...');
  });
</pre>
<p>
  Pyyntö on siis asynkroninen, joten täytyy määrittää, mitä tehdään, kun pyyntö palvelimelta lopulta saapuu perille. Se onnistuu määrittämällä <code>success</code>-funktiolle funktioparametrin, jota kutsutaan, kun palvelimelta tulee myöntävä vastaus statuskoodilla 200. Kutsuttavan funktion ensimmäinen parametri sisältää palvelimelta saadun vastauksen sisällön. Voimme myös antaa <code>error</code>-funktiolle parametriksi funktion, jota kutsutaan, jos palvelimelta ei tule myöntävää vastausta, eli jotain menee pieleen. Se on kätevää, kun halutaan välittää käyttäjälle palvelimen antama virheilmoitus.
</p>
<p>
  GET-pyyntöjen lisäksi voimme tietenkin lähettää POST-pyyntöjä, jossa välitämme pyynnön yhteydessä palvelimelle dataa. Se onnistuu yllätys, yllätys <code>post</code>-funktion avulla:
</p>
<pre class="sh_javascript_dom">
$http.post('/messages', { content: 'Wazzup guys?' })
  .success(function(data, status, headers, config){
    console.log('Palvelin lähetti vastauksen!');
    console.log(data);
  })
  .error(function(data, status, headers, config){
    console.log('Jotain meni pieleen...');
  });
</pre>
<p>
  Lisäämme siis <code>post</code>-funktiokutsun toiseksi parametriksi pyynnön yhteydessä palvelimelle lähetettävän datan. Lähetettävä data muutetaan automaattisesti JSON-muotoon, joten sitä ei tarvitse tässä sitä erikseen tehdä.
</p>
<div class="tehtavat">
  <h3>Aihealueet sovelluksessa (2p)</h3>
   <p>
    <strong>Älä koske tämän viikon tehtävien tehtäväpohjiin, vaan toteuta kaikki tehtävät  <code>Foorumi</code>-kansioon! Kun tehtävä on valmis, lähetä vain tehtäväpohja TMC:llä.</strong>
  </p>
  <p>
    Toteuta seuraavaksi sovellukseesi selainpuolen toiminnot, joiden avulla käyttäjä voi nähdä kaikki aihealueet, nähdä aihealueen tietyllä id:llä ja lisätä aihealueen. <code>app/app.js</code>-tiedostossa on määritelty seuraavat reitit, jotka ovat oleellisia toimintojen toteutuksessa:
  </p>
<pre class="sh_javascript_dom">
FoorumApp.config(function($routeProvider){
  $routeProvider
    .when('/', {
      controller: 'TopicsListController',
      templateUrl: 'app/views/topics/index.html'
    })
    .when('/topics/:id', {
      controller: 'ShowTopicController',
      templateUrl: 'app/views/topics/show.html'
    })
  // ...
});
</pre>
<p>
  Kuten huomaat, sovelluksen etusivulla on staattinen lista aihealueista ja esimerkiksi polusta <code>#/topics/1</code> löytää staattinen sivu aihealueen viesteistä.
</p>
<p>
  Aloita toteuttamalla <code>app/services/api.js</code>-tiedostossa sijaitsevaan <code>Api</code>-palveluun funktiot <code>getTopics</code>, joka hakee kaikki aihealueet API:si polusta <code>/topics</code>, <code>getTopic</code>, joka hakee aihealueen annetulla <code>id</code>-parametrilla API:si polusta <code>/topics/ID</code> ja <code>addTopic</code>, joka lisää <code>topic</code>-parametrina annetun aihealueen tekemällä POST-pyynnön sovelluksesi polkuun <code>/topics</code>. Muistathan, että lisättävä aihealue on <code>{ name: 'aihealueen nimi', description: 'aihealueen kuvaus' }</code>-muotoinen objekti. Muistin virkistämiseksi, AJAX-pyynnöt tehtiin Angularissa <code><a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a></code>-palvelun kautta. Tässä pieni esimerkki sen käyttämisestä:
</p>
<pre class="sh_javascript_dom">
ChatApp.service('Api', function($http){
  // GET-pyyntö polkuun /messages
  this.getMessages = function(){
    return $http.get('/messages');
  }

  // POST-pyyntö polkuun messages. Toinen parametrin on pyynnön mukana välitettävä data
  this.addMessage = function(message){
    return $http.post('/messages', message);
  }
});
</pre>
<p>
  Muistathan, että sekä <code>get</code>-, että <code>post</code>-funktiot lähettävät AJAX-pyynnön palvelimelle asynkronisesti, joten niille tulee antaa parametrina funktio, jota kutsutaan, kun pyyntöön saadaan vastaus palvelimelta. Tämä onnistuu ketjuttamalla pyynnön perään <code>success</code>-funktion kutsu, jota voi käyttää palvelua käyttävässä kontrollerissa seuraavasti:
</p>
<pre class="sh_javascript_dom">
ChatApp.controller('ChatController', function($scope, Api){
  Api.getMessages().success(function(messages){
    $scope.messages = messages;
  });
});
</pre>
<p>
  Kun <code>Api</code>-palvelun funktiot on toteutettu, toteuta kontrolleri niin, että se tarjoaa aihealueiden listaamiseen ja lisäämiseen tarvitut toiminnallisuudet. Aihealueiden listaamiselle on toteutettu valmiiksi staattinen näkymä tiedostossa <code>app/views/topics/index.html</code>. Muokkaa näkymää niin, että se oikeasti listaa sovellukseen talletettuja aihealueita. Samaisen tiedoston alalaidassa on lomake, jonka kautta tulisi pystyä lisäämään uusi aihealue. Käytä tiedostossa <code>app/controllers/topics_list_controller.js</code> löytyvää <code>TopicsListController</code>-kontrolleria hakemaan <code>Api</code>-palvelun <code>getTopics</code>-funktiolla kaikki aihealueet ja listaa ne näkymässä <code>app/views/topics/index.html</code> niin, että listatussa aihealueessa on sen nimi ja kuvaus. Käytä myös samassa kontrollerissa <code>Api</code>-palvelun <code>addTopic</code>-funktiota lisäämään aihealue käyttäjän lomakkeeseen syöttämien tietojen perusteella. Kun käyttäjä on lisännyt aihealueen, ohjaa hänet polkuun <code>/topic/ID</code>, jossa <code>ID</code> on lisätyn aihealueen <code>id</code>-attribuutin arvo (vinkki: <code><a href="https://docs.angularjs.org/api/ng/service/$location" target="_blank">$location</a></code>-palvelun <code>path</code>-funktio).
</p>
<p>
  Toteuta vielä lopuksi tiedostosta <code>app/controllers/show_topic_controller.js</code> löytyvä <code>ShowTopicController</code>-kontrolleri niin, että se hakee <code>id</code>-polkuparametrin perusteella aihealueen käyttämällä <code>Api</code>-palvelun, <code>getTopic</code>-funktiota. Muistathan, että polkuparametrin arvon sai <code><a href="https://docs.angularjs.org/api/ngRoute/service/$routeParams" target="_blank">$routeParams</a></code>-palvelun avulla seuraavasti:
</p>
<pre class="sh_javascript_dom">
FoorumApp.controller('ShowTopicController', function($scope, $routeParams, Api) {
  // id-polkuparametrin arvo
  console.log($routeParams.id);
});
</pre>
<p>
  Muokkaa <code>app/views/topics/show.html</code>-näkymää niin, että sivun otsikkona on aihealueen nimi ja sen alapuolella sen kuvaus. Muuta ei tarvitse vielä tässä tehtävässä muuttaa.
</p>
</div>
<h3>Mallien väliset relaatiot</h3>
<p>
  Kuten ehkä edellisestä tehtävästä arvasit, seuraavaksi meidän pitäisi pystyä liittämään viestejä aihealueisiin. Tietokannan tasolla olemme sen jo tehneet, koska <code>models/index.js</code>-tiedostosta löytyvät seuraavat rivit:
</p>
<pre class="sh_javascript_dom">
Topic.hasMany(Message);
// ...
Message.belongsTo(Topic);
</pre>
<p>
  Tämän perusteella Sequelize tietää, että aihealueseen liittyy monta viestiä ja viesti liittyy yhteen aihealueseen. Seuraava vaihe olisi muokata API:mme <code>/topics/ID</code>-polusta saamaamme JSON-muotoisten objektia niin, että siitä löytyy aihealueen attribuuttien lisäksi siihen liittyvät viestit. Otetaan käyttöön jo tarkkailemamme esimerkki kirja-mallista, joka määriteltiin seuraavasti:
</p>
<pre class="sh_javascript_dom">
var Book = sequelize.define('Book', {
  id: { type: Sequelize.INTEGER, autoIncrement: true, primaryKey: true },
  name: Sequelize.STRING,
  year: Sequelize.INTEGER,
  publisher: Sequelize.STRING
});
</pre>
<p>
  Kirjalla on tietenkin kirjoittaja, joten määritellään se omana mallinaan:
</p>
<pre class="sh_javascript_dom">
var Author = sequelize.define('Author', {
  id: { type: Sequelize.INTEGER, autoIncrement: true, primaryKey: true },
  name: Sequelize.STRING,
  dateOfBirth: Sequelize.DATE
});

Author.hasMany(Book);
Book.belongsTo(Author);
</pre>
<p>
  Kirjaan liittyy nyt aina kirjailija ja kirjailijalla on monta kirjaa. Kuulostaa järkevältä. Voimme nyt hakea tietokannasta kirjailijan ja hänen kirjoittamansa kirjat yhtä aikaa lisäämällä <code>findOne</code>-funktion kutsuun hieman asetuksia:
</p>
<pre class="sh_javascript_dom">
Author.findOne({
  where: { name: 'John Ronald Reuel Tolkien' },
  include: { model: Book }
}).then(function(author){
  console.log(author.Books);
});
</pre>
<p>
  Riittää siis lisätä <code>findOne</code>-funktion kutsuun parametriksi objekti, joka sisältää <code>include</code>-kentän, jossa määritellään, minkä mallien objektit liitetään haettavaan objektiin. Ainoana vaatimuksena on, että mallien välillällä on määritelty relaatio, kuten <code>belongsTo</code>, tai <code>hasMany</code>. <code>include</code>-kentän arvo voi olla myös taulukko, jos mallilla on monta relaatiota. Funktiokutsun seurauksena Sequelize lisää haettavaan kirjailijaan <code>Books</code>-kentän, joka sisältää taulukkona kaikki haettavan kirjalijan kirjat. Relaatiota voi määrittää myös <code>include</code>-kenttään sisäkkäin, jolloin voimme hakea kirjailijan kirjat ja kirjoihin liittyvät julkaisijat:
</p>
<pre class="sh_javascript_dom">
Author.findOne({
  where: { name: 'John Ronald Reuel Tolkien' },
  include: {
    model: Book,
    include: {
      model: Publisher
    }
  }
}).then(function(author){
  console.log(author.Books);
});
</pre>
<p>
  <code>include</code>-objektin käyttö toimii täysin samalla tavalla <code>findAll</code>-funktion kanssa. Jos haluamme lisätä kirjailijalle kirjan, meidän täytyy määrittää lisättävään kirjaan, että se kuuluu tietylle kirjailijalle. Koska olemme määritelleet, että kirjaan liittyy kirjalija, löytyy kirja-objektista kenttä <code>AuthorId</code>, joka kertoo, mikä on kirjailija-objektin <code>id</code>-attribuutin arvo, joka liittyy tähän kyseiseen kirjaan. Jos kirjaan ei liity kirjalijaa, on sen arvo <code>null</code>. Voimme siis määrittää kirjalle kirjailijan määrittämällä lisättävään kirjaan <code>AuthorId</code>-attribuutin:
</p>
<pre class="sh_javascript_dom">
var bookToAdd = {
  name: 'The Hobbit or There and Back Again',
  year: 1937
};

bookToAdd.AuthorId = 1; // Viittaa kirjailijaan nimeltä "John Ronald Reuel Tolkien".

Book.create(bookToAdd).then(function(book){
  console.log(book)
});
</pre>
<p>
  Nyt kirja nimeltä "The Hobbit or There and Back Again" viittaa kirjailijaan, jonka <code>id</code>-attribuutin arvo on 1, joka voisi olla vaikkapa kirjailija nimeltä "John Ronald Reuel Tolkien". Kirjan tapauksessa kentän siihen liittyvän kirjalijan <code>id</code>-attribuutin arvo löytyy kentästä <code>AuthorId</code>. Sama periaate pätee kaikkiin malleihin, joihin liittyy jokin toinen malli, kentän nimi on aina <code>MalliId</code>, jossa <code>Malli</code>, on malliin liittyvän mallin nimi.
</p>
<div class="tehtavat">
  <h3>API:n toteuttaminen: Viestit ja niiden aihealueet (2p)</h3>
  <p>
    <strong>Älä koske tämän viikon tehtävien tehtäväpohjiin, vaan toteuta kaikki tehtävät  <code>Foorumi</code>-kansioon! Kun tehtävä on valmis, lähetä vain tehtäväpohja TMC:llä.</strong>
  </p>
  <p>
    Lisätään seuraavaksi viestit sovelluksemme API:in. Viesteille on määritelty tiedostossa <code>routes/messages.js</code> valmiiksi kaksi reittiä: <code>router.get('/:id', ...)</code> ja <code>router.post('/:id/reply', ...)</code>. Kaikki tiedostossa määritellyt polut alkavat polulla <code>/messages</code>, jonka määrittely löytyy <code>app.js</code>-tiedostosta. Lisäksi viestin lisäämiselle on määritelty reitti <code>router.post('/:id/message', ...)</code> tiedostossa <code>routes/topics</code>. Tämä polku taas alkaa polulla <code>topics</code>, kuten muutkin aihealueisiin liittyvät polut.
  </p>
  <p>
    Hae ensimmäisessä reitissä viesti, jonka <code>id</code>-attribuutin arvo on muuttujan <code>messageId</code>-arvo. Liitä hakuun lisäksi kaikki viestiin liittyvät vastaukset (<code>Reply</code>) (vinkki: <code>findOne</code> ja sopiva <code>include</code>). Muistathan, että sovelluksen mallit löytyvät <code>Models</code>-muuttujasta, joten voit hakea esimerkiksi kaikki viestit seuraavasti:
  </p>
<pre class="sh_javascript_dom">
Models.Message.findAll().then(function(messages){
  console.log(messages);
});
</pre>
<p>
  Lisää toisessa reitissä viestille, jonka <code>id</code>-attribuutin arvo löytyy muuttujassa <code>messageId</code> vastaus, joka löytyy muuttujasta <code>replyToAdd</code> (vinkki: <code>create</code> ja lisää <code>replyToAdd</code>-objektiin kenttä <code>MessageId</code>, jonka arvo on <code>messageId</code>). Lähetä selaimelle vastauksena lisätty vastaus JSON-muotoisena.
</p>
<p>
  Kolmannessa reitissä lisää aihealueelle, jonka <code>id</code>-attribuutin arvo löytyy muuttujasta <code>topicId</code> viesti, joka löytyy muuttujasta <code>messageToAdd</code> (vinkki: <code>create</code> ja lisää <code>messageToAdd</code>-objektiin kenttä <code>TopicId</code>, jonka arvo on <code>topicId</code>). Lähetä selaimelle vastauksena lisätty viesti JSON-muotoisena.
</p>
<p>
  Muokkaa vielä lopuksi tiedostossa <code>routes/topics.js</code> määriteltyä reittiä <code>router.get('/:id', ...)</code>. Niin, että se lisää haettuun aihealueeseen siihen liittyvät viestit (vinkki: lisää vain <code>findOne</code>-funktion parametriksi objekti, jossa on sopiva <code>include</code>-kenttä).
</p>
<p>
  Varmista vielä Postmanilla, että toteuttamasi toiminnot toimivat seuraavasti:
  <ul>
    <li>
      Tee GET-pyyntö osoitteeseen <code>http://localhost:3000/topics</code> ja ota talteen jonkun aihealueen <code>id</code>-attribuutti JSON-muotoisesta taulukosta. Jos taulukko on tyhjä, lisää uusi aihealue tekemällä POST-pyyntö polkuun <code>http://localhost:3000/topics</code>, joka sisältää JSON-muotoisena lisättävän aihealueen (muoto on <code>{ "name": "aihealueen nimi", "description": "aihealueen kuvaus" }</code>). Lisää sen jälkeen valitsemallesi aihealueelle viesti tekemällä POST-pyyntö polkuun <code>http://localhost:3000/topics/ID/message</code> (osoitteessa <code>ID</code> on valitsemasi aihealueen <code>id</code>-attribuutin arvo), joka sisältää lisättävän viestin JSON-muotoisena (muoto on <code>{ "title": "viestin otsikko", "content": "viestin sisältö" }</code>). Vastauksena pitäisi tulla lisätty viesti JSON-muotoisena.
    </li>
    <li>
      Tee GET-pyyntö osoitteeseen <code>http://localhost:3000/topics/ID</code>, jossa <code>ID</code> äskeisessä kohdassa valitsemasi aihealueen <code>id</code>-attribuutin arvo. Varmista, että vastauksena saadusta JSON-muotoisessa objektista löytyy <code>Messages</code>-kenttä, josta löytyy taulukko, jossa on vähintään yksi objekti, joka on edellisessä kohdassa lisäämäsi viesti. Tee myös GET-pyyntö osoitteeseen <code>http://localhost:3000/messages/ID</code>, jossa <code>ID</code> on kyseisen viestin <code>id</code>-attribuutin arvo. Vastauksena pitäisi tulla viesti JSON-muotoisena objektina. Objektissa pitäisi olla myös <code>Replies</code>-kenttä, jossa on luultavasti tyhjä taulukko.
    </li>
    <li>
      Tee vielä lopuksi POST pyyntö osoitteeseen <code>http://localhost:3000/messages/ID/reply</code> (<code>ID</code> on äskeisessä kohdassa tarkkailemasi viestin <code>id</code>-attribuutin arvo), joka sisältää lisättävän vastauksen JSON-muotoisena (muoto on <code>{ "content": "vastauksen sisältö" }</code>). Vastauksena pitäisi tulla lisätty vastaus JSON-muotoisena. Tee vielä uudestaan GET-pyyntö osoitteeseen <code>http://localhost:3000/messages/ID</code>, jossa <code>ID</code> on sama kuin POST-pyynnön kanssa. Varmista, että viestin JSON-muotoisesen objektin <code>Replies</code>-kentän taulukossa on nyt vähintään yksi objekti, joka sisältää äsken lisäämäsi vastauksen.
    </li>
  </ul>
</p>
</div>
<div class="tehtavat">
  <h3>Viestit sovelluksessa (2p)</h3>
  <p>
    <strong>Älä koske tämän viikon tehtävien tehtäväpohjiin, vaan toteuta kaikki tehtävät <code>Foorumi</code>-kansioon! Kun tehtävä on valmis, lähetä vain tehtäväpohja TMC:llä.</strong>
  </p>
  <p>
    Muokataan seuraavaksi sovellustamme API:in tekemiemme muutosten mukaiseksi. Aloitetaan muokkaamalla näkymää <code>app/views/topics/show.html</code>, joka näyttää yksittäisen aihealueen ja siihen liittyvät viestit. Muokkaa näkymää niin, että siinä listataan aihealueen viestit ja listan otsikko kertoo, kuinka monta viestiä aihealueessa on (muista selkeä suomen kieli, vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngPluralize" target="_blank">ng-pluralize</a></code>-direktiivi). Muistathan, että aihealueen viestit pitäisi olla <code>Messages</code>-kentässä haetusta aihealue-objektista. Sinun ei tarvitse vielä välittää viestin alalaidassa olevasta "Käyttäjätunnus tähän"-kohdasta, mutta lisää viestin lisäysaika. Sequelize lisää automaattisesti lisättyihin objekteihin kentän <code>createdAt</code>, joka kuvaa aikaa, jolloin objekti on lisätty. Käytä sitä esittämään viestin lisäysaika ja käytä pohjassa annettua formaattia (vinkki: <code><a href="https://docs.angularjs.org/api/ng/filter/date" target="_blank">date</a></code>-filtteri). Jos joudut tekemään muutoksia kontrolleriin, löydät sen tiedostosta <code>app/controllers/show_topic_controller.js</code>.
  </p>
  <p>
    Seuraavaksi käyttäjän pitäisi pystyä lisäämään aihealueeseen viesti. Aloitetaan toiminnon toteuttaminen toteuttamalla <code>app/services/api.js</code>-tiedostosta löytyvään <code>Api</code>-palveluun funktio <code>addMessage</code>, joka lähettää POST pyynnön API:si polkuun <code>/topics/ID/message</code> (jossa <code>ID</code> on <code>topicId</code>-parametrin arvo), joka sisältää parametrina saadun <code>message</code> objektin (vinkki: <code><a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a></code>-palvelu). Muisthan, että lisättävä viesti on <code>{ title: 'viestin otsikko', content: 'viestin sisältö' }</code>-muotoinen objekti. Katso tarvittaessa mallia toteuttamastasi <code>addTopic</code>-funktiosta. Kun palvelun funktio on toteutettu, muokkaa tiedostosta <code>app/controllers/show_topic_controller.js</code> löytyvää kontrolleria ja näkymää <code>app/views/topics/show.html</code> niin, että viestin lisäys onnistuu näkymän alalaidasta löytyvän lomakkeen kautta. Kun käyttäjä on lisännyt viestin, ohjaa hänet lisätyn viestin sivulle. Muistathan, että POST-pyyntö API:n polkuun <code>/topics/ID/message</code> palauttaa lisätyn viestin, jonka <code>id</code>-attribuutin perusteella voit ohjata käyttäjän polkuun <code>/messages/ID</code> (vinkki: <code><a href="https://docs.angularjs.org/api/ng/service/$location" target="_blank">$location</a></code>-palvelun <code>path</code>-funktio).
  </p>
  <p>
    Siirrytään seuraavaksi viestin sivulle, joka staattinen versio löytyy sovelluksen sivulta <code>#/messages/1</code>. Tämä reitti on määritelty tiedostossa <code>app/app.js</code> seuraavasti:
  </p>
<pre class="sh_javascript_dom">
FoorumApp.config(function($routeProvider){
  $routeProvider
    // ...
    .when('/messages/:id', {
      controller: 'ShowMessageController',
      templateUrl: 'app/views/messages/show.html'
    })
    // ...
});
</pre>
<p>
  Polussa <code>/messages/:id</code> näytetään siis näkymä <code>app/views/messages/show.html</code> ja siihen liitetään kontrolleri <code>ShowMessageController</code>, joka löytyy tiedostosta <code>app/controllers/show_message_controller.js</code>. Huomaat, että näkymän otsikkona on viestin otsikko, jonka alapuolella on viestin sisältö. Sisällön alapuolelta taas löytyy otsikko, joka kertoo kuinka monta vastausta viestillä on ja sen alapuolelta löytyy listattuna kaikki vastaukset. Älä tässäkään näkymässä välitä kohdasta "Käyttäjätunnus tähän", palaamme siihen myöhemmin.
</p>
<p>
  Jotta pystymme esittämään viestin ja siihen liittyvät vastaukset, täytyy ne ensin hakea API:ltamme. Toteutetaan siis <code>Api</code>-palveluun funktio <code>getMessage</code>, joka tekee GET-pyynnön API:n polkuun <code>/messages/ID</code>, jossa <code>ID</code> on funktion <code>id</code>-parametrin arvo. Voit käyttää toteuttamaasi funktiota <code>ShowMessageController</code>-kontrollerissa seuraavasti:
</p>
<pre class="sh_javascript_dom">
FoorumApp.controller('ShowMessageController', function($scope, $routeParams, $location, Api){
  Api.getMessage($routeParams.id).success(function(message){
    $scope.message = message;
  });
});
</pre>
<p>
  Saamme siis esitettävän viestin <code>id</code>-attribuutin polkuparametrista <code><a href="https://docs.angularjs.org/api/ngRoute/service/$routeParams" target="_blank">$routeParams</a></code>-palvelun avulla. Nyt voimme esittää viestin ja siihen liittyvät vastaukset <code>app/views/messages/show.html</code>-näkymässä. Muisthan, että viestiin liittyvien vastausten pitäisi olla viesti-objektin <code>Replies</code>-kentässä.
</p>
<p>
  Toteuta vielä lopuksi toiminto, jonka avulla käyttäjä voi lisätä viestiin vastaukseen. Tee se toteuttamalla <code>Api</code>-palveluun funktio <code>addReply</code>, joka lähettää POST-pyynnön sovelluksesi polkuun <code>/messages/ID/reply</code> (jossa <code>ID</code> on funktion <code>messageId</code>-parametrin arvo), joka sisältää <code>reply</code>-parametrin arvon. Muistathan, että vastaus on <code>{ content: 'vastauksen sisältö' }</code>-muotoinen objekti. Tee sen jälkeen tarvittavat muutokset <code>ShowMessageController</code>-kontrolleriin ja <code>app/views/messages/show.html</code>-näkymään. Kun käyttäjä on lisännyt vastauksen, lisää vastaus viesti-objektin <code>Messages</code>-taulukkoon, niin se tulee näkyviin näkymässä.
</p>
</div>
<h3>Yksinkertainen autentikaation toteuttaminen</h3>
<p>
  Emme halua, että kuka tahansa pääsee käyttämään sovelluksemme toimintoja, vaan haluamme rajata ne vain kirjautuneille käyttäjille. Olemme jo määritelleet käyttäjälle mallin <code>models/index.js</code>-tiedostossa. Lisäksi on määritelty, että käyttäjällä on monta viesti ja vastausta sekä, että viestiin ja vastaukseen liittyy käyttäjä:
</p>
<pre class="sh_javascript_dom">
// ...

var User = Database.sequelize.define('User', {
  id: { type: Database.DataTypes.INTEGER, autoIncrement: true, primaryKey: true },
  username: Database.DataTypes.STRING,
  password: Database.DataTypes.STRING
});

// ...

User.hasMany(Message);
User.hasMany(Reply);

Message.belongsTo(User);
Reply.belongsTo(User);

//...
</pre>
<p>
  Käyttäjällä on siis attribuutit <code>username</code> (käyttäjätunnus) ja <code>password</code> (salasana). Toteutetaan seuraavaksi sovellukseemme erittäin yksinkertainen autentikaatio, joka katsoo, löytyykö tietokannastamme käyttäjää annetulla käyttäjätunnuksella ja salasanalla. Jos käyttäjä löytyy, autentikaatio onnistuu, muuten se epäonnistuu. Siirrytään tiedostoon <code>routes/users.js</code>, johon on määritelty seuraava reitti:
</p>
<pre class="sh_javascript_dom">
// POST /users/authenticate
router.post('/authenticate', function(req, res, next){
  // Tarkista käyttäjän kirjautuminen tässä. Tee se katsomalla, löytyykö käyttäjää annetulla käyttäjätunnuksella ja salasanalla (Vinkki: findOne ja sopiva where)
  var userToCheck = req.body;
  res.send(200);
});
</pre>
<p>
  Reitti siis vastaa POST-pyyntöihin polkuun <code>/users/authenticate</code> ja olettaa saavansa pyynnön yhteydessä objektin, joka sisältää kentät <code>username</code> ja <code>password</code>, jotka vastaavat käyttäjätietoja, joilla käyttäjä yrittää authentikoitua. Toteutetaan reitti niin, että jos käyttäjä löytyy annetulla käyttäjätunnuksella ja salasanalla, lähetämmä vastauksena JSON-muotoisen objektin löytyneestä käyttäjästä, muuten lähetämme statuskoodin 403 (forbidden), joka kertoo vastauksen lähettäjälle, että authentikaatio epäonnistui. Voimme käyttää toteutukseen tuttua <code>findOne</code>-funktiota, johon lisäämme yksinkertaisen <code>where</code>-objektin:
</p>
<pre class="sh_javascript_dom">
// POST /users/authenticate
router.post('/authenticate', function(req, res, next){
  var userToCheck = req.body;

  if(userToCheck == null || userToCheck.username == null || userToCheck.password == null){
    res.send(403);
  }

  Models.User.findOne({
    where: {
      username: userToCheck.username,
      password: userToCheck.password
    }
  }).then(function(user){
    if(user){
      req.session.userId = user.id;
      res.json(user)
    }else{
      res.send(403);
    }
  });
});
</pre>
<p>
  Authentikaatiosta ei ole hyötyä, jos emme sen yhteydessä tallenna tietoa, kuka käyttäjä on authentikoitunut jollain tavalla. Tallennammekin tiedon kirjautuneesta käyttäjästä <strong>sessioon</strong> rivillä <code>req.session.userId = user.id;</code>. Session on palvelimelle tallennettu tieto, joka liittyy tiettyyn palvelimelle pyyntöjä lähettävään asiakaskoneeseen. Toisin sanoen, kun authentikoidun onnistuneesti jonkun käyttäjätunnuksen ja salasanan avulla, palvelimelle tallennetaan sessioon tieto, että käyttämäni asiakaskone olen authentikoitunut käyttäjällä, jonka <code>id</code>-attribuutin arvo on tallettu session avaimeen <code>userId</code>. Tämä tieto ei kuitenkaan säily palvelimella ikuisesti, mutta tarpeeksi kauan, jotta käyttäjä voi käyttää sovellusta ilman, että hänen täytyy authentikoitua jatkuvasti uudelleen.
</p>
<p>
  Toteuteen vielä funktio, joka tarkastaa, onko käyttäjä kirjautunut sisään, eli toisin sanoen tarkastaa, onko <code>req.session.userId</code>-asetettu. Toteutetaan funktio tiedostoon <code>utils/authentication.js</code>-seuraavasti:
</p>
<pre class="sh_javascript_dom">
var authentication = function(req, res, next) {
  if (!req.session.userId || req.session.userId == null) {
    res.send(403);
  } else {
    next();
  }
}

// ...
</pre>
<p>
  Funktio siis tarkistaa, että session <code>userId</code>-avain on asetettu. Jos avainta ei ole asetettu, käyttäjä ei ole authentikoitunut ja lähetämme vastauksena statuskoodin 403 (forbidden). Muuten käyttäjä on authentikoitunut ja kutsumme mystistä <code>next</code>-funktiota.
</p>
<p>
  Kuten ehkä huomaat, funktio näyttää erittäin paljon reiteissä määriteltyjä funktioita, jotka käsittelevät pyyntöjä. Se johtuu yksinkertaisesti siitä, että tätäkin funktiota käytetään pyynnön käsittelyyn, sillä tarkastelemme siinä pyyntöön liittyvää sessiota. Toteuttamamme funktio on Express:in nk. <a href="http://expressjs.com/guide/using-middleware.html" target="_blank">middleware</a>-funktio, joita voi määrittää reitteihin ennen itse pyyntöä käsittelevää funktiota. <code>else</code>-haarassa kutsuttava <code>next</code>-funktio tarkoittaa vaan sitä, että voimme siirtyä seuraavaan middleware-funktioon. Käytetään seuraavaksi toteuttamaamme middleware-funktiota aihealueen lisäyksen yhteydessä. Sille löytyi reitti tiedostossa <code>routes/topics.js</code>:
</p>
<pre class="sh_javascript_dom">
// POST /topics
router.post('/', authentication, function(req, res, next) {
  // ...
});
</pre>
<p>
  Toteuttamme funktio on tallennettu muuttujaan <code>authentication</code> (näet sen tiedoston ensimmäisillä riveillä) ja se on nyt lisätty <code>post</code>-funktiokutsun toiseksi parametriksi ennen pyynnön lopullista käsittelijää. Nyt POST-pyyntö polkuun <code>/topics</code> etenee niin, että ensin kutsutaan <code>authentication</code>-funktiota. Jos käyttäjä ei ole authentikoitunut, pyyntöön vastataan statuskoodilla 403, joten lopulliseen käsittelijään ei siirrytä ollenkaan. Jos käyttäjä taas on authentikoitunut, kutsumme funktiota <code>next</code>, jolloin siirrymme lopulliseen käsittelijäämme, jossa lisäämme annetun aihealueen. Lisää sama middleware-funktio myös reitteihin, jotka lisäävät viestin ja vastauksen, niin käyttäjä ei pääse lisäämään niitä ilman authentikoitumista.
</p>
<p>
  Tällä hetkellä selainpuolella on hieman ikävää, että käyttäjä näkee aihealueen, viestin ja vastauksen lisäyslomakkeen, mutta lisääminen niiden kautta ei onnistu, koska palvelin vastaa pyyntöihin statuskoodilla 403. Ne pitäisi siis kokonaan piilottaa, jos käyttäjä ei ole kirjautunut sisään. Käyttäjä ei pysty myöskään kirjautumaan sisään ja sen jälkeen kirjautumaan ulos, eikä rekisteröitymään. Seuraavissa tehtävissä puutumme näihin ongelmiin.
</p>
<div class="tehtavat">
  <h3>API:n toteuttaminen: Käyttäjät</h3>
  <p>
    <strong>Älä koske tämän viikon tehtävien tehtäväpohjiin, vaan toteuta kaikki tehtävät  <code>Foorumi</code>-kansioon! Kun tehtävä on valmis, lähetä vain tehtäväpohja TMC:llä.</strong>
  </p>
  <p>
    Jatketaan API:mme toteuttamista käyttäjien osalta. Varmista aluksi, että olet toteuttanut äskeisessä osiossa toteutetun käyttäjän authentikoitumisen käsittelevän reitin tiedostossa <code>routes/users.js</code> ja authentikoitumisen tarkistavan funktion tiedostossa <code>utils/authentication.js</code>. Varmista myös, että olet lisännyt <code>authentication</code>-funktion aihealueen, viestin ja vastauksen lisäämisen käsittelevään reittiin middleware-funktioksi.
  </p>
  <p>
    Toteutaan seuraavaksi käyttäjän rekisteröityminen, eli uuden käyttäjän lisääminen. Sille löytyy reitti <code>routes.post('/', ...)</code> valmiina tiedostosta <code>routes/users.js</code>. Ennen kuin lisäät käyttäjän vanhalla tutulla <code>create</code>-funktiolla, tarkista ennen, ettei käyttäjätunnusta ole varattu <code>findOne</code>-funktion ja sopivan <code>where</code>-objektin avulla. Muistathan, että pääset käyttämään <code>User</code>-mallia <code>Models</code>-muuttujan kautta seuraavasti:
  </p>
<pre class="sh_javascript_dom">
Models.User.findOne({
  where: { username: 'foo' }
}).then(function(user){
  console.log(user);
});
</pre>
<p>
  Kun käyttäjä on lisätty, lähettä vastauksena lisätty käyttäjä JSON-muotoisena. Jos käyttäjätunnus oli jo olemassa lähetä vastauksena statuskoodilla 400 (bad input) <code>{ error: 'Käyttäjätunnus on jo käytössä!' }</code>-objekti JSON-muotoisena. Voit liittää vastaukseen erikseen statuskoodin seuraavasti:
</p>
<pre class="sh_javascript_dom">
res.status(400).json({ error: 'Käyttäjätunnus on jo käytössä!' });
</pre>
<p>
  Kuten huomaat, salasana on tällä hetkellä selkokielisenä muodossa, joka on tietoturvan kannalta erittäin huono asia. Tietoturva ei ole kuitenkaan tämän kurssin kannalta olennaista, mutta jos asia kiinnostaa sinua, voi salasanat esittää hajakoodatussa muodossa esimerkiksi <a href="https://github.com/ncb000gt/node.bcrypt.js/" target="_blank">tämän</a> kirjaston avulla.
</p>
<p>
  Kun käyttäjä lisääminen on toteutettu, hae kirjautunut käyttäjä reitissä <code>router.get('/logged-in', ...)</code>. Siihen soveltuu <code>findOne</code>-funktio, joka ottaa parametrikseen muuttujan <code>loggedInId</code>. Lähetä vastauksena kirjautunut käyttäjä JSON-muodossa.
</p>
<p>
  Muokataan vielä tiedostossa <code>routes/topics.js</code>-olevaa reittiä <code>router.get('/:id', ...)</code> niin, että se liittää aihealueen viesteihin niiden käyttäjät. Tee sama reitille <code>router.get('/:id', ...)</code> tiedostossa <code>routes/messages.js</code>, jossa liitä viestin vastauksiin niiden käyttäjät. Muistathan, että <code>include</code>-objekteja pystyi määrittämään sisäkkäin seuraavasti:
</p>
<pre class="sh_javascript_dom">
Models.Topic.findOne({
  where: {
    id: 1
  },
  include: {
    model: Models.Message,
    include: {
      model: Model.User
    }
  }
}).then(function(topic){
  console.log(topic);
});
</pre>
<p>
  Liitetään lopuksi lisättävään viestiin ja aihealueeseen käyttäjä. Se onnistuu yksinkertaisesti lisäämällä <code>messageToAdd</code>-objektiin kentät <code>TopicId</code> ja <code>UserId</code> siten, että niiden arvot viittaavat liitettävien objektien <code>id</code>-attribuuttien arvoihin seuraavasti:
</p>
<pre class="sh_javascript_dom">
// ...
var messageToAdd = req.body;
messageToAdd.TopicId = topicId;
messageToAdd.UserId = req.session.userId;

Models.Message.create(messageToAdd).then(function(message){
  console.log(message);
});
</pre>
<p>
  Vastaavasti vastauksen yhteydessä lisää <code>MessageId</code>-kentän arvoksi muuttujan <code>messageId</code> arvo.
</p>
</div>
<div class="tehtavat">
  <h3>Käyttäjät sovelluksessa (2p)</h3>
  <p>
    <strong>Älä koske tämän viikon tehtävien tehtäväpohjiin, vaan toteuta kaikki tehtävät  <code>Foorumi</code>-kansioon! Kun tehtävä on valmis, lähetä vain tehtäväpohja TMC:llä.</strong>
  </p>
  <p>
    Sovelluksemme on enään käyttäjien selainpuolen toteutusta vaille valmis. Käyttäjille on määritelty sovellukseemme seuraavat reitit tiedostossa <code>app/app.js</code>:
  </p>
<pre class="sh_javascript_dom">
FoorumApp.config(function($routeProvider){
  $routeProvider
    // ...
    .when('/login', {
      controller: 'UsersController',
      templateUrl: 'app/views/users/login.html'
    })
    .when('/register', {
      controller: 'UsersController',
      templateUrl: 'app/views/users/register.html'
    })
    // ...
});
</pre>
<p>
  Kirjautumissivu löytyy polusta <code>/login</code>, joka esittää näkymän, joka löytyy tiedostosta <code>app/views/users/login.html</code>.Rekisteröitymissivu löytyy taas polusta <code>/register</code>, joka esittää näkymän, joka löytyy tiedostosta <code>app/views/users/register.html</code>. Molemmissa reiteissä on käytössä <code>UsersController</code>-kontrolleri, jonka pohja löytyy tiedostosta <code>app/controllers/users_controller.js</code>.
</p>
<p>
  Aloita kirjautumisen ja rekisteröitymisen toteuttaminen lisäämällä tiedostosta <code>app/services/api.js</code> löytyvään <code>Api</code>-palveluun funktiot <code>login</code> ja <code>register</code> (vinkki: <code><a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a></code>-palvelu). Muisthan, että käyttäjä on <code>{ username: 'käyttäjätunnus', password: 'salasana' }</code>-muotoinen objekti. Muista lisäksi, että virheellisen kirjautumisen yhteydessä palvelin lähettää statuskoodin 403, joten voimme käsitellä epäonnistuneen kirjautumisen kontrollerissamme <code>error</code>-funktiolla:
</p>
<pre class="sh_javascript_dom">
Api.login({ username: 'foo', password: 'bar'})
  .success(function(user){
    console.log('Kirjautuminen onnistui!');
    console.log(user);
  })
  .error(function(){
    console.log('Kirjautuminen epäonnistui! Lisätään käyttäjälle virheilmoitus');
    $scope.errorMessage = 'Väärä käyttäjätunnus tai salasana!';
  });
</pre>
<p>
  Näytä epäonnistuneen kirjautumisen yhteydessä käyttäjälle kirjautumislomakkeessa jokin virheilmoitus, jos kirjautuminen onnistuu, ohjaa käyttäjä aihealueet listaavalla sivulle, eli polkuun <code>/</code> (vinkki: <code><a href="https://docs.angularjs.org/api/ng/service/$location" target="_blank">$location</a></code>-palvelun <code>path</code>-funktio).
</p>
<p>
  Kun kirjautuminen on toteutettu, toteuta rekisteröityminen. Muista, että jos käyttäjä yrittää rekisteröityä käyttäjätunnuksella, joka on jo käytössä, tulee palvelimelta vastauksena statuskoodi 400, jonka mukana tulee objekti <code>{ error: 'Käyttäjätunnus on jo käytössä!' }</code>. Voit huomata tämän käyttämällä kyselyn kanssa <code>error</code>-funktiota, kuten kirjautumisenkin kanssa ja näyttää käyttäjälle virheilmoituksen. Jos rekisteröityminen onnistuu, ohjaa käyttäjä aihealueet listaavalla sivulle, eli polkuun <code>/</code>, kuten kirjautumisenkin kanssa.
</p>
<p>
  Kun sekä kirjautuminen, että rekisteröityminen on toteutettu, muokkaa näkymiä <code>app/views/topics/show.html</code>, joka listaa viestit ja näkymää <code>app/views/messages/show.html</code>, joka näyttää aihealueen vastaukset niin, että kohdassa "Käyttäjätunnus tähän" on viestin tai vastauksen lisännyt käyttäjä. Muistathan, että käyttäjä-objekti pitäisi löytyä kentästä <code>User</code>.
</p>
<p>
  Viimeistellään sovelluksemme vielä niin, että käyttäjä voi kirjautua ulos, eikä käyttäjä näe aihealueen, viestin tai vastauksen lisäämislomaketta ilman, että hän on kirjautunut sisään. Jos katsot tiedostoa <code>app/app.js</code>, näet, että tiedoston lopusta löytyy koodipätkä, joka lisää funktion <code>logOut</code> sovelluksemme globaaliin näkyvyysalueeseen, eli <code>$rootScope</code>-objektiin. Jos menet tiedostoon <code>views/index.html</code>, joka on sivupohjamme, huomaat, että navigaatiossa on linkki "Kirjaudu ulos", jota painattaessa funktiota <code>logOut</code> kutsutaan. Linkki ei tosin näytetä, koska se näytetään vain, jos <code>userLoggedIn</code>-muuttujalla on arvo, jota sillä ei vielä ole.
</p>
<p>
  Toteuta <code>Api</code>-palveluun vielä funktio <code>getUserLoggedIn</code>, jonka jälkeen voimme lisätä reitteihimme <code>resolve</code>-objektin, joka hakee kirjautuneen käyttäjän ennen kuin reitti ladataan. Lisätään siihen funktio, joka hakee käyttäjän, joka on kirjautunut sisään ja lisää sen <code>$rootScope</code>-objektiin. Käytännössä se onnistuisi näin:
</p>
<pre class="sh_javascript_dom">
FoorumApp.config(function($routeProvider){
  $routeProvider
    .when('/', {
      controller: 'TopicsListController',
      templateUrl: 'app/views/topics/index.html',
      resolve: {
        userLoggedIn: function($rootScope, Api){
          return Api.getUserLoggedIn().success(function(user){
            $rootScope.userLoggedIn = user.username ? user : null;
          });
        }
      }
    })
    // ...
</pre>
<p>
  Lisää tämä <code>resolve</code> objekti jokaiseen reittiin, niin kirjautunut käyttäjä tarkastetaan jokaisessa reitissä ennen kuin se ladataan. Nyt voimme lisätä näkymiin <code>app/views/topics/show.html</code> ja <code>app/views/messages/show.html</code> ja <code>ng-if</code>-direktiivit, jotka näyttävät lisäyslomakkeet vain, jos <code>userLoggedIn</code>-muuttujalla on arvo. Lisäksi kirjautumisen jälkeen navigaation pitäisi ilmestyä "Kirjaudu ulos"-linkki, jota klikkaamalla käyttäjä voi kirjautua ulos.
</p>
</div>
<h2>Node.js-sovellus Herokuun</h2>
<p>
  Lisätään seuraavaksi toteuttamme Foorumi-sovellus Herokuun. Se onnistuu lähes yhtä suoraviivaisesti, kuin viime viikolla Herokuun lisäämämme Elokuvakirjasto-sovellus. Tällä kertaa emme tosin käytä Firebasea, vaan tarvitsemme Herokulta tietokannan. Kun kehitimme sovellustamme omalla koneellamme käytössämme oli SQLite-tietokanta ja siitä mainittiikin, ettei se ole hyvä vaihtoehto tuotantoympäristössä, kuten Herokussa. Heroku tarjoaa onneksi meille PostgreSQL-tietokannan, johon vaihtaminen ei vaikuta sovellukseemme juuri ollenkaan.
</p>
<p>
  Aloitetaan luomalla uusi Heroku-sovellus suorittamalla <code>Foorumi</code>-kansion juuressa komento <code>heroku create</code>. Jos et ole vielä asentanut Heroku Toolbelt:iä, lue viime viikon ohje "Sovellus muiden nähtäville: Heroku". Kun komento on suoritettu, pyydetään Herokulta käyttöömme PostgreSQL-tietokantaan suorittamalla <code>Foorumi</code>-kansion juuressa komento <code>heroku addons:add heroku-postgresql:dev</code>. Terminaaliin pitäisi ilmestyä tätä muistuttava teksti:
</p>
<pre class="sh_xml">
Adding heroku-postgresql:dev on fast-dusk-7858... done, v5 (free)
Attached as HEROKU_POSTGRESQL_BRONZE_URL
Database has been created and is available
 ! This database is empty. If upgrading, you can transfer
 ! data from another database with pgbackups:restore.
Use `heroku addons:docs heroku-postgresql:dev` to view documentation.
</pre>
<p>
  Tässä tapauksessa PostgreSQL-tietokannan URL löytyy konfiguraatiomuuttujasta <code>HEROKU_POSTGRESQL_BRONZE_URL</code>, mutta sen nimi vaihtelee, joten tarkasta, minkä niminen se on omassa tapauksessasi. Suorita sen jälkeen komento <code>heroku config:get HEROKU_POSTGRESQL_BRONZE_URL</code>, jossa <code>HEROKU_POSTGRESQL_BRONZE_URL</code> on oman konfiguraatiomuuttujasti nimi. Terminaaliin pitäisi ilmestyä tätä muistuttava teksti:
</p>
<pre class="sh_xml">
postgres://pfforbjhkrletg:aic5oO6Cran1g3hk6mJa5QqNZB@ec2-23-21-91-97.compute-1.amazonaws.com:5432/dek11b2j1g3mfb
</pre>
<p>
  Tämä on PostgreSQL-tietokantasi URL, jonka kautta siihen saa muodostettua yhteyden. Kopioi se talteen, tarvitsemme sitä pian. Seuraavaksi meidän täytyy kertoa Sequelize:lle, että käytössämme ei ole enää SQLite-tietokanta, vaan PostgeSQL-tietokanta. Se onnistuu siirtymällä tiedostoon <code>db/connection.js</code> ja korvaamalla muuttujan <code>sequelize</code>-arvo seuraavasti:
</p>
<pre class="sh_javascript_dom">
var sequelize = new Sequelize('postgres://gtoisioduequfh:MST5G0EEMFkbWWQMrUqsudkxLa@ec2-54-163-226-9.compute-1.amazonaws.com:5432/d99fquooctquiv', {
  dialect: 'postgres',
  protocol: 'postgres'
});
</pre>
<p>
  Korvaa vain ensimmäinen parametri oman PostgreSQL-tietokannan URL:illasi.
</p>
<p>
  Suorita seuraavaksi <code>Foorumi</code>-kansion juuressa komennot <code>git add -A</code>, <code>git commit -m "Sovellus Herokuun"</code> ja <code>git push heroku master</code> (juuri tässä järjestyksessä!). Heroku alkaa valmistelemaan sovellustasi. Kun se on valmis suorita lopuksi komento <code>heroku run node db/seed.js</code>, joka alustaa tietokannan ja avaa sovelluksesi selaimessasi suorittamalla <code>heroku open</code>. Se on siinä!
</p>
<p>
  Älä pelästy siitä, että sivuilla ei ole mitään sisältöä. Se johtuu yksinkertaisesti siitä, että tietokantasi on vaihtunut ja se on toistaiseksi tyhjä.
</p>
</section>
</article>


</body>
</html>
